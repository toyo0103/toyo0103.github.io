<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程式隨筆</title>
  
  
  <link href="https://toyo0103.github.io/atom.xml" rel="self"/>
  
  <link href="https://toyo0103.github.io/"/>
  <updated>2022-12-03T08:03:19.101Z</updated>
  <id>https://toyo0103.github.io/</id>
  
  <author>
    <name>Toyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How cache-control directives affect caching?</title>
    <link href="https://toyo0103.github.io/2022/12/03/cache_control_directives/"/>
    <id>https://toyo0103.github.io/2022/12/03/cache_control_directives/</id>
    <published>2022-12-03T07:00:00.000Z</published>
    <updated>2022-12-03T08:03:19.101Z</updated>
    
    <content type="html"><![CDATA[<p>I’m curios how <code>cache-control</code> directives affect caching, so I make a small experiment to see the interaction between browser, reverse proxy and server.</p><p>I introduce 6 APIs that respond different cache-control value in response header and current time only.</p><table><thead><tr><th align="left"></th><th align="left">Reponse Cache-Control</th></tr></thead><tbody><tr><td align="left">[GET]/cache/get-public</td><td align="left">public,max-age=120</td></tr><tr><td align="left">[GET]/cache/get-private</td><td align="left">private,max-age=120</td></tr><tr><td align="left">[GET]/cache/get-unset</td><td align="left">max-age=120</td></tr><tr><td align="left">[DELETE]/cache/delete-public</td><td align="left">public,max-age=120</td></tr><tr><td align="left">[DELETE]/cache/delete-private</td><td align="left">private,max-age=120</td></tr><tr><td align="left">[DELETE]/cache/delete-unset</td><td align="left">max-age=120</td></tr></tbody></table><p>Create a simple web page for test<br><img src="/images/20221103/0.png" alt="/images/20221103/0.png"></p><p>Clicking the buttons will call the APIs and show the response data on page. At the same time I monitor the developer tool to record the results.</p><p>Whether the browsers cache the response? (tested on safari, chrome and edge)</p><table><thead><tr><th align="center"></th><th align="center">Public</th><th align="center">Private</th><th align="center">Unset</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">V</td><td align="center">V</td><td align="center">V</td></tr><tr><td align="center">DELETE</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table><p>Whether the reverse proxy(I use nginx) caches the response?</p><table><thead><tr><th align="center"></th><th align="center">Public</th><th align="center">Private</th><th align="center">Unset</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">V</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="center">DELETE</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table><p>According the results, we know the modern browsers would not break the rule of <code>cacheable</code> and reverse proxy may not store the response when you don’t set public/private directives.</p><div class="note info">            <p>References</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">Cache-Control - HTTP | MDN (mozilla.org)</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/cacheable">Cacheable - MDN Web Docs Glossary: Definitions of Web-related terms | MDN (mozilla.org)</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I’m curios how &lt;code&gt;cache-control&lt;/code&gt; directives affect caching, so I make a small experiment to see the interaction between browser,</summary>
      
    
    
    
    
    <category term="Cache" scheme="https://toyo0103.github.io/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient doesn&#39;t change cookie value per request</title>
    <link href="https://toyo0103.github.io/2022/08/08/http_client_does_not_change_cookie_value_per_request/"/>
    <id>https://toyo0103.github.io/2022/08/08/http_client_does_not_change_cookie_value_per_request/</id>
    <published>2022-08-08T03:00:00.000Z</published>
    <updated>2022-08-09T14:30:13.203Z</updated>
    
    <content type="html"><![CDATA[<p>Recently I found that the HttpClient doesn’t change cookie value per request, and it will cache the value for 2 minutes after the first request which have set the cookie value sent.</p><h1 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h1><ul><li>dotnet 5</li><li>runtime image: mcr.microsoft.com/dotnet/aspnet:5.0</li></ul><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>I use typed client in our project and use HttpRequestMessage to set the cookie “user.token” in every request.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyHttpClient</span> : <span class="title">IMyHttpClient</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HttpClient _httpClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHttpClient</span>(<span class="params">HttpClient httpClient</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._httpClient = httpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">CallAPI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> request = <span class="keyword">new</span> HttpRequestMessage(HttpMethod.Post, <span class="string">&quot;/the/api&quot;</span>);</span><br><span class="line">        <span class="comment">// set request content</span></span><br><span class="line">        request.Content = <span class="keyword">new</span> StringContent(<span class="string">&quot;mydata&quot;</span>, Encoding.UTF8, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="comment">// set cookie here</span></span><br><span class="line">        request.Headers.Add(<span class="string">&quot;Cookie&quot;</span>, <span class="string">$&quot;user.token=<span class="subst">&#123;token&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> _httpClient.SendAsync(request);</span><br><span class="line">        response.EnsureSuccessStatusCode();</span><br><span class="line">        <span class="keyword">var</span> res = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Register MyHttpClient to the Denpency Injection provider.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services.AddHttpClient&lt;IMyHttpClient, MyHttpClient&gt;(config =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    config.BaseAddress = <span class="keyword">new</span> Uri(<span class="string">&quot;https://my.server.com&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>When I use <code>CallAPI()</code> of MyHttpClient, I found the cookie doesn’t change value per request, and it will cache value for 2 minutes.</p><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>HttpClient is just a container of <code>HttpClientHandler</code>. If you trace the source code on <a href="https://github.com/dotnet/extensions/blob/v3.1.8/src/HttpClientFactory/Http/src/DefaultHttpClientFactory.cs">Github</a> you will see the code</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpClient <span class="title">CreateClient</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> handler = CreateHandler(name);</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient(handler, disposeHandler: <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> options = _optionsMonitor.Get(name);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; options.HttpClientActions.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        options.HttpClientActions[i](client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpMessageHandler <span class="title">CreateHandler</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> entry = _activeHandlers.GetOrAdd(name, _entryFactory).Value;</span><br><span class="line"></span><br><span class="line">    StartHandlerEntryTimer(entry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry.Handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When you are asking for HttpClient, HttpClientFactory will generate a HttpClient instance everytime and try to get HttpMessageHandler from the pool. Why HttpClientFactory maintains HttpMessageHandler pool for us? Because creating TCP connections are extremely expensive, so we should reuse it as we can as possible.</p><p>So multiple HttpClients will possibly use same HttpMessageHandler. HttpMessageHandler has Property named CookieContainer. It will store cookie value when you first time to set the value. So it will cause different requests using same cookie value until HttpMessageHandler expired.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>There is a way to stop HttpMessageHandler using CookieContainer.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">services.AddHttpClient&lt;IPortalShellClient, PortalShellHttpClient&gt;(config =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    config.BaseAddress = <span class="keyword">new</span> Uri(clientConfig.PortalSiteEndpoint);</span><br><span class="line">&#125;)</span><br><span class="line">.ConfigurePrimaryHttpMessageHandler(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Tell HttpMessageHandler to stop using CookieContainer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpClientHandler &#123; UseCookies = <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Then you can set cookie value per request now.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://stackoverflow.com/questions/65227400/do-pooled-httpclient-instances-keep-the-cookiecontainer">Do pooled HttpClient instances keep the CookieContainer?</a></p></li><li><p><a href="https://github.com/microsoft/referencesource/blob/master/System/net/System/Net/Http/HttpClientHandler.cs">HttpClientHandler.cs</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Recently I found that the HttpClient doesn’t change cookie value per request, and it will cache the value for 2 minutes after the first r</summary>
      
    
    
    
    
    <category term="dotnet core" scheme="https://toyo0103.github.io/tags/dotnet-core/"/>
    
  </entry>
  
  <entry>
    <title>[讀書心得][領域驅動設計與 .Net Core] Chapter2: 語言與情境</title>
    <link href="https://toyo0103.github.io/2022/05/25/book_hands_on_ddd_with_dotnet_ch2/"/>
    <id>https://toyo0103.github.io/2022/05/25/book_hands_on_ddd_with_dotnet_ch2/</id>
    <published>2022-05-25T14:00:00.000Z</published>
    <updated>2022-08-09T13:36:17.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="建立共同語言"><a href="#建立共同語言" class="headerlink" title="建立共同語言"></a>建立共同語言</h2><p>這章主是在講述語言的重要性，而語言又如何直接間接的影響到系統的成敗。這邊的語言並非指程式語言，而是指在相同情境下大家所共同理解的語言，就用 <code>User</code> 這個詞來舉例，在不同情境下就可能代表著不同意義</p><ul><li>對購物網站而言 : User 可能代表的是逛商城的<em>消費者</em></li><li>對商城平台而言 : User 可能代表是<em>進駐的廠商</em></li><li>對商城後台而言 : User 可能代表的是<em>進駐廠商的員工</em></li></ul><p>一個 User 在各個情境下代表著不同意義，想關注的事情也不盡相同，當我們沒有情境為背景下，單單用 User 做為溝通可能會陷入雞同鴨講的狀況，這就是情境之於語言為何重要的地方。</p><div class="note info">            <p>過去開會時發現一個現象，時常開發單位與需求單位在溝通時，彼此對於同一個東西用的詞是完全不同的，當需求單位在描述事情時，較新進或對 Domain 不熟的開發人員可能會弄不清楚對方在說什麼，這時候就需要熟的人在旁邊補充「他指的是系統裡的 xxx」，而會產生這樣的差距，常常是因為開發人員將他們的工作視為”將需求翻譯成程式語言”，所以程式內的語言可能自成一格，並與現實用語脫鉤，而這類的情況一多，當不同背景的人共同溝通時就會需要彼此一直翻譯，翻譯的狀況越多，中間遺失掉的”知識”可能就越多，大家應該都有看過翻譯很爛的書的經驗吧…</p>          </div><p>所以書中建議為不同背景的人找尋共同用語相當重要，這可以減少溝通時因為翻譯而導致的落差，書中舉了一個很真實的案例：當使用者在廣告系統中發佈 (publish) 廣告時，為了避免帶有惡意或不適當的內容，會讓該廣告進入審核的流程 ….，而當這個需求轉化為程式語言後可能會變成</p><ul><li>當使用者按下 publish 按鈕時，將廣告狀態更新為 Published，並且發出<code>廣告狀態已變更(AdStatusUpdated)</code>的事件</li><li>審核系統收到 <code>廣告狀態已變更(AdStatusUpdated)</code> 事件時將廣告撈出來排入審核流程</li></ul><p>看出這中間有多大的落差了嗎？我們在系統中不用 <code>廣告已被發佈(AdPublished)</code>，取而代之的是<code>廣告狀態已變更（AdStatusUpdated）</code>，發佈的動作轉化成狀態的變更，需求在這大量轉化為系統程式碼的過程中，很有可能原始的意圖早已消失，而這可能正是關鍵知識遺失的過程。</p><h2 id="精準需求的迷失"><a href="#精準需求的迷失" class="headerlink" title="精準需求的迷失"></a>精準需求的迷失</h2><p>每當我們交付功能給客戶，面對客戶的不滿意時，常常歸因於<code>需求描述的失準</code>，開發團隊內會互相抱怨、指責，開發者埋怨開需求的人規格亂寫，開需求的人埋怨開發者搞不清楚也不問，導致開發出來的系統與最終想解決的問題有一大段落差，所以團隊可能會開始找更厲害的 PO 或 PM，開始要求規格書的格式，試圖用鉅細彌遺厚厚一本的規格書來彌補與真實之間的落差。</p><p>而事實真的是這樣嗎？很多時候開發人員是沒有機會直接面對需求單位或業務人員的，所以當這些需求單位透過與系統分析師描述後，再透過<code>系統分析師的理解</code>轉化成規格書，這中間可能就已經遺失了一部分真實。</p><div class="note info">            <p>很多時候會議內所謂的共識，是你以為你的共識，我以為我的共識，實際上彼此認知的事情根本不是一回事，等雙方都告一段落後回來一對才發現跟當時說的不一樣，但彼此都覺得自己是照當時的決議實作的啊，所以問題可能不是雙方背信，而是彼此認知根本不在同一個點上。</p>          </div><p>書中提到可以嘗試在溝通中，用視覺化的方式彌平彼此認知的落差，而我自己的經驗也發現，大量的文字描述常常聽者很難聚焦，當開始把各個會議中談到的東西視覺化，輔助上依賴關係與線性流程，有助於幫助與會人員更能聚焦在同一個點上。<br><img src="/images/20220525/1.jpg" alt="/images/20220525/1.jpg"><br>圖片來源: 領域驅動設計與 .Net Core 書中 p.26</p><h2 id="透過新的術語發現新的情境"><a href="#透過新的術語發現新的情境" class="headerlink" title="透過新的術語發現新的情境"></a>透過新的術語發現新的情境</h2><p>最前面提到在不同情境下，User 可能代表的意義完全不同，當我們在討論過程中可能會脫口而出<code>前台的消費者</code>、<code>平台的廠商</code>、<code>後台的管理者</code>…等等，而當這些用語的不同時，其實也幫助了我們發現了<code>新的情境</code>，針對這些新出現的情境建立對應的模型是需要的，對比於前面只用 <code>使用者(User)</code>來描述，後者更精準也更貼近真實，這也可以避免開發者寫出近乎於上帝類別的 User 來。 </p><p>雖然短短一小篇，但發現要把讀完的東西用自己的話再說一次真的還有一段差距啊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;建立共同語言&quot;&gt;&lt;a href=&quot;#建立共同語言&quot; class=&quot;headerlink&quot; title=&quot;建立共同語言&quot;&gt;&lt;/a&gt;建立共同語言&lt;/h2&gt;&lt;p&gt;這章主是在講述語言的重要性，而語言又如何直接間接的影響到系統的成敗。這邊的語言並非指程式語言，而是指在相同情</summary>
      
    
    
    
    <category term="領域驅動設計與.Net Core" scheme="https://toyo0103.github.io/categories/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"/>
    
    
    <category term="DDD" scheme="https://toyo0103.github.io/tags/DDD/"/>
    
    <category term="讀書心得" scheme="https://toyo0103.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
    <category term="領域驅動設計與 .Net Core" scheme="https://toyo0103.github.io/tags/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"/>
    
  </entry>
  
  <entry>
    <title>[讀書心得][領域驅動設計與 .Net Core] Chapter1: 為什麼需要領域驅動設計</title>
    <link href="https://toyo0103.github.io/2022/05/23/book_hands_on_ddd_with_dotnet/"/>
    <id>https://toyo0103.github.io/2022/05/23/book_hands_on_ddd_with_dotnet/</id>
    <published>2022-05-23T14:52:00.000Z</published>
    <updated>2022-08-09T13:36:17.079Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20220523/cover.jpg" alt="/images/20220523/cover.jpg"><br>圖片來源: <a href="https://www.tenlong.com.tw/products/9789864348602">https://www.tenlong.com.tw/products/9789864348602</a></p><p>第一章講述了軟體發展史中，為了解決軟體開發上的困境許多方法被發明了出來，而雖然每個方法都宣稱能有效解決（或部分解決）專案上的問題，但經過統計，成功的專案始終不超過 22%。而 DDD 也是為了解決軟體開發時所碰到的困境所被提出來的一種方法。</p><p>軟體通常是為了解決某些問題而被研發的，所以當<code>錯誤的理解問題</code>就很容易導致失敗，人類在解決問題上有著豐富的經驗，所以當人類看到問題時，通常會有一些<code>直覺的解決方案</code>浮出腦中（快思慢想也有提到這點），這可能源自於你的經驗或是過往學經歷，而這<code>直覺的好點子</code>很高的可能是錯誤的方向，而人往往又會傾向於找盡各種方法試圖說服自己<code>剛剛的好點子</code>是正確的，即便在實作的過程中隱約察覺到不對勁了…</p><div class="note info">            <p>個人經驗中有察覺到這個現象，常常誤以為自己一開始的想法是正確的，所以即便過程中發現問題也會用各種變形方法試圖將問題套入其中，而這往往會將問題變得更複雜。</p><p>我曾經跟專案成員討論目前框架使用上的困境，而我發現大部分人會傾向在框架中設計各種 Config 、環境變數切換來滿足所謂的特殊情境，而沒有去思考框架設計是否瞄準錯了問題。又或是為了解決部署環境問題，直接聯想到 Container 解決方案，結果為了管理 Container 所以引入更複雜的 k8s 做為編排的工具，也許本質想解決的問題沒這麼複雜，卻在解決的過程中意外的把問題變得更複雜。</p>          </div><h2 id="避免無知"><a href="#避免無知" class="headerlink" title="避免無知"></a>避免無知</h2><p>書本中將無知分類成五個層級</p><ul><li>缺少無知(lack of ignorance) : 表示你擁有大部分的知識，知道「該做什麼」、「怎麼做」</li><li>缺乏知識(lack of knowledge) : 你意識到自己的無知，所以你獲取更多知識來填補知識的落差</li><li>缺乏意識(lack of awareness) : 「不知道自己不知道」，連意識到無知都沒有，例如拿到規格就覺得自己知道要解決的問題是什麼了，而忽略了其實自己根本不知道本質問題是什麼狀況，人往往會做出錯誤決策都屬這層</li><li>缺乏流程(lack of process) : 你不知道你自己不知道是什麼，也無管道能弄清楚</li><li>元無知(meta igonorance) : 連無知的五個層次都不知道 </li></ul><p>DDD 之父 Eric Evans 對於「提前設計」提出了見解 : 我們在專案的初期會進行提前設計的動作，而此時恰好也是我們擁有「最少知識」並且是最無知的時期。在專案開始時幾乎沒有知識的情況下，就對軟體的設計和架構做出大多數的「重要決策」，這不會是個好的做法。</p><div class="note info">            <p>個人覺得這跟敏捷中提到的小增量多迭代道理是一樣的，我們很難在專案初期就了解問題的全貌，所以小步前進，並且因應碰到的問題即時快速的調整，才能讓我們越來越貼近真實情況的樣貌，也可以降低在專案初期的過度設計，導致架構一直調整的窘境。</p>          </div><p>隨著現代專案要處理的問題越來越複雜（可能是質或是量的複雜度），有效的處理<code>領域知識</code>、<code>減少無知</code>，準確將問題分類，避免實現目標路途中的認知偏誤，DDD 就是想要解決這些問題所被提出的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20220523/cover.jpg&quot; alt=&quot;/images/20220523/cover.jpg&quot;&gt;&lt;br&gt;圖片來源: &lt;a href=&quot;https://www.tenlong.com.tw/products/97898643486</summary>
      
    
    
    
    <category term="領域驅動設計與.Net Core" scheme="https://toyo0103.github.io/categories/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"/>
    
    
    <category term="DDD" scheme="https://toyo0103.github.io/tags/DDD/"/>
    
    <category term="讀書心得" scheme="https://toyo0103.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
    <category term="領域驅動設計與 .Net Core" scheme="https://toyo0103.github.io/tags/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"/>
    
  </entry>
  
  <entry>
    <title>弱雞 Tech Lead 初體驗</title>
    <link href="https://toyo0103.github.io/2022/05/20/become_a_tech_lead/"/>
    <id>https://toyo0103.github.io/2022/05/20/become_a_tech_lead/</id>
    <published>2022-05-20T15:39:00.000Z</published>
    <updated>2022-08-09T13:36:17.079Z</updated>
    
    <content type="html"><![CDATA[<p>近期很後悔自己中斷了寫部落格的習慣，為了重新養成這個習慣，所以有了這開春第一篇文章（都快夏天了老闆～），而既然是開春第一篇，想說就來寫些較軟性的題目好了（絕對不是我技術都沒長進的關係啦…），所以今天就來聊聊近期與團隊共患難的事情好了。</p><p>可能老闆知道我今年犯太歲的關係，不能讓我太好過，所以年初就派我去擔任一個 5 人小團隊的 tech lead，一開始本來懷抱著 “大家都很優秀，我應該只要去幫大家打打雜就好”的心態加入，殊不知考驗才剛剛開始。</p><p>這個團隊負責的是一個架構與開發框架性質的專案，亦即它的設計未來可能會直接影響 N 個團隊的開發習慣與 N 個服務掛在上面的行為，所以它的難度不低，加上初期時程壓力、人力吃緊的情況下，體質並不是很好，例如：</p><ul><li>專案幾乎沒有測試，上線常常發生改 A 壞 B 的情況</li><li>文件非常多，但跟實際系統運作邏輯有不小的落差</li><li>系統在還不穩固的情況下已經釋出 SDK 給團隊使用，加大改版向下相容的挑戰</li><li>Release 純手工，過程中需要人工介入調整許多地方，不熟的人看文件還要花半天以上才能搞定</li><li>框架本身的目標與使用該框架的服務需求間的拉扯，導致初期就有高度客製化的狀況，增加了後續入住這個框架得複雜度</li><li>資料庫版控管理不佳，每次更版幾乎都要倒資料，間接也讓服務開不出 API，因為實時的資料異動會導致資料遺失</li></ul><p>基於上述原因，團隊士氣其實並不高，因為即便是看似簡單的功能上線都如履薄冰，加上該專案是受到重視的專案（被定位為乘載公司未來性的框架），人員陸續補進來，團隊的壓力也隨之增加，因為人力往往與產值掛鉤，給予對應的人力沒有對應的產值是無法被接受的。</p><p>所以初期我花最多時間思考的不是怎麼滿足需求，反而是該如何穩住系統跟增加開發成員的信心，在軟體業也快 10 年了，新需求與改需求是不會有停止的一天，每個跟你談的需求都會很急很趕，不急不趕才是新聞，所以與其追著需求跑，我更在思考的是</p><ol><li>該如何穩住這個系統 ? 讓開發人員有信心，讓新進人員能在最短時間成為戰力</li><li>這個框架到底想解決的本質問題是什麼？ 如果它沒有守住那條線，這個框架基本上也沒有存在的價值</li></ol><p>所以我跟主管談了一個方案，農曆年前約三週時間需求我一律不收也不處理，一切請他幫我緩到農曆年後再說，對內開始跟團隊成員著手處理以下問題</p><ol><li>重建系統核心<br>我開始與團隊成員梳理目前系統運作的脈絡，對我來說系統要在不斷變動的環境下發展，不外乎讓你的程式碼能好好說明系統在做什麼，如果連幾個類別物件間的互動關係都說不清楚寫不好，又該如何期待這成千上萬行的程式碼堆疊出來系統會有一套清晰的邏輯在運作。又如何期待新進工程師能在眾多的文件中自己理出系統邏輯，縱然文件全然正確，理解文件後對應到程式碼的運作，這中間還有一段很長的路要走。所以我很喜歡 Uncle Bob 說的『世界上最好的文件應該是你的程式碼。』<br>這個觀念剛好也契合 DDD 中所強調的，把你的專注力先放在解決核心問題上，把問題之外的資料庫、 Schema、 軟體分層、作業系統先切開，先用最簡單的類別與物件來展示你要解決的業務邏輯，當這些都說得通、運作得當，剩下的都是支撐這個核心的基礎建設而已。</li></ol><ol start="2"><li>建立單元測試<br>我與團隊成員立下的第一個約定就是 “MR 只要沒有單元測試一律退回”，我認為確保寫出來的程式運作邏輯的正確性是身為工程師的基本素養，Code Review 應該是讓大家討論與互相學習的場域，並試著透過多人 Review 從不同角度尋找盲點，防止重大舞弊、效能、資安…等問題，不要期待 Reviewer 能用肉眼幫你找出所有漏洞，如果寫單元測試都無法保證系統百分之百正確了，更何況不寫。<br>寫單元測試好處真的很多，除了能用最低成本快速驗證你的想法與程式碼之外，它也在保護你的團隊成員，當專案龐大到一個程度，團隊內成員對於 Code 與各個需求掌握度也都會有落差，所以當未來需求變動時，它能幫忙把關是否哪邊因為變動而出錯了。</li></ol><ol start="3"><li>重新梳理開發流程與 CI/CD<br>與團隊成員討論了之前的分支策略後利弊後，我們開始改成 trunk-based 的跑法，試著降低大家解衝突的時間，並逼大家思考持續整合回 Master 的相容性問題，同時也開始投入資源建立 CI/CD ，讓一些明確與重複的流程自動化，降低部署的時間與負擔。穩固快速的部署流程不單單只是減少時間的浪費，往往也能增加團隊成員的信心，你會有信心即便真的最後出錯了，我們都有機會在很短的時間內迭代修復或退版，就像打籃球時有個超強中鋒幫你搶籃板一樣，各個投三分都跟 Curry 一樣有信心 (最近都在看 NBA 季後賽啦)。</li></ol><p>經過一番奮戰後，我們終於在總共花了 4 週多的時間，將原本幾乎開不出 API 的系統，陸續釋出 20多支的 API 上線，並且交付批次工具幫助協作單位整合資料，解決了之前常常需要手動進資料庫塞資料與髒資料橫行的問題，也終於終於得到了團隊成員的第一次肯定（淚）。 </p><p>但人生往往不會這麼簡單，你懂的 …</p><p>待續 … </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期很後悔自己中斷了寫部落格的習慣，為了重新養成這個習慣，所以有了這開春第一篇文章（都快夏天了老闆～），而既然是開春第一篇，想說就來寫些較軟性的題目好了（絕對不是我技術都沒長進的關係啦…），所以今天就來聊聊近期與團隊共患難的事情好了。&lt;/p&gt;
&lt;p&gt;可能老闆知道我今年犯太歲</summary>
      
    
    
    
    <category term="工程師的那些事" scheme="https://toyo0103.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
    
    <category term="工程師的那些事" scheme="https://toyo0103.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>淺談 CQRS</title>
    <link href="https://toyo0103.github.io/2021/08/15/intro_cqrs/"/>
    <id>https://toyo0103.github.io/2021/08/15/intro_cqrs/</id>
    <published>2021-08-15T15:37:00.000Z</published>
    <updated>2022-08-09T13:36:17.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前專案就使用過 CQRS 做為系統的架構來開發，但一直覺得自己『知其然，而不知其所以然』，剛好最近出了一本<a href="https://www.tenlong.com.tw/products/9789864347926">CQRS 命令查詢職責分離模式</a> 所以就買回來把他讀完了，趁記憶還很清晰時趕快做一下筆記，以下的內容參雜了許多自己的見解，歡迎大家一起討論</p><h1 id="什麼是-CQRS"><a href="#什麼是-CQRS" class="headerlink" title="什麼是 CQRS"></a>什麼是 CQRS</h1><p>CQRS 全名為 Command Query Responsibility Segregation ，意即<strong>命令</strong>與<strong>查詢</strong>分離的設計模式，而</p><ul><li>Command : 會對系統狀態或資料做出異動的行為</li><li>Query : 單純取得資料不會對系統狀態造成異動的行為</li></ul><p>以傳統 CRUD 類比的話，CUD = Command，R = Query</p><h1 id="為什麼需要-CQRS"><a href="#為什麼需要-CQRS" class="headerlink" title="為什麼需要 CQRS"></a>為什麼需要 CQRS</h1><h2 id="降低複雜度"><a href="#降低複雜度" class="headerlink" title="降低複雜度"></a>降低複雜度</h2><p>我自己接觸過的大部分系統，大多都是以維護資料做為出發點來設計的系統，例如專案內一定會有所謂的 Repository Layer ： 一個提供各種 API 並能對資料做 CRUD 的封裝層。<br>系統本來就是一系列對資料維護的過程，這樣做有錯嗎？ 只要商業情境不要太複雜的話，大部分都沒什麼問題，但如果系統規模越做越大，商業情境越來越複雜，如果只是用 CRUD 的思維來設計系統，往往會讓複雜度越疊越高，甚至到不可收拾的地步。<br>舉個例子，你應該看過這樣的 API</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">MemberDto member</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> memberEntity = MemberRepository.Get(member.Id);</span><br><span class="line">    <span class="keyword">if</span>(memberEntity == <span class="literal">null</span>) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullReferenceException(<span class="string">&quot;Member not found.&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>.IsNullOrEmpty(member.Name)) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(member.Name));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(DateTime.TryParse(member.Birthday, <span class="keyword">out</span> <span class="keyword">var</span> birthday) == <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="keyword">nameof</span>(member.Birthday));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bla bla bla ....</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span>.IsNullOrEmpty(member.Password)) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(member.Password));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set Entity ...</span></span><br><span class="line"></span><br><span class="line">    memberEntity.Password = member.Password;</span><br><span class="line"></span><br><span class="line">    MemberRepository.Update(memberEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個 API 可能包含了對 Member 資料的各種邏輯驗證，而呼叫這個 API 的你可能只是為了完成密碼變更而已，這份 Code 硬要說沒什麼大問題，但也體現了從 CRUD 角度設計出的 API 可能隨著商業邏輯的日益複雜，複雜度可能會成長到非常可怕的地步，而這也是 CQRS 中想避免的事情。</p><h2 id="Command-會這樣做"><a href="#Command-會這樣做" class="headerlink" title="Command 會這樣做"></a>Command 會這樣做</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ResetPasswordCommand command</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> member = MemberRepository.Get(command.Id);</span><br><span class="line">    <span class="keyword">if</span>(memberEntity == <span class="literal">null</span>) </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullReferenceException(<span class="string">&quot;Member not found.&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//領域模型知道 ResetPassowrd 的相關驗證與知識</span></span><br><span class="line">    member.ResetPassword(command.Password);</span><br><span class="line"></span><br><span class="line">    MemberRepository.Update(member);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-貼近現實世界的用語"><a href="#1-貼近現實世界的用語" class="headerlink" title="1. 貼近現實世界的用語"></a>1. 貼近現實世界的用語</h3><p>PO 會對我們說需要<code>會員註冊</code>的功能，而不會說需要<code>新增會員</code>的功能，而通常<code>更換密碼</code>與<code>忘記密碼</code>會是完全不一樣的流程，用 <code>UpdatePassword</code> 很難精準說明這裡面做了什麼，你可能需要翻程式碼看流程，才能說出這個方法內包含了哪些商業情境，而這正是 Command 想避免的。</p><h3 id="2-貼近商業邏輯"><a href="#2-貼近商業邏輯" class="headerlink" title="2. 貼近商業邏輯"></a>2. 貼近商業邏輯</h3><p>一個 Command 只做一件事情，而 Command 所執行的流程跟邏輯應符合真實流程與情境</p><h3 id="3-Command-內盡量不要再串其他-Command"><a href="#3-Command-內盡量不要再串其他-Command" class="headerlink" title="3. Command 內盡量不要再串其他 Command"></a>3. Command 內盡量不要再串其他 Command</h3><p>Command 通常會對應觸發系統 Event，當 Command 串 Command 時，後續的連鎖反應容易失控，盡量讓 Command 就是獨立完成一個商業邏輯。</p><p>也許看到這邊會覺得這好像有點 DDD 的影子，定義領域模型並封裝領域知識，外部透過 Command 觸發領域模型做事，就我目前的認識，的確 DDD 通常會採用 CQRS 的設計模式來實作，但 CQRS 卻不一定要實作 DDD，不過 DDD 我還是初學者就不獻醜了。</p><h2 id="提升效能"><a href="#提升效能" class="headerlink" title="提升效能"></a>提升效能</h2><p>系統都希望提供各種角度的搜尋來滿足分析與功能需求，而這會加重資料庫的運算資源短缺問題，通常下一步就會開始將資料庫做<code>讀寫分離</code>的拆解，但最終逃離不了 Table Schema 需要同一套的束縛，而這個束縛在運算或是資料到達某個量級時就很難再往上提升了。</p><p>搜尋、寫入最佳化是個兩難的問題，搜尋要快通常要對 Index 設計下一些功夫，而偏偏 Index 越多寫入越慢，又或是 Table Schema 適度的反正規化對搜尋較為友善，但偏偏這會讓寫入資料維護時變得異常麻煩；反過來看，寫入要快需要盡量只寫入該寫入或該更新的資料，而正規化反而是有利於寫入的情境。當讀寫都對同一個 DB 或是同一張 Table 時這兩邊的平衡往往會讓 RD 抓狂，而 CQRS 正是能解決的問題的很好解決方案。<br><img src="/images/20210815/cqrs.png" alt="/images/20210815/cqrs.png"><br>CQRS 允許 Command 與 Query 可以是 Table 等級的隔離也可以是資料庫的實體隔離，更提供針對 Command 與 Query 各自選用最佳方案的資料庫，例如：Command 選用 RDB 而 Query 選擇 NoSQL 甚至是 Elasticsearch 這種重量級搜尋服務來滿足，兩邊資料則透過 Event Sync 的方式來同步。<br>通常系統寫入與查詢的量也是不成比例的，一般系統大部分都在應付各種查詢，而寫入可能只有讀取不到 10 分之 1 的量，CQRS 是有辦法單獨對 Query DB 做橫向擴充，而這在傳統系統架構上是很難做到的一點。</p><h1 id="既然這麼好，我是否該每個系統都這樣設計"><a href="#既然這麼好，我是否該每個系統都這樣設計" class="headerlink" title="既然這麼好，我是否該每個系統都這樣設計"></a>既然這麼好，我是否該每個系統都這樣設計</h1><p>有優點就有缺點，而 CQRS 的缺點是對於開發的難度提升了不止一個檔次，等等！上面不是說為了簡化才選擇 CQRS，這邊又說開發變困難，筆者態度前後不一啦（怒噴兩萬字）</p><p>先冷靜聽我說，CQRS 是想讓你的程式碼符合商業情境，並盡量符合 Single responsibility principle，這是 Code Level 的簡化，但架構卻變得更為複雜，第一你得面對兩邊資料庫的選擇問題，就算退一步說，我系統量不大，選擇同一座資料庫切 Table 可以吧，但 Command 與 Query 就是會有同步時間差，資料只能做到<strong>最終一致性</strong>，而你準備好面對這樣的改變了嗎？你應該不會想要採用 CQRS ，但抄寫兩張 Table 卻用同步的作法，這樣用單張 Table 採用 CRUD 的方式還更快一些。</p><p>當你的開始對 Command / Query 各自選用最佳的資料庫解決方案時，Event Sync 抄寫資料的實作想好解決方案了嗎？中間是透過 Queue 實作 Pub / Sub 同步嗎？ 資料同步延遲的 SLO 定好了嗎？ Consumer 同步速度跟不上寫入發過來的 Event 時，橫向擴充的機制是否想好了？</p><p>當開始要面對最終一致性時，不單單只是系統層面的調整，有時甚至從需求到 RD 觀念都是需要做些改變，現實世界最終一致性例子比比皆是，但在過去的大單體時代強一致性才是顯學，如今系統需要乘載的量體已經不可同日而語，除非有革命性的物理突破，不然我們都要開始習慣這個改變</p><div class="note info">            <p>延伸閱讀<br><a href="https://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html">Starbucks Does Not Use Two-Phase Commit</a></p>          </div><p>講這麼多，那到底怎樣才需要用到 CQRS 實作系統？ 我的建議是如果這個系統<strong>流量</strong>或<strong>資料量</strong>預期成長不大，或需求不太會隨著商業情境一直改變的，例如後台系統，這種真的套個 Template 用 CRUD 簡單搞定就好，引入 CQRS 只會增加複雜度且不會有多大效益的，反之如果這個系統預期未來會持續成長，商業需求也會一直調整，那我會建議可以考慮引入 CQRS，但在前期可以選擇單一資料庫切 Table 的方式就好，等到真的量開始起來時再開始 Migration 都還來得及。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前專案就使用過 CQRS 做為系統的架構來開發，但一直覺得自己『知其然，而不知其所以然』，剛好最近出了一本&lt;a href=&quot;https:/</summary>
      
    
    
    
    
    <category term="CQRS" scheme="https://toyo0103.github.io/tags/CQRS/"/>
    
  </entry>
  
  <entry>
    <title>擷取封包練習</title>
    <link href="https://toyo0103.github.io/2021/04/29/packet_capture/"/>
    <id>https://toyo0103.github.io/2021/04/29/packet_capture/</id>
    <published>2021-04-29T05:45:00.000Z</published>
    <updated>2022-08-09T13:36:17.081Z</updated>
    
    <content type="html"><![CDATA[<p>最近接到一個任務，需要協助團隊重現幾個 DB 連線時的錯誤，例如: connection pool 超過上限爆掉、connection timeout 等等，而其中一個錯誤 Pre-Login handshack 最難重現</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.Data.SqlClient.SqlException (0x80131904): Connection Timeout Expired.  The timeout period elapsed while attempting to consume the pre-login handshake acknowledgement.  This could be because the </span><br><span class="line">pre-login handshake failed or the server was unable to respond back in time.  The duration spent while attempting to connect to this server was - [Pre-Login] initialization=2846; handshake=6765; </span><br></pre></td></tr></table></figure><p>這個錯誤推測是在與 SQL Server 連線時 three-way handshake 沒有收到回應導致的失敗，可能屬於網路不穩掉封包問題導致，但問題怎麼證明?</p><h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><p>首先得先確認與 SQL Server 連線時到底傳了哪些封包出去，可以透過 <a href="https://www.wireshark.org/">wireshark</a> 側錄封包的功能來達成</p><h2 id="1-設定-Capture"><a href="#1-設定-Capture" class="headerlink" title="1. 設定 Capture"></a>1. 設定 Capture</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst host xxx.xxx.xxx.xxx &amp;&amp; port 1433</span><br></pre></td></tr></table></figure><p><img src="/images/20210429/1.png" alt="/images/20210429/1.png"></p><h2 id="2-嘗試對-SQL-做一次連線並觀察封包"><a href="#2-嘗試對-SQL-做一次連線並觀察封包" class="headerlink" title="2. 嘗試對 SQL 做一次連線並觀察封包"></a>2. 嘗試對 SQL 做一次連線並觀察封包</h2><p><img src="/images/20210429/2.png" alt="/images/20210429/2.png"><br>可以發現 Pre-login handshake 應該會有三次封包傳輸</p><h1 id="Packet-Loss"><a href="#Packet-Loss" class="headerlink" title="Packet Loss"></a>Packet Loss</h1><p>接著得想辦法重現封包丟失的狀況下，是否會引發相同的 Exception，因為不知道怎麼精準的特定封包攔下來 (如果有人會的話也歡迎留言教學一下)，所以這邊透過 <a href="https://github.com/jagt/clumsy">Clumsy</a> 這個套件來輔助達成</p><h2 id="1-指定目的地的封包多少比例被攔截下來"><a href="#1-指定目的地的封包多少比例被攔截下來" class="headerlink" title="1. 指定目的地的封包多少比例被攔截下來"></a>1. 指定目的地的封包多少比例被攔截下來</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outbound and ip.DstAddr = xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p><img src="/images/20210429/3.png" alt="/images/20210429/3.png"></p><h2 id="2-增加連線-handshake-的機率"><a href="#2-增加連線-handshake-的機率" class="headerlink" title="2. 增加連線 handshake 的機率"></a>2. 增加連線 handshake 的機率</h2><p>因為無法精準攔截封包，所以採取短時間快速重複連線來增加封包被攔截的碰撞機率，所以我將 Connection Pool 關閉，並且開多執行序只做最簡單的連線與關閉連線，果然很快就碰到 handshake 的封包被攔掉的狀況</p><p><img src="/images/20210429/4.png" alt="/images/20210429/4.png"></p><p>而最後也證實了只要連線時網路不穩定導致掉封包等狀況時，底層是會引發上述錯誤的狀況</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近接到一個任務，需要協助團隊重現幾個 DB 連線時的錯誤，例如: connection pool 超過上限爆掉、connection timeout 等等，而其中一個錯誤 Pre-Login handshack 最難重現&lt;/p&gt;
&lt;figure class=&quot;highli</summary>
      
    
    
    
    
    <category term="wireshark" scheme="https://toyo0103.github.io/tags/wireshark/"/>
    
    <category term="clumsy" scheme="https://toyo0103.github.io/tags/clumsy/"/>
    
  </entry>
  
  <entry>
    <title>dotnet core 3 container 無法連線 MSSQL 2016</title>
    <link href="https://toyo0103.github.io/2020/12/01/dotnet_core_3_container_ms_sql_2016/"/>
    <id>https://toyo0103.github.io/2020/12/01/dotnet_core_3_container_ms_sql_2016/</id>
    <published>2020-12-01T14:22:00.000Z</published>
    <updated>2022-08-09T13:36:17.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h1><p>最近踩到 dotnet core 3 contaienr  + ms sql 2016 的問題，問題的現象是，程式只要跑到建 sql connection 那行就會 hang 在那邊，沒有 timeout 也沒有 Exception … 追查之下後發現，原來 MS SQL 2016 如果沒有調整更新，預設 TLS 好像只支援 1.0、1.1 (待確認)，而我用的 base image : <code>mcr.microsoft.com/dotnet/core/runtime:3.1</code> 的 TLS 設定要求最低版本是 1.2，這也就引發了上述的狀況</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/ssl/openssl.cnf</span> </span><br><span class="line">[system_default_sect]</span><br><span class="line">MinProtocol = TLSv1.2</span><br><span class="line">CipherString = DEFAULT@SECLEVEL=2</span><br></pre></td></tr></table></figure><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>一般來說，基於安全性會建議至少停用 TLS 1.0 並支援 1.2 才是比較好的做法，但如果你跟我一樣只是在測試，那可以採用以下比較 workaround 的做法，在 dockerfile 加上以下幾行來調整 container tls 最低支援版本</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">RUN</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&#x27;s/DEFAULT@SECLEVEL=2/DEFAULT@SECLEVEL=1/g&#x27;</span> <span class="string">/etc/ssl/openssl.cnf</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&#x27;s/MinProtocol = TLSv1.2/MinProtocol = TLSv1/g&#x27;</span> <span class="string">/etc/ssl/openssl.cnf</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&#x27;s/DEFAULT@SECLEVEL=2/DEFAULT@SECLEVEL=1/g&#x27;</span> <span class="string">/usr/lib/ssl/openssl.cnf</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&#x27;s/MinProtocol = TLSv1.2/MinProtocol = TLSv1/g&#x27;</span> <span class="string">/usr/lib/ssl/openssl.cnf</span></span><br></pre></td></tr></table></figure><p>這樣重新啟動也就會正常了</p> <div class="note info">            <p>參考文章</p><p><a href="https://github.com/dotnet/SqlClient/issues/222">.NET Core 3.0 Docker Container Won’t Connect to SQL Server</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;情境&quot;&gt;&lt;a href=&quot;#情境&quot; class=&quot;headerlink&quot; title=&quot;情境&quot;&gt;&lt;/a&gt;情境&lt;/h1&gt;&lt;p&gt;最近踩到 dotnet core 3 contaienr  + ms sql 2016 的問題，問題的現象是，程式只要跑到建 sql con</summary>
      
    
    
    
    
    <category term="dotnet core" scheme="https://toyo0103.github.io/tags/dotnet-core/"/>
    
    <category term="Docker" scheme="https://toyo0103.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【C#】 關於 Async 的三兩事</title>
    <link href="https://toyo0103.github.io/2020/09/19/about_async/"/>
    <id>https://toyo0103.github.io/2020/09/19/about_async/</id>
    <published>2020-09-19T09:07:00.000Z</published>
    <updated>2022-08-09T13:36:17.079Z</updated>
    
    <content type="html"><![CDATA[<p>說來真的好久沒有寫文章了，除了工作很忙之外，目前碰到的問題也通常不是一兩篇文章可以交代的清，所以也就更新部落格的時間也就間隔越來越長了。</p><p>這次主要是想把最近針對 Async 的一些測試研究記錄下來，那我們就開始吧 ！</p><h1 id="Async-是什麼？"><a href="#Async-是什麼？" class="headerlink" title="# Async 是什麼？"></a># Async 是什麼？</h1><p>Async 在 C# 語言中用來支援非同步處理的一種語法，而它的使用往往搭配 Await 一起使用，先來看看一段簡單的程式碼</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;1. Hi I&#x27;m Async Demo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到非同步的任務</span></span><br><span class="line">    <span class="keyword">var</span> task = DoAsync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//繼續執行</span></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;2. Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待非同步任務執行完成</span></span><br><span class="line">    <span class="keyword">await</span> task;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;4. End!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="comment">//碰到 await 時，會將控制項回傳給呼叫端，並且等待非同步的方法執行完成</span></span><br><span class="line">    <span class="keyword">await</span> Task.Run(()=&gt; </span><br><span class="line">                   &#123;</span><br><span class="line">                     Thread.Sleep(TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">                     Console.WriteLine(<span class="string">$&quot;3. Async method Done&quot;</span>);</span><br><span class="line">                   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段程式碼執行後可以看到以下結果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Hi I&#39;m Async Demo</span><br><span class="line">2. Hello World!</span><br><span class="line">3. Async method Done</span><br><span class="line">4. End!</span><br></pre></td></tr></table></figure><h2 id="觀察執行緒的切換"><a href="#觀察執行緒的切換" class="headerlink" title="觀察執行緒的切換"></a>觀察執行緒的切換</h2><p>接著加上執行緒 Id 看看，讓我們更清楚執行緒之間是如何切換的</p><p><img src="/images/20200919/1.png" alt="/images/20200919/1.png"></p><p>執行結果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] 1. Hi I&#39;m Async Demo</span><br><span class="line">[1] 2. Hello World!</span><br><span class="line">[4] 3. Async method Done</span><br><span class="line">[4] 4. End!</span><br></pre></td></tr></table></figure><p><strong>執行流程</strong></p><ul><li><p><strong>執行緒_1</strong> 在 11 行印出了 <code>[1] 1. Hi I&#39;m Async Demo</code></p></li><li><p><strong>執行緒_1</strong> 在 14 行進入了 DoAsync 的方法中</p></li><li><p><strong>執行緒_1</strong> 在 27 行碰到 Task.Run 開啟了非同步執行的方法，並因為 await 跳出了這個 DoAsync() </p></li><li><p><strong>執行緒_1</strong> 在 16 行碰到印出了 <code>[1] 2. Hello World!</code></p></li><li><p><strong>執行緒_1</strong> 在 19 行碰到 await task ，開始等待 task 執行完成，<strong>執行緒_1</strong> 釋放回到 Thread Pool</p></li><li><p><strong>執行緒_4</strong> 在非同步方法的第 30 行 印出了 <code>[4] 3. Async method Done</code> ，並通知 await task 執行完成</p></li><li><p>TaskScheduler（通常，這會是以執行緒集區為目標的預設工作排程器）依據最有效率的判斷，讓 <strong>執行緒_4</strong> 往下執行未完的部分</p></li><li><p><strong>執行緒_4</strong> 接手繼續將 await 之後還沒做完的工作執行完成，意即 21 行，印出 <code>[4] 4. End!</code></p></li></ul><h2 id="稍微修改一下程式…"><a href="#稍微修改一下程式…" class="headerlink" title="稍微修改一下程式…"></a>稍微修改一下程式…</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>] 1. Hi I&#x27;m Async Demo&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//強制將非同步方法改成同步</span></span><br><span class="line">    DoAsync().Wait();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>] 2. Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>] 4. End!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DoAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="comment">//碰到 await 時，會將控制項回傳給呼叫端，並且等待非同步的方法執行完成</span></span><br><span class="line">    <span class="keyword">await</span> Task.Run(()=&gt; </span><br><span class="line">                   &#123;</span><br><span class="line">                     Thread.Sleep(TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">                     Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>] 3. Async method Done&quot;</span>);</span><br><span class="line">                   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1] 1. Hi I&#39;m Async Demo</span><br><span class="line">[4] 3. Async method Done</span><br><span class="line">[1] 2. Hello World!</span><br><span class="line">[1] 4. End!</span><br></pre></td></tr></table></figure><p>這邊可以看到 <strong>執行緒_1</strong> 在執行到 await Task.Run(()=&gt; …) 時跳出，但因為我們下了 Wait()，所以強迫 <strong>執行緒_1</strong> 進行同步的等待。</p><p><strong>執行緒_4</strong> 印完 <code>[4] 3. Async method Done</code> 後，通知 <strong>執行緒_1</strong> 繼續往下進行，所以看到 <strong>執行緒_1</strong>  接著將剩下的程式跑完</p><h2 id="差別在哪？"><a href="#差別在哪？" class="headerlink" title="差別在哪？"></a>差別在哪？</h2><p>當呼叫非同步執行方法時，如果一路都是用 await 並不會造成任何執行緒被封鎖，換言之該執行緒還可以在別的地方繼續服務，一旦呼叫了 <strong>Result</strong> 或 <strong>Wait()</strong> 這類的強制同步方法，則該執行緒會被封鎖，並等待到非同步方法執行完成後才繼續完成尚未完成的後續工作，這會嚴重消耗執行緒的使用效率。</p><p>我曾經對一個 Web API 專案進行壓測，在資源給得非常有限的情境下 (約 0.5 core cpu)，<code>await 搭配 Task.Run()</code> 跟 <code>Result 搭配 Task.Run</code> ，兩個 RPS 測起來差了快一倍之多，在資源極度有限下，執行緒的使用效率將大大影響整體服務的效率。</p><h1 id="SynchronizationContext"><a href="#SynchronizationContext" class="headerlink" title="# SynchronizationContext"></a># SynchronizationContext</h1><p>SynchronizationContext 是用來記錄當前執行緒環境的類別，在 ASP.NET、WPF、WinForm 都有類似的類別只是名字可能有些差異，其最主要的目的都是在非同步方法中要能調用 UI 執行緒來更新介面之類的操作，而 SynchronizationContext 就紀錄著 UI 執行緒。</p><h2 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h2><p>過去寫 ASP.NET 的時候曾經踩過一次  SynchronizationContext 的雷，在 ASP.NET 中如果如果呼叫 <code>SynchronizationContext.Currnt</code> 會發現並不為 Null，且型別是 <code>AspNetSynchronizationContext</code> ，當我們用上述的 <code>Result / Wait() 搭配 await</code> 將會導致 Deadlock。</p><p>原因是程式碰到 await 時會先判斷 SynchronizationContext.Currnt 是否為 Null，如果是則會在 Task 結束時呼叫 TaskScheduler （通常為 Thread Pool）來安排後續工作。反之，如果 SynchronizationContext.Currnt 不為 Null 時，就會透過 SynchronizationContext.Currnt 來繼續後續的動作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//碰到 await 時，記住了 SynchronizationContext.Currnt</span></span><br><span class="line"><span class="keyword">await</span> Task.Run(()=&gt; </span><br><span class="line">               &#123;</span><br><span class="line">                 Thread.Sleep(TimeSpan.FromSeconds(<span class="number">5</span>));</span><br><span class="line">                 Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>] 3. Async method Done&quot;</span>);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure><p>而 .Result / Wait() 的方法會封鎖住 SynchronizationContext.Currnt，造成兩邊互等的情況發生，產生了 Deadlock</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DoAsync().Wait(); <span class="comment">//封鎖 SynchronizationContext.Currnt 的物件等待 Task 完成</span></span><br></pre></td></tr></table></figure><p>而這只會發生在 SynchronizationContext.Currnt 不為 Null 的系統中，像是前述提到的 ASP.NET、WPF、WinForm，在 Console Application 並不會發生。</p><h2 id="解決方法-ConfigureAwait-false"><a href="#解決方法-ConfigureAwait-false" class="headerlink" title="解決方法 ConfigureAwait(false)"></a>解決方法 ConfigureAwait(false)</h2><p>如果要避免上述所提到的 Deadlock ，可以在呼叫非同步方法時加上 ConfigureAwait(false)，這樣非同工作完成時就會透過另一條執行緒繼續完成後續工作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Run(()=&gt; </span><br><span class="line">          &#123;</span><br><span class="line">              ....</span><br><span class="line">          &#125;).ConfigureAwait(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="在-ASP-Net-Core-的時代…"><a href="#在-ASP-Net-Core-的時代…" class="headerlink" title="在 ASP.Net Core 的時代…"></a>在 ASP.Net Core 的時代…</h2><p>在 ASP.Net core 呼叫 SynchronizationContext.Current 現在只會得到 Null ，換言之剛剛發生 deadlock 的情境已經不會發生，所以過往在非同步的地方常常要用 ConfigureAwait(false) 可以不用寫了，不過如果你是寫元件或 SDK 類的，並無法預測會被使用在怎樣的環境的話，建議還是都加上會比較保險。</p><h1 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="# Best Practice"></a># Best Practice</h1><p>在使用 Async / await 等非同步技巧時，最好的方式還是都盡量使用非阻斷式的寫法 await ，避免使用 Result / Wait() ，即使你已經是寫 ASP.Net core 不會發生 Deadlock 的情況，阻斷式的寫法對於執行緒的使用效率來說還是會有影響的。</p><div class="note info">            <p>參考文章</p><p><a href="https://docs.microsoft.com/zh-tw/dotnet/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern">使用以工作為基礎的非同步模式</a></p><p><a href="https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html">ASP.NET Core SynchronizationContext</a></p><p><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/">ConfigureAwait FAQ</a></p><p><a href="https://www.huanlintalk.com/2016/01/asyc-deadlock-in-aspbet.html">.NET 程式鎖死與 SynchronizationContext</a></p><p><a href="https://www.cnblogs.com/lzxianren/p/SynchronizationContext.html">搞懂 SynchronizationContext（第一部分)</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;說來真的好久沒有寫文章了，除了工作很忙之外，目前碰到的問題也通常不是一兩篇文章可以交代的清，所以也就更新部落格的時間也就間隔越來越長了。&lt;/p&gt;
&lt;p&gt;這次主要是想把最近針對 Async 的一些測試研究記錄下來，那我們就開始吧 ！&lt;/p&gt;
&lt;h1 id=&quot;Async-是什麼</summary>
      
    
    
    
    
    <category term="Async" scheme="https://toyo0103.github.io/tags/Async/"/>
    
    <category term="C#" scheme="https://toyo0103.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>initialize RabbitMQ container&#39;s Queue and Exchange</title>
    <link href="https://toyo0103.github.io/2020/06/06/rabbitmq_container_initial_queue/"/>
    <id>https://toyo0103.github.io/2020/06/06/rabbitmq_container_initial_queue/</id>
    <published>2020-06-06T15:48:00.000Z</published>
    <updated>2022-08-09T13:36:17.081Z</updated>
    
    <content type="html"><![CDATA[<p>為了測試方便常常會在本機起 RabbitMQ Container，但隨著系統的演進初始化 RabbitMQ 變得越來越複雜，例如：每次都要先設定 8 組 Queue，Exchange binding …等等</p><p>工程師的美德就是懶，所以開始找辦法是不是可以讓 RabbitMQ Container 起來時就自己設定好呢？</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>RabbitMQ 有提供設定檔來初始化，分別為放在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config</span><br><span class="line">&#x2F;etc&#x2F;rabbitmq&#x2F;definitions.json </span><br></pre></td></tr></table></figure><p>而這兩個檔案裡面可以設定 VirtualHost、Authorization、Exchange、Queue</p><p><strong>rabbitmq.config</strong><br>這邊特別提醒一下，內容最後面那個小點不是打錯喔，是規定就是要有的!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    rabbit,</span><br><span class="line">    [</span><br><span class="line">      &#123; loopback_users, [] &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    rabbitmq_management,</span><br><span class="line">    [</span><br><span class="line">      &#123; load_definitions, &quot;&#x2F;etc&#x2F;rabbitmq&#x2F;definitions.json&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure><p><strong>definitions.json</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rabbit_version&quot;: &quot;3.8&quot;,</span><br><span class="line">  &quot;users&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;guest&quot;,</span><br><span class="line">      &quot;password&quot;: &quot;guest&quot;,</span><br><span class="line">      &quot;tags&quot;: &quot;administrator&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;vhosts&quot;: [</span><br><span class="line">    &#123; &quot;name&quot;: &quot;&#x2F;&quot; &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;permissions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;user&quot;: &quot;guest&quot;,</span><br><span class="line">      &quot;vhost&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">      &quot;configure&quot;: &quot;.*&quot;,</span><br><span class="line">      &quot;write&quot;: &quot;.*&quot;,</span><br><span class="line">      &quot;read&quot;: &quot;.*&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;parameters&quot;: [],</span><br><span class="line">  &quot;policies&quot;: [],</span><br><span class="line">  &quot;exchanges&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;nmq&quot;,</span><br><span class="line">      &quot;vhost&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;direct&quot;,</span><br><span class="line">      &quot;durable&quot;: true,</span><br><span class="line">      &quot;auto_delete&quot;: false,</span><br><span class="line">      &quot;internal&quot;: false,</span><br><span class="line">      &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;queues&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;command&quot;,</span><br><span class="line">      &quot;vhost&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">      &quot;durable&quot;: true,</span><br><span class="line">      &quot;auto_delete&quot;: false,</span><br><span class="line">      &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;bindings&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;source&quot;: &quot;nmq&quot;,</span><br><span class="line">      &quot;vhost&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">      &quot;destination&quot;: &quot;command&quot;,</span><br><span class="line">      &quot;destination_type&quot;: &quot;queue&quot;,</span><br><span class="line">      &quot;routing_key&quot;: &quot;command&quot;,</span><br><span class="line">      &quot;arguments&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>在啟動 rabbitmq container 的時候將這兩個檔案透過 volume 的方式丟進去，這樣就可以達成目的了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -it \</span></span><br><span class="line"><span class="bash">-v /etc/so/rabbitmq.config:/etc/rabbitmq/rabbitmq.config:ro \ </span></span><br><span class="line">-v /etc/so/definitions.json:/etc/rabbitmq/definitions.json:ro rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>如過你不幸 (?) 的跟我一樣是使用 windows container，volume 這個選擇不屬於你，因為 windows container 只能將整個資料夾 volume 進去，並不能指定單一檔案，所以如果將整個資料夾放進去，需要額外將一些本該在 <code>/etc/rabbitmq</code> 底下的檔案也都 copy 出來，才不會跑起來的時候少東少西的，但這個方法總覺得有點麻煩，所以我採用自己 build image 的方案</p><p><strong>dockerfile</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">rabbitmq:3.8-management</span></span><br><span class="line"></span><br><span class="line"><span class="string">ADD</span> <span class="string">rabbitmq.config</span> <span class="string">/etc/rabbitmq/</span></span><br><span class="line"><span class="string">ADD</span> <span class="string">definitions.json</span> <span class="string">/etc/rabbitmq/</span></span><br></pre></td></tr></table></figure><p>透過 build image 的過程中將檔案放進去，之後起起來也都不用在下 volume 指令，也算是簡單不少</p><div class="note info">            <p><a href="https://stackoverflow.com/questions/30747469/how-to-add-initial-users-when-starting-a-rabbitmq-docker-container"><a href="https://stackoverflow.com/questions/30747469/how-to-add-initial-users-when-starting-a-rabbitmq-docker-container">How to add initial users when starting a RabbitMQ Docker container?</a></a></p><p><a href="https://devops.datenkollektiv.de/creating-a-custom-rabbitmq-container-with-preconfigured-queues.html">Creating a custom RabbitMQ container with preconfigured queues</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;為了測試方便常常會在本機起 RabbitMQ Container，但隨著系統的演進初始化 RabbitMQ 變得越來越複雜，例如：每次都要先設定 8 組 Queue，Exchange binding …等等&lt;/p&gt;
&lt;p&gt;工程師的美德就是懶，所以開始找辦法是不是可以讓 Ra</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://toyo0103.github.io/tags/Docker/"/>
    
    <category term="RabbitMQ" scheme="https://toyo0103.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>hnsCall failed in Win32 The object already exists</title>
    <link href="https://toyo0103.github.io/2020/02/26/windows_docker_hnscall_error/"/>
    <id>https://toyo0103.github.io/2020/02/26/windows_docker_hnscall_error/</id>
    <published>2020-02-26T02:28:00.000Z</published>
    <updated>2022-08-09T13:36:17.084Z</updated>
    
    <content type="html"><![CDATA[<p>windows server 2019 重開機後，自建 container nat networks 會消失。<br><a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/network-drivers-topologies">來源 : Windows container network drivers</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAT networks created on Windows Server 2019 (or above) are no longer persisted after reboot.</span><br></pre></td></tr></table></figure><p>所以我有寫一些重啟機器時檢查 network ，如果不存在就再建立一組並且啟動 docker，但時不時會碰到 <code>Error response from daemon: hnsCall failed in Win32: The object already exists. (0x1392)</code> 的錯誤。</p><p>但透過以下指令卻又都找不到已經存在的 network mapping</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> docker network <span class="built_in">ls</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">Get-NetNatStaticMapping</span></span><br></pre></td></tr></table></figure><p>直接下指令砍掉要建立的 network 名稱，會回傳這物件不存在，但你要建立又會說這物件已經存在的鬼擋牆狀況… 這應該是 windows container bug ，之前只要碰到這個問題都直接重長機器，而剛剛終於找到解法了 (灑花)</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先停掉 docker service</span></span><br><span class="line"><span class="variable">$Stop</span><span class="literal">-Service</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停掉 hns </span></span><br><span class="line"><span class="variable">$Stop</span><span class="literal">-Service</span> hns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重啟 docker service, 這會連帶的 hns 也會被啟動</span></span><br><span class="line"><span class="variable">$Start</span><span class="literal">-Service</span> docker</span><br></pre></td></tr></table></figure><p>這時候再重新跑 docker network create 就會過了，這問題卡了我很長一段時間，終於找到解法了</p><div class="note info">            <p><a href="https://github.com/docker/for-win/issues/1384">Docker Network Create Fails: HNS failed with error : The object already exists. #1384</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;windows server 2019 重開機後，自建 container nat networks 會消失。&lt;br&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/virtualization/windowscontainers/con</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://toyo0103.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>powershell筆記</title>
    <link href="https://toyo0103.github.io/2020/02/26/powershell_note/"/>
    <id>https://toyo0103.github.io/2020/02/26/powershell_note/</id>
    <published>2020-02-25T16:03:00.000Z</published>
    <updated>2022-08-09T13:36:17.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20200226/0.jpg" alt="/images/20200226/0.jpg"></p><p>(圖片出處: <a href="https://sploot.tw/2018/06/powershell-suite-windows-attack-tookit/">https://sploot.tw/2018/06/powershell-suite-windows-attack-tookit/</a>)</p><p>powershell 苦手如我，最近有越來越多的需求要從頭到尾自建 CI/CD 與自動化佈署流程，每次寫都要查一次覺得很煩(越老越金魚腦)，決定把常常用到的筆記方便查找</p><h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出所有的環境變數</span></span><br><span class="line"><span class="variable">$gci</span> env:* | <span class="built_in">Sort-Object</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">Name                           Value</span><br><span class="line">----                           -----</span><br><span class="line">ALLUSERSPROFILE                C:\ProgramData</span><br><span class="line">APPDATA                        C:\Users\Steven Tsai\AppData\Roaming</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#設定環境變數</span></span><br><span class="line"><span class="variable">$env:test</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="variable">$env:test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#result</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h1 id="Variable"><a href="#Variable" class="headerlink" title="Variable"></a>Variable</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="variable">$test</span></span><br><span class="line"><span class="comment">#result</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><h1 id="If-…-Else"><a href="#If-…-Else" class="headerlink" title="If … Else"></a>If … Else</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="variable">$if</span>(<span class="variable">$test</span> <span class="operator">-eq</span> <span class="string">&quot;123&quot;</span>) &#123;<span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span>&#125; <span class="keyword">else</span> &#123;<span class="built_in">echo</span> <span class="string">&quot;no&quot;</span>&#125;</span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把判斷的結果存到變數中</span></span><br><span class="line"><span class="variable">$test</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="variable">$result</span>=<span class="keyword">if</span>(<span class="variable">$test</span> <span class="operator">-eq</span> <span class="string">&quot;123&quot;</span>) &#123;<span class="built_in">echo</span> <span class="string">&quot;yes&quot;</span>&#125; <span class="keyword">else</span> &#123;<span class="built_in">echo</span> <span class="string">&quot;no&quot;</span>&#125;</span><br><span class="line"><span class="variable">$result</span></span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure><h1 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span>=<span class="string">&quot;a,b,c&quot;</span></span><br><span class="line"><span class="variable">$test</span>.Split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span>=<span class="string">&quot;a,b,c&quot;</span></span><br><span class="line"><span class="variable">$test</span>.Split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure><h1 id="Invoke-WebRequest"><a href="#Invoke-WebRequest" class="headerlink" title="Invoke-WebRequest"></a>Invoke-WebRequest</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要帳密上傳檔案</span></span><br><span class="line"><span class="variable">$PASSWORD</span> = <span class="built_in">ConvertTo-SecureString</span> <span class="literal">-String</span> <span class="string">&quot;your_password&quot;</span> <span class="literal">-AsPlainText</span> <span class="literal">-Force</span></span><br><span class="line"><span class="variable">$CREDENTIAL</span> = <span class="built_in">New-Object</span> <span class="literal">-TypeName</span> <span class="string">&quot;System.Management.Automation.PSCredential&quot;</span> <span class="literal">-ArgumentList</span> <span class="string">&quot;your_account&quot;</span>, <span class="variable">$PASSWORD</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$Invoke</span><span class="literal">-WebRequest</span> <span class="literal">-Method</span> PUT <span class="literal">-Uri</span> https://server/file.zip <span class="literal">-UseBasicParsing</span> <span class="literal">-Credential</span> <span class="variable">$CREDENTIAL</span> <span class="literal">-Infile</span> <span class="string">&quot;.\file.zip&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Remove-Item"><a href="#Remove-Item" class="headerlink" title="Remove-Item"></a>Remove-Item</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#force強制刪除</span></span><br><span class="line"><span class="variable">$Remove</span><span class="literal">-Item</span> .\file.zip <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><h1 id="New-Item"><a href="#New-Item" class="headerlink" title="New-Item"></a>New-Item</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立 logs 資料夾</span></span><br><span class="line"><span class="variable">$New</span><span class="literal">-Item</span> <span class="literal">-ItemType</span> directory <span class="literal">-Path</span> C:\logs</span><br><span class="line"></span><br><span class="line"><span class="comment">#result</span></span><br><span class="line">目錄: C:\</span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d-----      <span class="number">2020</span>/<span class="number">2</span>/<span class="number">26</span>  上午 <span class="number">12</span>:<span class="number">28</span>                test</span><br></pre></td></tr></table></figure><h1 id="Copy-Item"><a href="#Copy-Item" class="headerlink" title="Copy-Item"></a>Copy-Item</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Copy</span><span class="literal">-Item</span> c:\source_folder C:\target_folder\ <span class="literal">-Recurse</span></span><br></pre></td></tr></table></figure><h1 id="Out-File"><a href="#Out-File" class="headerlink" title="Out-File"></a>Out-File</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#將文字寫成檔案</span></span><br><span class="line"><span class="variable">$test</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="variable">$test</span> | <span class="built_in">Out-File</span> <span class="string">&quot;C:\log.txt&quot;</span> <span class="literal">-Encoding</span> utf8 <span class="literal">-Force</span></span><br></pre></td></tr></table></figure><h1 id="Write-file-without-BOM"><a href="#Write-file-without-BOM" class="headerlink" title="Write file without BOM"></a>Write file without BOM</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$test</span>=<span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="variable">$</span>[<span class="type">System.IO.File</span>]::WriteAllLines(<span class="string">&quot;C:\log.txt&quot;</span>, <span class="variable">$test</span>) </span><br></pre></td></tr></table></figure><h1 id="Start-Transcript"><a href="#Start-Transcript" class="headerlink" title="Start-Transcript"></a>Start-Transcript</h1><p>通常腳本會在長機器的時候自動執行，這時候並不會有人工介入，如果發生錯誤就很需要事後追查 Log ，但一段腳本可能上百上千行，到底錯在哪很難找，這時候就可以透過以下方法把執行的過程跟 output 都儲存下來</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Start</span><span class="literal">-Transcript</span> <span class="literal">-Path</span> <span class="string">&quot;c:\logs.txt&quot;</span> <span class="literal">-Append</span></span><br><span class="line"><span class="variable">$New</span><span class="literal">-Item</span> <span class="literal">-Type</span> Directory C:\TestData2\ <span class="literal">-Force</span></span><br><span class="line"><span class="variable">$Stop</span><span class="literal">-Transcript</span></span><br></pre></td></tr></table></figure><p>執行結束後打開 logs.txt 就可以看到以下輸出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">**********************</span><br><span class="line">Windows PowerShell 轉譯開始</span><br><span class="line">**********************</span><br><span class="line">已啟動轉譯，輸出檔為 c:\logs.txt</span><br><span class="line">PS C:\Users\Steven Tsai&gt; New-Item -Type Directory C:\TestData2\ -Force</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目錄: C:\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d-----      2020&#x2F;2&#x2F;26  上午 12:40                TestData2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS C:\Users\Steven Tsai&gt; Stop-Transcript</span><br><span class="line">**********************</span><br><span class="line">Windows PowerShell 轉譯結束</span><br><span class="line">結束時間: 20200226004058</span><br><span class="line">**********************</span><br></pre></td></tr></table></figure><h1 id="Set-Global-Enviroment"><a href="#Set-Global-Enviroment" class="headerlink" title="Set Global Enviroment"></a>Set Global Enviroment</h1><p>這是用在自動化安裝一些套件，例如 : Git , consul 後需要設定全域的環境變數，才能讓之後的指令能夠認得 consul –version 這類指令。</p><p>如果手動安裝，就是去把環境變數中 Path 加上 consul.exe 的位置，以下範例是抓出 Path 本來的設定值，並在尾段補上新的路徑設定</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$oldpath</span> = (<span class="built_in">Get-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment&#x27;</span> <span class="literal">-Name</span> PATH).path</span><br><span class="line"></span><br><span class="line"><span class="variable">$newpath</span> = <span class="string">&quot;<span class="variable">$</span>&#123;oldpath&#125;;C:\consul\&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$Set</span><span class="literal">-ItemProperty</span> <span class="literal">-Path</span> <span class="string">&#x27;Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment&#x27;</span> <span class="literal">-Name</span> PATH <span class="literal">-Value</span> <span class="variable">$newPath</span></span><br></pre></td></tr></table></figure><h1 id="Start-Service"><a href="#Start-Service" class="headerlink" title="Start-Service"></a>Start-Service</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Start</span><span class="literal">-Service</span> your_service_name</span><br></pre></td></tr></table></figure><h1 id="register-task-scheduler"><a href="#register-task-scheduler" class="headerlink" title="register task scheduler"></a>register task scheduler</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要執行的動作</span></span><br><span class="line"><span class="variable">$action</span>= (<span class="built_in">New-ScheduledTaskAction</span> <span class="literal">-Execute</span> <span class="string">&quot;powershell.exe&quot;</span> <span class="literal">-Argument</span> <span class="string">&quot;-ExecutionPolicy bypass C:\start.ps1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#執行權限</span></span><br><span class="line"><span class="variable">$ProvisionPrincipal</span> = <span class="built_in">New-ScheduledTaskPrincipal</span> <span class="literal">-UserId</span> <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span> <span class="literal">-RunLevel</span> Highest <span class="literal">-LogonType</span> S4U</span><br><span class="line"></span><br><span class="line"><span class="comment">#觸發的時機</span></span><br><span class="line"><span class="variable">$ProvisionTrigger</span> = <span class="built_in">New-ScheduledTaskTrigger</span> <span class="literal">-AtStartup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#註冊 task Schedule </span></span><br><span class="line"><span class="variable">$Register</span><span class="literal">-ScheduledTask</span> <span class="literal">-TaskName</span> <span class="string">&quot;StartConsul&quot;</span> <span class="literal">-TaskPath</span> <span class="string">&quot;\&quot;</span> <span class="literal">-Action</span> <span class="variable">$action</span> <span class="literal">-Trigger</span> <span class="variable">$ProvisionTrigger</span> <span class="literal">-Principal</span> <span class="variable">$ProvisionPrincipal</span> </span><br></pre></td></tr></table></figure><h1 id="Create-User"><a href="#Create-User" class="headerlink" title="Create User"></a>Create User</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#設定 User 密碼</span></span><br><span class="line"><span class="variable">$Secure_String_Pwd</span>=<span class="built_in">ConvertTo-SecureString</span> <span class="string">&quot;user_password&quot;</span> <span class="literal">-AsPlainText</span> <span class="literal">-Force</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建立User</span></span><br><span class="line"><span class="variable">$New</span><span class="literal">-LocalUser</span> <span class="string">&quot;teamuser&quot;</span> <span class="literal">-Password</span> <span class="variable">$Secure_String_Pwd</span> <span class="literal">-FullName</span> <span class="string">&quot;Arch team user&quot;</span> <span class="literal">-Description</span> <span class="string">&quot;for arch team&quot;</span> <span class="literal">-PasswordNeverExpires</span>:<span class="variable">$true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#將此 User 加入 Administrators</span></span><br><span class="line"><span class="variable">$Add</span><span class="literal">-LocalGroupMember</span> <span class="literal">-Group</span> <span class="string">&quot;Administrators&quot;</span> <span class="literal">-Member</span> <span class="string">&quot;teamuser&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建立一個全新的 Group</span></span><br><span class="line"><span class="variable">$New</span><span class="literal">-LocalGroup</span> <span class="literal">-Name</span> <span class="string">&quot;docker-users&quot;</span></span><br><span class="line"><span class="comment">#將此 User 加進去</span></span><br><span class="line"><span class="variable">$Add</span><span class="literal">-LocalGroupMember</span> <span class="literal">-Group</span> <span class="string">&quot;docker-users&quot;</span> <span class="literal">-Member</span> <span class="string">&quot;archteamuser&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Expand-Archive"><a href="#Expand-Archive" class="headerlink" title="Expand-Archive"></a>Expand-Archive</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$curl</span> https://source_file.zip <span class="literal">-o</span> c:\targe_file.zip</span><br><span class="line"></span><br><span class="line"><span class="variable">$Expand</span><span class="literal">-Archive</span> c:\targe_file.zip c:\file <span class="literal">-force</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20200226/0.jpg&quot; alt=&quot;/images/20200226/0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;(圖片出處: &lt;a href=&quot;https://sploot.tw/2018/06/powershell-suite-windows</summary>
      
    
    
    
    
    <category term="CI/CD" scheme="https://toyo0103.github.io/tags/CI-CD/"/>
    
    <category term="powershell" scheme="https://toyo0103.github.io/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>透過容器建置專案</title>
    <link href="https://toyo0103.github.io/2020/02/17/docker_ci_build/"/>
    <id>https://toyo0103.github.io/2020/02/17/docker_ci_build/</id>
    <published>2020-02-17T15:06:00.000Z</published>
    <updated>2022-08-09T13:36:17.080Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20200217/0.jpg" alt="希望學會這個技巧後，以後大家弄CI/CD環境都能海闊天空"></p><p>(圖片出處 : <a href="http://ezvivi2.com/article/200483.asp">http://ezvivi2.com/article/200483.asp</a>)</p><p>有在處理 CI/CD 的人應該都碰到過維護建置環境的問題，舉例來說，當今天開發 C# 專案可能有 dotnet framework、dotnet core、有些人開發前端會需要 npm …等等，CI 機器就需要裝一堆為了建置佈署的軟體，如果開發人員變多，建置排隊久候，可能就會將環境升級為 Master、Slave 架構，但又面臨了多台 Slave 如何快速增長(通常只有上班時間才會同時這麼多人在建置，所以動態增長 CI 機器有其必要)，如何維護多台 Slave 環境，有時候遇到需要的套件版本打架的時候，處理起來真的是會抓狂。</p><h1 id="透過容器來建置專案"><a href="#透過容器來建置專案" class="headerlink" title="透過容器來建置專案"></a>透過容器來建置專案</h1><p>其實綜觀上述的問題可以發現，每個專案建置所需要的東西可能不盡相同，為了讓 CI 機器能夠滿足所有建置的條件往往會把環境搞得過於複雜，這時候容器就是一個非常好的選擇，它滿足了每次建置環境都是<strong>獨立</strong>、<strong>隔離</strong>的條件且方便佈署。</p><p>一旦使用容器來做為建置的媒介，需要長一台新的 CI 機器時，只要將機器開起來並安裝完 docker 就搞定了(甚至 AWS 都有做好的現成 AMI 連自己安裝都省了)，不再需要寫一狗票的腳本來安裝機器。</p><h1 id="實例"><a href="#實例" class="headerlink" title="實例"></a>實例</h1><p>以下是我一個專案建置時的 dockerfile，沒幾行的 script 就快速講一下，因為我這個專案裡面同時有 dotnet framework 與 dotnet core ，所以找個微軟官方提供的  <code>mcr.microsoft.com/dotnet/framework/sdk:4.8</code>, 裡面已經安裝了下列套件。 <a href="https://hub.docker.com/_/microsoft-dotnet-framework-sdk/">Docker Hub 連結</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.NET Framework Runtime</span><br><span class="line">Visual Studio Build Tools</span><br><span class="line">Visual Studio Test Agent</span><br><span class="line">NuGet CLI</span><br><span class="line">.NET Framework Targeting Packs</span><br><span class="line">ASP.NET Web Targets</span><br></pre></td></tr></table></figure><p>我用這個 base image 開了 workspace 資料夾並把 source code 複製進去後，接著就是大家熟悉的 nuget restore 、 dotnet build、 dotnet publish 在容器的環境內建置專案。</p><p>第二段是起另一個 base image <code>windows servercore 2019</code>，將剛剛建置好的 artifact 放到指定的資料夾，最後這一包會建置成 image 並推到公司的 Artifact management 上，其它人只要拉下這個 image 就可以執行了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">mcr.microsoft.com/dotnet/framework/sdk:4.8</span> <span class="string">AS</span> <span class="string">build-env</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">c:/workspace</span></span><br><span class="line"></span><br><span class="line"><span class="string">COPY</span> <span class="string">.</span> <span class="string">./</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">nuget</span> <span class="string">restore</span> <span class="string">src\nmqv3.sln</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">dotnet</span> <span class="string">restore</span> <span class="string">--configfile</span> <span class="string">src\.nuget\NuGet.Config</span> <span class="string">src\my_project.sln</span></span><br><span class="line"></span><br><span class="line"><span class="string">run</span> <span class="string">dotnet</span> <span class="string">build</span> <span class="string">-c</span> <span class="string">release</span> <span class="string">src\my_project.sln</span> </span><br><span class="line"><span class="string">run</span> <span class="string">dotnet</span> <span class="string">publish</span> <span class="string">-c</span> <span class="string">Release</span> <span class="string">-r</span> <span class="string">win-x64</span> <span class="string">--self-contained</span> <span class="literal">true</span> <span class="string">src\Router\Router.csproj</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">FROM</span> <span class="string">mcr.microsoft.com/windows/servercore:ltsc2019</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">c:/worker</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">--from=build-env</span> <span class="string">c:/workspace/src/Worker/bin/release/</span> <span class="string">.</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">c:/router</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">--from=build-env</span> <span class="string">c:/workspace/src/Router/bin/Release/netcoreapp3.0/win-x64/publish/</span> <span class="string">.</span></span><br></pre></td></tr></table></figure><p>從建置到最後要交付的 container image 一氣呵成，全部都濃縮在一份 dockerfile 裡面，這份 dockerfile 會跟著專案內，只要任何一台機器可以執行 docker container 就可以建置佈署這個專案，是不是方便許多 XD</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20200217/0.jpg&quot; alt=&quot;希望學會這個技巧後，以後大家弄CI/CD環境都能海闊天空&quot;&gt;&lt;/p&gt;
&lt;p&gt;(圖片出處 : &lt;a href=&quot;http://ezvivi2.com/article/200483.asp&quot;&gt;http</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://toyo0103.github.io/tags/Docker/"/>
    
    <category term="CI/CD" scheme="https://toyo0103.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>AsyncLocal and ThreadLocal</title>
    <link href="https://toyo0103.github.io/2020/01/22/aynclocal_threadlocal/"/>
    <id>https://toyo0103.github.io/2020/01/22/aynclocal_threadlocal/</id>
    <published>2020-01-22T06:00:00.000Z</published>
    <updated>2022-08-09T13:36:17.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">ThreadLocal</span>&lt;<span class="title">string</span>&gt; LocalString</span> = <span class="keyword">new</span> ThreadLocal&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LocalString.Value = <span class="string">&quot;Value 1&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【A】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = AsyncMethod();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【D】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> t1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">AsyncMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【B】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalString.Value = <span class="string">&quot;Value 3&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【C】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【E】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【A】 Thread: 14, ExcutionContext: 37151951 ,value: Value 1</span></span><br><span class="line"><span class="comment">//【B】 Thread: 14, ExcutionContext: 51676517 ,value: Value 1</span></span><br><span class="line"><span class="comment">//【C】 Thread: 14, ExcutionContext: 51676517 ,value: Value 3</span></span><br><span class="line"><span class="comment">//【D】 Thread: 14, ExcutionContext: 37151951 ,value: Value 3</span></span><br><span class="line"><span class="comment">//【E】 Thread: 16, ExcutionContext: 46128400 ,value: </span></span><br></pre></td></tr></table></figure><p>ThreadLocal 非常容易理解, 每個 Thread 之間彼此是隔離的, 即便 ExcutionContext 不同, 但只要是同一個 Thread 都會是共用的。</p><p>所以可以看到 await 之後, 因為不同 Thread 執行剩下的 Code , ThreadLocal 的值就變成預設的空值</p><br><h1 id="AsyncLocal"><a href="#AsyncLocal" class="headerlink" title="AsyncLocal"></a>AsyncLocal</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">AsyncLocal</span>&lt;<span class="title">string</span>&gt; LocalString</span> = <span class="keyword">new</span> AsyncLocal&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LocalString.Value = <span class="string">&quot;Value 1&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【A】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = AsyncMethod();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【D】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> t1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">AsyncMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【B】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">LocalString.Value = <span class="string">&quot;Value 3&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【C】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;【E】 Thread: <span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>, ExcutionContext: <span class="subst">&#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125;</span> ,value: <span class="subst">&#123;LocalString.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//【A】 Thread: 14, ExcutionContext: 5705933 ,value: Value 1</span></span><br><span class="line"><span class="comment">//【B】 Thread: 14, ExcutionContext: 12517624 ,value: Value 1</span></span><br><span class="line"><span class="comment">//【C】 Thread: 14, ExcutionContext: 12517624 ,value: Value 3</span></span><br><span class="line"><span class="comment">//【D】 Thread: 14, ExcutionContext: 5705933 ,value: Value 1</span></span><br><span class="line"><span class="comment">//【E】 Thread: 8, ExcutionContext: 35765882 ,value: Value 3</span></span><br></pre></td></tr></table></figure><p>AsyncLocal 會在每次需要切出 ExcutionContext 時複製一份給新的 ExcutionContext , 所以每個 ExcutionContext間的 AsyncLocal 都是獨立的，但同時可達跨 Thread , ExcutionContext 往下傳遞的特性。</p><div class="note info">            <p>參考文章</p><p><a href="https://www.cnblogs.com/zkweb/p/7747162.html">AsyncLocal的运作机制和陷阱</a></p><p><a href="https://www.cnblogs.com/tcjiaan/p/5007737.html">【.NET深呼吸】基於異步上下文的本地變量（AsyncLocal）</a></p><p><a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.executioncontext?view=netframework-4.8">ExecutionContext 類別</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h1&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;tab</summary>
      
    
    
    
    
    <category term="C#" scheme="https://toyo0103.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Service Discovery</title>
    <link href="https://toyo0103.github.io/2019/11/09/service_discovery/"/>
    <id>https://toyo0103.github.io/2019/11/09/service_discovery/</id>
    <published>2019-11-09T04:32:00.000Z</published>
    <updated>2022-08-09T13:36:17.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20191109/0.png" alt="/images/20191109/0.png"></p><p>( <a href="https://www.codeprimers.com/service-discovery-in-microservice-architecture/">https://www.codeprimers.com/service-discovery-in-microservice-architecture/</a> )</p><br><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>傳統上一組服務通常都會搭配 DNS + Load balance + serivce cluster, 服務要呼叫時也都是直接打 Domain 讓 Load balance 去導流。</p><p>不過這也面臨了管理 Domain 與服務間的複雜度, 例如服務要加一台新的機器需要去設定 Load balance 才有辦法服務(當然也是可以搭配一些 cloud autoscaling 機制來簡化流程); Client 在呼叫 Service 時通常需要真的打打看才有辦法知道服務是否還正常, 無法事先知道服務狀態再決定是否要呼叫。</p><p>近年微服務與容器化運用的盛行, 上述方式就顯得有點卡卡的，如果你的服務在 k8s 內那可能還好, 大部分它都幫忙處理掉了, 但如果像我們公司一樣, 很多服務雖然容器化但還無法進到 k8s 內, container 可以在短時間內 scale 成數倍來因應大流量, 但卡在這些服務需要去 load balance 註冊才有辦法讓流量導進來,  那顯然就有點做半套的感覺， Service Discovery 的應用就成為了重要的課題</p><br><h1 id="什麼是-Service-Discovery"><a href="#什麼是-Service-Discovery" class="headerlink" title="什麼是 Service Discovery"></a>什麼是 Service Discovery</h1><p>翻譯成中文就是服務發現(廢話…)，顧名思義就是呼叫端在需要時先透過搜尋來找到對應的服務，而要達成這點需要一些配合才能達成。</p><p>首先第一步, 當某個服務起來時應該主動向提供 service discovery 註冊自己是什麼服務? 位置在哪? 是否已經可以開始服務了? </p><p><img src="/images/20191109/1.gif" alt="/images/20191109/1.gif"></p><p>註冊時會搭配著 Health check 的機制, 告訴 service discovery 如何檢核這個節點是否健康的</p><p><img src="/images/20191109/2.png" alt="/images/20191109/2.png"></p><p>Client 在要叫用 service 時, 先透過 service name 詢問有哪些節點可用, 而 service discovery 也能準確地回應有哪些目前還是健康的節點可供呼叫 </p><p><img src="/images/20191109/3.png" alt="/images/20191109/3.png"></p><p>當節點損壞時, 以 container 的案例, 會直接換掉不健康的 container 重長一組, 而這又會回到圖一註冊的流程。</p><p>更細緻一點的作法還有對 service discovery 回應的列表做快取，例如快取 1 秒，當服務自己要被收掉時, 做好 graceful shutdown 先把自己從服務列表中 deregister , 並且等待 3 秒後才關機，避免快取到的 Client 打來你剛好停止服務。</p><p>或是對服務加上 Tag ，當特定用戶或 VIP 連進來時可以透過搜尋特定機器去執行</p><p><img src="/images/20191109/4.png" alt="/images/20191109/4.png"></p><br><h1 id="面臨的問題"><a href="#面臨的問題" class="headerlink" title="面臨的問題"></a>面臨的問題</h1><p>但並不是所有事情都是如此美好, 公司目前導入這些機制雖然可以大幅簡化管理內部服務 domain 這類的問題, 但對於 load balance，即選取適合的節點這點上還有一些問題要克服，例如傳統 ELB 這類的服務都會依據每個節點的回應速度來判斷接下來導流的分配，但 service discovery 因為 request 並不會經過它，所以相關 latancy 也無從監控與觀察, 所以 load balance 這題必須額外拉出來做相對應的監控機制。</p><p>再來當服務橫跨 vm 跟 k8s 時情境就變得更複雜，不過這些題目等到之後有明確的方向再做整理好了，久違的文章雖然都沒寫到 code，但還是把一些觀念記錄下來。相關的實作等之後有空再補吧 (逃)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20191109/0.png&quot; alt=&quot;/images/20191109/0.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;( &lt;a href=&quot;https://www.codeprimers.com/service-discovery-in-micros</summary>
      
    
    
    
    
    <category term="microservice" scheme="https://toyo0103.github.io/tags/microservice/"/>
    
    <category term="service discovery" scheme="https://toyo0103.github.io/tags/service-discovery/"/>
    
  </entry>
  
  <entry>
    <title>NATS Streaming 調查報告書</title>
    <link href="https://toyo0103.github.io/2019/08/19/nats_streaming/"/>
    <id>https://toyo0103.github.io/2019/08/19/nats_streaming/</id>
    <published>2019-08-19T15:00:00.000Z</published>
    <updated>2022-08-09T13:36:17.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20190819/0.jpg" alt="/images/20190819/0.jpg"></p><p>最近因為任務關係對 NATS Streaming 做了一些研究跟 POC，這邊把一些研究到的NATS Streaming 特性記錄下來</p><h1 id="什麼是-NATS"><a href="#什麼是-NATS" class="headerlink" title="什麼是 NATS"></a>什麼是 NATS</h1><p><a href="https://nats.io/">NATS</a> 是一種 Queue , 它效能比一般的 Queue 好上許多，號稱 Sender / Reciever 每秒可高達 20 萬筆 Message，這是非常驚人的數字。</p><p><img src="/images/20190819/1.png" alt="/images/20190819/1.png"></p><p>（來源：<a href="https://bravenewgeek.com/dissecting-message-queues/%EF%BC%89">https://bravenewgeek.com/dissecting-message-queues/）</a></p><p>可以看到 RabbitMQ 在它旁邊矮了一大截….</p><br><p>NATS 支援 Subscribe 模式，Subscriber 訂閱需要的 subject，當 NATS 收到 Message 時就會同時派發給所有訂閱者。</p><p><img src="/images/20190819/2.png" alt="/images/20190819/2.png"></p><p>（來源：<a href="https://nats-io.github.io/docs/developer/concepts/pubsub.html%EF%BC%89">https://nats-io.github.io/docs/developer/concepts/pubsub.html）</a></p><br><p>NATS 也支援 Queu Group，NATS 會對同一個 Queue Group 的所有 Subscriber 分配訂閱的 Message，而不會重複</p><p><img src="/images/20190819/3.png" alt="/images/20190819/3.png"></p><p>（來源：<a href="https://nats-io.github.io/docs/developer/concepts/queue.html%EF%BC%89">https://nats-io.github.io/docs/developer/concepts/queue.html）</a></p><p>不過這些都不算太特別，畢竟 RabbitMQ 一樣能做到相同的功能，最特別的是 NATS Streaming</p><br><h1 id="什麼是-NATS-Streaming"><a href="#什麼是-NATS-Streaming" class="headerlink" title="什麼是 NATS Streaming"></a>什麼是 NATS Streaming</h1><p>NATS Streaming 是附加在 NATS 之上的加值功能，他可以永久的保留所有的 Message，並且支援 Cursor（指標）功能，你可以任意的讓 Subscriber 回到特定的點 <strong>重播</strong> 所有的 Message。</p><p>這一點相當有用，試想一下，如果今天我們將所有交易的過程都透過 NATS Streaming 記錄下來，假設資料庫或記錄的地方損毀，我們只要重新 Replay 所有 Message，即能重建最後的結果。這也是 <a href="https://microservices.io/patterns/data/event-sourcing.html">Event Sourcing</a> 中最重要的的一環。</p><p>為了達成 Event Sourcing 這個設計模式的目標，演練了一些特定的情境</p><ol><li>為了達成 HA 及加快處理速度的需求，需要多個 Subscriber 同時訂閱相同 Subject，並且彼此不會做到重複的 Message。</li><li>演練災難還原，Subscriber 必須能回朔到過去的的定時間點，重新 Replay 所有歷程</li></ol><br><h2 id="1-Queue-Group"><a href="#1-Queue-Group" class="headerlink" title="1. Queue Group"></a>1. Queue Group</h2><p>其實第一項相對於容易，只要用 Queue Group 即可輕鬆達成，只要每個 Subscriber 給定同一組 Queue Group Name 即可。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = StanOptions.GetDefaultOptions();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subOptions = StanSubscriptionOptions.GetDefaultOptions();</span><br><span class="line">subOptions.MaxInflight = <span class="number">1</span>; <span class="comment">// MaxInflight</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cf = <span class="keyword">new</span> StanConnectionFactory();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = cf.CreateConnection(<span class="string">&quot;test-cluster&quot;</span>, clientId, options);</span><br><span class="line"><span class="keyword">var</span> s = c.Subscribe(<span class="string">&quot;foo&quot;</span>, queueGroup, subOptions, (obj, args) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">                ......</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待接收關機訊號</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//關閉連線</span></span><br><span class="line">s.Close(); </span><br><span class="line">c.Close();</span><br><span class="line">c.Dispose();</span><br></pre></td></tr></table></figure><p>這邊需要特別注意 <strong>MaxInflight</strong> 這個參數，為了效率 NATS  預設會一次派給 Subscriber 1000 則Message（預設值有點忘記），好讓 Subscriber 不需要每做完一筆才透過網路要下一筆 Message，但這也讓我測出一個問題，當預收的訊息太多並且 Subscriber 根本來不及消化掉，這時候 NATS 會判定該則訊息 timeout，轉而派給同群別的Subscriber 來處理，這時候可能會發生兩個 Subscriber 執行到同一筆 Message 的狀況，所以請估算好 MaxInflight 的值，避免抓一堆做不完重派的狀況發生。</p><p>當最後一個 <strong>Subscriber</strong> 離線後，Queue Group 即會被刪除</p><br><h2 id="2-Durable-Name"><a href="#2-Durable-Name" class="headerlink" title="2. Durable Name"></a>2. Durable Name</h2><p>前面有提到 NATS Streaming 支援 Cursor 的功能，當 Subscriber 都離線時，如果有給它 Durable Name，他會記得上次你執行到哪一筆，當下次 Subscriber 重新連上時會從那個點繼續往下派發</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subOptions = StanSubscriptionOptions.GetDefaultOptions();</span><br><span class="line">subOptions.DurableName = _appSetting.DURABLENAME;</span><br></pre></td></tr></table></figure><br><h2 id="3-StartAt"><a href="#3-StartAt" class="headerlink" title="3. StartAt"></a>3. StartAt</h2><p>接著來實作災難還原的步驟，首先如何讓特定的 Queue Group 退到特定的點，呈上，同時多個 Subscriber 與 Durable Name 都還是要能符合。</p><p>SDK 其實有提供 <strong>StartAt()</strong> 的 API</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Receive messages starting at a specific sequence number</span></span><br><span class="line"><span class="keyword">var</span> subOptions = StanSubscriptionOptions.GetDefaultOptions();</span><br><span class="line">subOptions.StartAt(<span class="number">22</span>);</span><br></pre></td></tr></table></figure><p>不過這邊需特別注意，同一個 Queue Group 只有在第一個 Subscriber 進來時（也就建立這個 Queue Group 的時候）<strong>StartAt 才會生效</strong>，之後進來的 Subscriber 帶這個值都會被直接忽略掉。</p><p>這邊問題就來了，當我們帶了 Queue Group ＋ Durable Name，即便所有的 Subscriber 都離線了，NATS 還是會貼心的幫你記錄最後執行到的地方，所以之後進來的 Subscriber 也都不可能是第一個了，換言之這樣的狀況是無法重新設定指標的。</p><p>所以如果要刪除  Queue Group ＋ Durable Name 的 Queue Group 唯一的方法只有讓所有的 Subscriber 退訂閱</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消訂閱 刪除該Group</span></span><br><span class="line">s.Unsubscribe();</span><br></pre></td></tr></table></figure><p>這邊跟上面的範例程式不一樣，上面的是用 **Close()**，這樣並不會讓 Subscriber 退訂閱，只會是離線而已，唯有用 <strong>Unsubscribe()</strong> 將 Subscriber 全部退訂閱後，有 Durable Name 的 Queue Group 才會被刪除掉。</p><p>另外 NATS SDK 並沒有提供查詢 Queue Group 所有 Subscriber 的 Client ID，依據官方的說法，這份清單應該是使用者需要自己維護的，在上面這個案例上，就會需要將所有 <strong>Subscriber</strong> 用相同 Client ID 連上線後退訂閱。</p><br><h2 id="4-ManualAcks"><a href="#4-ManualAcks" class="headerlink" title="4. ManualAcks"></a>4. ManualAcks</h2><p>用上述的方法成功刪除 Queue Group 後，下一步就是重新讓第一個 <strong>Subscriber</strong> 去建立 Queue Group 並指定 <strong>StartAt</strong> ，不過這邊有點麻煩的地方是，<strong>Subscriber</strong> 一連線後馬上就會開始拋 Message 過來，這時後如果你是希望災難還原與重新執行 Replay 分開做時就會很困擾。</p><p>預設 StanSubscriptionOptions 是收到 Message 後自動就幫你 Ack 回報 NATS 你收到了在處理了，NATS 也就會繼續往下把下一筆分配給別人，但我只是想指定位子不想要處理 Message 呢？</p><p>這時候就要透過設定將 Ack 改成手動回報</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subOptions = StanSubscriptionOptions.GetDefaultOptions();</span><br><span class="line">subOptions.ManualAcks = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = c.Subscribe(<span class="string">&quot;foo&quot;</span>, queueGroup, subOptions, (obj, args) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                      args.Message.Ack();</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>這樣只要不呼叫 **Ack()**，就等於不處理這筆 Message 了，當 Subscriber 離線或是 Message timeout，NATS 就會重新分派給其他 Subscriber 處理了，這樣也間接達到重建 Queue Group 與指定 Cursor 的目標。</p><div class="note info">            <p>參考文章</p><p><a href="https://nats-io.github.io/docs/">NATS Document</a></p><p><a href="https://github.com/nats-io/stan.net">The official NATS .NET C# Streaming Client</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20190819/0.jpg&quot; alt=&quot;/images/20190819/0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近因為任務關係對 NATS Streaming 做了一些研究跟 POC，這邊把一些研究到的NATS Streaming 特性記錄下</summary>
      
    
    
    
    
    <category term="microservice" scheme="https://toyo0103.github.io/tags/microservice/"/>
    
    <category term="NATS" scheme="https://toyo0103.github.io/tags/NATS/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPool</title>
    <link href="https://toyo0103.github.io/2019/08/01/threadpool/"/>
    <id>https://toyo0103.github.io/2019/08/01/threadpool/</id>
    <published>2019-08-01T11:14:00.000Z</published>
    <updated>2022-08-09T13:36:17.084Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p>GitHub SourceCode : <a href="https://github.com/toyo0103/ThreadPoolDemo">連結</a></p>          </div><p>自從加入精神時光屋團隊後，對於一些平行處理、多執行序等程式掌控力就越來越要求。為了不要當拖油瓶，這次練習的是 ThreadPoll，從這個練習可以更精準掌握 Thread 控制技巧。</p><br><h1 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h1><p>建立 Thread 其實是需要成本的，所以頻繁的建立 Thread 砍掉 Thread 相當耗效能，另一方面，如果等到有 Task 才開始建立 Thread 可能會導致第一個 Task 回應速度過慢。例如 : IIS 底層就有 ThreadPool ，為了因應 Request 進來時能更快速的回應，但又不能為了一昧追求速度不管資源的有效運用，所以ThreadPool 應該有增長跟最低維持幾條的上下限。</p><p>依據上面描述定義以下目標</p><ol><li>自製 ThreadPool</li><li>依據 Task 量決定 Thread 的數量，Task 過多會加開 Thread 處理，反之會減少</li><li>ThreadPool 可以設定 Thread 數量上下限 </li></ol><br><h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><p>希望呼叫的方式如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 建立自己的 ThreadPool ，設定 Thread 至少保持 3 條，上限不超過 10 條 </span></span><br><span class="line">        MyThreadPool myTreadPool = <span class="keyword">new</span> MyThreadPool(<span class="number">3</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一值塞任務進去,不管任務執行完了沒</span></span><br><span class="line">        <span class="comment">// 所以 ThreadPool 應該要能接住 Task 讓它們排隊消耗 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myTreadPool.Enqueue(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">        <span class="comment">// 等待執行結束</span></span><br><span class="line">        myTreadPool.WaitFinished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>MyThreadPool</strong> </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingCollection&lt;<span class="built_in">int</span>&gt; _jobQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _minThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _maxThread;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span>(<span class="params"><span class="built_in">int</span> minThread,<span class="built_in">int</span> maxThread</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._minThread = minThread;</span><br><span class="line">        <span class="keyword">this</span>._maxThread = maxThread;</span><br><span class="line">        <span class="comment">// 最多只能放 100 個 Task</span></span><br><span class="line">        <span class="keyword">this</span>._jobQueue = <span class="keyword">new</span> BlockingCollection&lt;<span class="built_in">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WaitFinished</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _jobQueue.TryAdd(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>實作 ThreadPool 保有最少的 Thread</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingCollection&lt;<span class="built_in">int</span>&gt; _jobQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _minThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _maxThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _currentThreadCount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Thread&gt; _threads;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span>(<span class="params"><span class="built_in">int</span> minThread,<span class="built_in">int</span> maxThread</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._minThread = minThread;</span><br><span class="line">        <span class="keyword">this</span>._maxThread = maxThread;</span><br><span class="line">        <span class="keyword">this</span>._jobQueue = <span class="keyword">new</span> BlockingCollection&lt;<span class="built_in">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">this</span>._currentThreadCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>._threads = <span class="keyword">new</span> List&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; minThread; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.CreateThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateThread</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">int</span> id = Interlocked.Increment(<span class="keyword">ref</span> _currentThreadCount);</span><br><span class="line">        <span class="keyword">if</span> (id &gt; _maxThread)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可開的 Thread 到達極限, 無法加開</span></span><br><span class="line">            Interlocked.Decrement(<span class="keyword">ref</span> _currentThreadCount);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(ThreadBody);</span><br><span class="line">        thread.Name = <span class="string">$&quot;Thread-<span class="subst">&#123;id&#125;</span>&quot;</span>;</span><br><span class="line">        thread.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._threads.Add(thread);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Thread count : <span class="subst">&#123;<span class="keyword">this</span>._currentThreadCount&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ThreadBody</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>實作 TheadBody </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ThreadBody</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = Thread.CurrentThread.Name;</span><br><span class="line">    Console.WriteLine(name + <span class="string">&quot; starts&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 Task 還沒有塞完就一直搶來處理</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>._jobQueue.IsCompleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> task = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(_jobQueue.TryTake(<span class="keyword">out</span> task, <span class="number">100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模擬 Task 要執行的時間, 0.1 ~ 0.5秒不等</span></span><br><span class="line">            Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="built_in">int</span> excuteTime = <span class="number">0</span>;</span><br><span class="line">            excuteTime = rnd.Next(<span class="number">100</span>, <span class="number">500</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span> do task_<span class="subst">&#123;task&#125;</span> spend <span class="subst">&#123;excuteTime&#125;</span> ms&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            Thread.Sleep(excuteTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(name + <span class="string">&quot; are closed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這邊會有一個問題, 如果塞 Task 的速度不定, 可能時快時慢, 如果中間間隔過長會導致 Thread 一直拿不到 Task 來工作卻又停不下來, 持續空轉 , 所以必須加一個機制讓它等待, 並在必要時刻喚醒</p><br><p><strong>ManualResetEvent</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ManualResetEvent _mre;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span>(<span class="params"><span class="built_in">int</span> minThread,<span class="built_in">int</span> maxThread</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>._mre = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ThreadBody</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = Thread.CurrentThread.Name;</span><br><span class="line">    Console.WriteLine(name + <span class="string">&quot; starts&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 Task 還沒有塞完就一直搶來處理</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>._jobQueue.IsCompleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> task = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(_jobQueue.TryTake(<span class="keyword">out</span> task, <span class="number">100</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="built_in">int</span> excuteTime = <span class="number">0</span>;</span><br><span class="line">            excuteTime = rnd.Next(<span class="number">100</span>, <span class="number">500</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span> do task_<span class="subst">&#123;task&#125;</span> spend <span class="subst">&#123;excuteTime&#125;</span> ms&quot;</span>);</span><br><span class="line">            Thread.Sleep(excuteTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">_mre.WaitOne();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>MSDN : <a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.manualresetevent?view=netframework-4.8">ManualResetEvent Class</a> </p><p>ManualResetEvent 就像是個手動的紅綠燈, 可以將 Thread Block 在 WaitOne 這行, 直到呼叫 ManualResetEvent.Set()將燈號切成綠燈, 全部的 Thread 才會往下繼續執行。</p><p>與之相對的是 <a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.threading.autoresetevent?view=netframework-4.8">AutoResetEvent Class</a> , 差別只在於 ManualResetEvent 呼叫 Set (綠燈), Reset (紅燈)。而 AutoResetEvent 呼叫 Set 每次只會隨機放一條 Thread , 不像 ManualRestEvent 是全部放</p><br><p><strong>Enqueue</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 表示容量滿了</span></span><br><span class="line">    <span class="keyword">while</span> (_jobQueue.TryAdd(i) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Queue Length 過長, 需加開 Thread</span></span><br><span class="line">        <span class="keyword">this</span>.CreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切成綠燈, 放掉所有 Thread 開始搶工作做</span></span><br><span class="line">_mre.Set();</span><br><span class="line">    <span class="comment">// 切成紅燈, 如果有 Tread 搶不到事情來做又會被 Block 在 _mre.WaitOne(); 那行</span></span><br><span class="line">    _mre.Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>實作動態伸縮 Thread 數量</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ThreadBody</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">       </span><br><span class="line"><span class="keyword">while</span> (!<span class="keyword">this</span>._jobQueue.IsCompleted)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">if</span> (_mre.WaitOne(<span class="number">5000</span>) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 進到這邊表示 Thread 並不是因為_mre.Set()被喚醒, 而是5秒 timeout</span></span><br><span class="line">            <span class="comment">// 嘗試回收 Thread</span></span><br><span class="line">            <span class="keyword">if</span> (Interlocked.Decrement(<span class="keyword">ref</span> _currentThreadCount) &lt; _minThread)</span><br><span class="line">            &#123;</span><br><span class="line">                Interlocked.Increment(<span class="keyword">ref</span> _currentThreadCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Thread count : <span class="subst">&#123;<span class="keyword">this</span>._currentThreadCount&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   Console.WriteLine(name + <span class="string">&quot; are closed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><strong>WaitFinished</strong></p><p>這個方法如果被呼叫時, 應該將所有 Thread 都喚醒, 並且等待每個 Thread 都執行完畢</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WaitFinished</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._jobQueue.CompleteAdding();</span><br><span class="line">    _mre.Set();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> _threads)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t.Join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>**完整版的 Code **</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 建立自己的 ThreadPool ，設定 Thread 至少保持 3 條，上限不超過 10 條 </span></span><br><span class="line">        MyThreadPool myTreadPool = <span class="keyword">new</span> MyThreadPool(<span class="number">3</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一值塞任務進去,不管任務執行完了沒</span></span><br><span class="line">        <span class="comment">// 所以 ThreadPool 應該要能接住 Task 讓它們排隊消耗 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myTreadPool.Enqueue(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">        <span class="comment">// 等待執行結束</span></span><br><span class="line">        myTreadPool.WaitFinished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingCollection&lt;<span class="built_in">int</span>&gt; _jobQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _minThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _maxThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _currentThreadCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ManualResetEvent _mre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Thread&gt; _threads;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadPool</span>(<span class="params"><span class="built_in">int</span> minThread,<span class="built_in">int</span> maxThread</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._minThread = minThread;</span><br><span class="line">        <span class="keyword">this</span>._maxThread = maxThread;</span><br><span class="line">        <span class="comment">// 最多只能放 100 個 Task</span></span><br><span class="line">        <span class="keyword">this</span>._jobQueue = <span class="keyword">new</span> BlockingCollection&lt;<span class="built_in">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">this</span>._currentThreadCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>._mre = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>._threads = <span class="keyword">new</span> List&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; minThread; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.CreateThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateThread</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">int</span> id = Interlocked.Increment(<span class="keyword">ref</span> _currentThreadCount);</span><br><span class="line">        <span class="keyword">if</span> (id &gt; _maxThread)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可開的 Thread 到達極限, 無法加開</span></span><br><span class="line">            Interlocked.Decrement(<span class="keyword">ref</span> _currentThreadCount);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(ThreadBody);</span><br><span class="line">        thread.Name = <span class="string">$&quot;Thread-<span class="subst">&#123;id&#125;</span>&quot;</span>;</span><br><span class="line">        thread.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._threads.Add(thread);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Thread count : <span class="subst">&#123;<span class="keyword">this</span>._currentThreadCount&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WaitFinished</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._jobQueue.CompleteAdding();</span><br><span class="line">        _mre.Set();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> _threads)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t.Join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Enqueue</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _mre.Set();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示容量滿了</span></span><br><span class="line">        <span class="keyword">while</span> (_jobQueue.TryAdd(i) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Queue Length 過長, 需加開 Thread</span></span><br><span class="line">            <span class="keyword">this</span>.CreateThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _mre.Reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ThreadBody</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">string</span> name = Thread.CurrentThread.Name;</span><br><span class="line">        Console.WriteLine(name + <span class="string">&quot; starts&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有 Task 還沒有塞完就一直搶來處理</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>._jobQueue.IsCompleted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> task = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(_jobQueue.TryTake(<span class="keyword">out</span> task, <span class="number">100</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">                <span class="built_in">int</span> excuteTime = <span class="number">0</span>;</span><br><span class="line">                excuteTime = rnd.Next(<span class="number">100</span>, <span class="number">500</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span> do task_<span class="subst">&#123;task&#125;</span> spend <span class="subst">&#123;excuteTime&#125;</span> ms&quot;</span>);</span><br><span class="line">                Thread.Sleep(excuteTime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_mre.WaitOne(<span class="number">5000</span>) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 此條 Thread 5秒都沒有工作, 嘗試收掉</span></span><br><span class="line">                <span class="keyword">if</span> (Interlocked.Decrement(<span class="keyword">ref</span> _currentThreadCount) &lt; _minThread)</span><br><span class="line">                &#123;</span><br><span class="line">                    Interlocked.Increment(<span class="keyword">ref</span> _currentThreadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">$&quot;Thread count : <span class="subst">&#123;<span class="keyword">this</span>._currentThreadCount&#125;</span>&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(name + <span class="string">&quot; are closed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h1><p>執行中應該可以看到 Task 消化不夠快而加開 Thread </p><p><img src="/images/20190801/1.png" alt="/images/20190801/1.png"></p><p>最後因為程式在等待 ReadKey(), 如果超過 5 秒不按會看到 Thread 收掉的訊息</p><p> <img src="/images/20190801/2.png" alt="/images/20190801/2.png"></p><p>按下任意鍵,就會全部收掉並關閉程式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info&quot;&gt;
            &lt;p&gt;GitHub SourceCode : &lt;a href=&quot;https://github.com/toyo0103/ThreadPoolDemo&quot;&gt;連結&lt;/a&gt;&lt;/p&gt;
          &lt;/div&gt;
</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://toyo0103.github.io/tags/LeetCode/"/>
    
    <category term="精神時光屋" scheme="https://toyo0103.github.io/tags/%E7%B2%BE%E7%A5%9E%E6%99%82%E5%85%89%E5%B1%8B/"/>
    
  </entry>
  
  <entry>
    <title>【.Net Core】dotnet tool</title>
    <link href="https://toyo0103.github.io/2019/05/30/dotnet_tool/"/>
    <id>https://toyo0103.github.io/2019/05/30/dotnet_tool/</id>
    <published>2019-05-30T08:37:00.000Z</published>
    <updated>2022-08-09T13:36:17.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h1><p><img src="/images/20190530/0.png" alt="/images/20190530/0.png"></p><p>最近在公司開發一支稱為 Linter 的小程式，負責檢查 Bitbucket  PR 的異動內容，看看是否有符合公司規範 ，例如 : 加了 Config 後是否有確實在對應環境補上相關設定，盡量避免這種編譯檢查不出來但上線才壞掉的情況。</p><p>原本預想的架構圖如上圖，使用者發了 PR ，透過 Webhook 觸發 Jenkins Master ，由 Master 安排一台機器去執行檢查。</p><p>但面臨一個問題是，當 Linter 這支程式要更版時變得很麻煩，因為每台 Jenkins 都必須要更新這支程式，原本也有想說不如把 Linter 獨立一台機器寫成類似像 API 的服務好了，但未來勢必面臨太多 PR 導致瓶頸，之後在導入 ELB 加多台機器 …. 想著想著就覺得太麻煩了。</p><p>之後同事建議可以包成 dotnet tool 的工具，Linter 要更新時只是發佈新版 Nuget ，而不是去佈署每台 Jenkins Slave，而  Jenkins Slave 每次要執行檢查 PR 時，先檢查自己套件是否為最新版的再往下執行。</p><p><img src="/images/20190530/1.png" alt="/images/20190530/1.png"></p><p>整個流程瞬間變得簡單乾淨許多，所以就動手開始將這套程式包成 dotnet tool</p><br><h1 id="製作-dotnet-tool"><a href="#製作-dotnet-tool" class="headerlink" title="製作 dotnet tool"></a>製作 dotnet tool</h1><p>首先將要包成 dotnet tool 的專案檔 csproj 加上 PackAsTool 設定  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Exe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netcoreapp2.1<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AssemblyName</span>&gt;</span>Linter<span class="tag">&lt;/<span class="name">AssemblyName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RootNamespace</span>&gt;</span>Linter<span class="tag">&lt;/<span class="name">RootNamespace</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PackAsTool</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PackAsTool</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>將執行檔打包成 nupkg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dotnet pack -c release -o nupkg -p:PackageVersion=1.0.0 src\Linter.csproj</span></span><br></pre></td></tr></table></figure><p>推上 Nuget Server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nuget.exe push src\nupkg\Linter.1.0.0.nupkg &lt;Nuget Key&gt; -<span class="built_in">source</span> &lt;Nuget Server&gt;</span></span><br></pre></td></tr></table></figure><br><h1 id="執行-dotnet-tool"><a href="#執行-dotnet-tool" class="headerlink" title="執行 dotnet tool"></a>執行 dotnet tool</h1><p>Install</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dotnet tool install --add-source &lt;Nuget Server&gt; -g Linter</span></span><br></pre></td></tr></table></figure><p>Update</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dotnet tool update -g --no-cache Linter</span></span><br></pre></td></tr></table></figure><p>接著就看你原本怎麼封裝 Cli ，直接執行即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> Linter check -n .......</span></span><br></pre></td></tr></table></figure><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>第一次使用 dotnet tool 有驚豔到，以前都只會傻傻的用 console application ，每次都覺得部屬超麻煩，以後透過 dotnet tool 真的是方便多了 </p><div class="note info">            <p><a href="https://blog.miniasp.com/post/2018/04/19/DotNet-Core-2-1-Global-Tools">保哥 - 體驗 .NET Core 2.1 全新的全域工具安裝與使用 (.NET Core Global Tools)</a></p><p><a href="https://docs.microsoft.com/zh-tw/dotnet/core/tools/global-tools-how-to-create">使用 .NET Core CLI 建立 .NET Core 通用工具</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;情境&quot;&gt;&lt;a href=&quot;#情境&quot; class=&quot;headerlink&quot; title=&quot;情境&quot;&gt;&lt;/a&gt;情境&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/20190530/0.png&quot; alt=&quot;/images/20190530/0.png&quot;&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="dotnet core" scheme="https://toyo0103.github.io/tags/dotnet-core/"/>
    
  </entry>
  
  <entry>
    <title>【SQL】Output</title>
    <link href="https://toyo0103.github.io/2019/05/07/sql_output/"/>
    <id>https://toyo0103.github.io/2019/05/07/sql_output/</id>
    <published>2019-05-07T02:36:00.000Z</published>
    <updated>2022-08-09T13:36:17.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20190507/0.jpg" alt="/images/20190507/0.jpg"></p><h1 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h1><p>DBA 反應偵測到有個 Update Query 很頻繁，且通常緊接著 Update 後都會再進 Select 把剛剛 Update 的資料拉走，資料量太大時頻率太高導致 SQL 效能瓶頸，建議調整成 Update 後直接把剛剛異動的資料拉走，而不是拆兩段查詢。</p><h1 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h1><p>當 SQL Server 執行 Update 時會 Lock 相關要異動的資料，並把異動前後的資料放入 Log 中，如果希望能在一次 Query 中就把資料 Update 並把影響到的資料回傳，可以透過 <code>Ouput </code> 這個子句來達成</p><div class="note info">            <p>Ouput 可用於以下情境</p><p>Delete</p><p>Insert</p><p>Update</p><p>Merge</p>          </div><p>我們有一張表，紀載著每個人的名稱與學期分數</p><p><img src="/images/20190507/1.png" alt="/images/20190507/1.png"></p><p>老師大發慈悲想把低於 60 分的人都改成 60 分及格，這時候語法可以這樣下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@UpdateLog</span> <span class="keyword">table</span>(</span><br><span class="line">Id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">Name nvarchar(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">OriScore <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">NewScore <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">UPDATE dbo.[<span class="keyword">User</span>]</span><br><span class="line"><span class="keyword">SET</span> Score <span class="operator">=</span> <span class="number">60</span></span><br><span class="line">OUTPUT INSERTED.Id,</span><br><span class="line">   INSERTED.Name,</span><br><span class="line">   DELETED.Score,</span><br><span class="line">   INSERTED.Score</span><br><span class="line"><span class="keyword">INTO</span> <span class="variable">@UpdateLog</span></span><br><span class="line"><span class="keyword">WHERE</span> Score <span class="operator">&lt;</span> <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="variable">@UpdateLog</span></span><br></pre></td></tr></table></figure><p><img src="/images/20190507/2.png" alt="/images/20190507/2.png"></p><div class="note info">            <p>參考資料</p><p><a href="https://docs.microsoft.com/zh-tw/sql/t-sql/queries/output-clause-transact-sql?view=sql-server-2017">Microsoft - OUTPUT 子句 (Transact-SQL)</a></p><p><a href="https://www.essentialsql.com/sql-update-statement/">Use SQL UPDATE to Query and Modify Data</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/20190507/0.jpg&quot; alt=&quot;/images/20190507/0.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;情境&quot;&gt;&lt;a href=&quot;#情境&quot; class=&quot;headerlink&quot; title=&quot;情境&quot;&gt;&lt;/a&gt;情境&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    
    <category term="SQL" scheme="https://toyo0103.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>【AWS】EC2 can&#39;t access metadata service</title>
    <link href="https://toyo0103.github.io/2019/04/30/aws_windows_ec2_cant_access_metadata/"/>
    <id>https://toyo0103.github.io/2019/04/30/aws_windows_ec2_cant_access_metadata/</id>
    <published>2019-04-30T07:52:00.000Z</published>
    <updated>2022-08-09T13:36:17.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情境"><a href="#情境" class="headerlink" title="情境"></a>情境</h1><p>EC2 上的 windows VM 突然無法存取相對應的 AWS 服務，而這些權限原本都是透過 IAM Role 賦予的，之前文章有提過 AWS 機器是如何透過 IAM Role 得知自己有哪些權限</p><div class="note info">            <p><a href="/2019/02/19/windows_contianer_iamrole_/">Windows IAM Role 問題</a></p>          </div><p>在該機器呼叫 metadata service 會回應錯誤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl 169.254.169.254</span></span><br></pre></td></tr></table></figure><p>詢問對 AWS 比較熟的一些同事，聽說在 windows server 2012 版本之後，更換 Instance Type 重新開機時會發生</p><br><h1 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h1><p>執行 C:\ProgramData\Amazon\EC2-Windows\Launch\Scripts\InitializeInstance.ps1 ，它會重新 Binding 一些相關設定，執行完後就好了</p><div class="note info">            <p>參考文章</p><p><a href="https://stackoverflow.com/questions/45095261/aws-ec2-windows-10-cant-access-metadata">[Stackoverflow] AWS EC2 Windows 10 can’t access metadata</a></p>          </div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;情境&quot;&gt;&lt;a href=&quot;#情境&quot; class=&quot;headerlink&quot; title=&quot;情境&quot;&gt;&lt;/a&gt;情境&lt;/h1&gt;&lt;p&gt;EC2 上的 windows VM 突然無法存取相對應的 AWS 服務，而這些權限原本都是透過 IAM Role 賦予的，之前文章有提過 A</summary>
      
    
    
    
    
    <category term="aws" scheme="https://toyo0103.github.io/tags/aws/"/>
    
  </entry>
  
</feed>
