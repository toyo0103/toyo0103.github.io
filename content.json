{"meta":{"title":"程式隨筆","subtitle":null,"description":null,"author":"Toyo","url":"https://toyo0103.github.io","root":"/"},"pages":[{"title":"categories","date":"2018-05-15T06:05:16.000Z","updated":"2022-08-09T13:36:17.098Z","comments":false,"path":"categories/index.html","permalink":"https://toyo0103.github.io/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2018-09-12T09:18:00.000Z","updated":"2022-08-09T13:36:17.098Z","comments":false,"path":"about/index.html","permalink":"https://toyo0103.github.io/about/index.html","excerpt":"","text":"擅長ASP.Net MVC、Web API2、Unit Test、Git、有過建置CI/CD的經驗，持續關注.NET Core的發展，期望有天能透過它將網站放到Linux上運行。曾應用過AWS SES、Storage，Azure Redis、MS SQL等服務，略懂前端Vue與JQuery框架。 目前持續學習日文，朝著考取N2為目標前進，自學生時期開始與英文搏鬥至今，依然處於下風，立志不再被『教你30天精通英文』書給騙的平凡工程師。 經歷 91APP 資深工程師 美而快實業股份有限公司 資深工程師 永慶房產集團 資深工程師 沃克威資訊股份有限公司 工程師 專案簡歷 線上服飾電子商務平台建置 房市行情數據計算 地圖行情搜尋效能優化 公部門入口網站建置 證照 日檢N3合格(2018)"},{"title":"tags","date":"2018-05-15T05:14:25.000Z","updated":"2022-08-09T13:36:17.204Z","comments":false,"path":"tags/index.html","permalink":"https://toyo0103.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"How cache-control directives affect caching?","slug":"cache_control_directives","date":"2022-12-03T07:00:00.000Z","updated":"2022-12-03T08:10:22.755Z","comments":true,"path":"2022/12/03/cache_control_directives/","link":"","permalink":"https://toyo0103.github.io/2022/12/03/cache_control_directives/","excerpt":"","text":"I’m curios how cache-control directives affect caching, so I make a small experiment to see the interaction between browser, reverse proxy and server. I introduce 6 APIs that respond different cache-control value in response header and current time only. Reponse Cache-Control [GET]/cache/get-public public,max-age=120 [GET]/cache/get-private private,max-age=120 [GET]/cache/get-unset max-age=120 [DELETE]/cache/delete-public public,max-age=120 [DELETE]/cache/delete-private private,max-age=120 [DELETE]/cache/delete-unset max-age=120 Create a simple web page for test Clicking the buttons will call the APIs and show the response data on page. At the same time I monitor the developer tool to record the results. Whether the browsers cache the response? (tested on safari, chrome and edge) Public Private Unset GET V V V DELETE X X X Whether the reverse proxy(I use nginx) caches the response? Public Private Unset GET V X X DELETE X X X According to the results, we know the modern browsers would not break the rule of cacheable and reverse proxy may not store the response when you don’t set public/private directives. ReferencesCache-Control - HTTP | MDN (mozilla.org)Cacheable - MDN Web Docs Glossary: Definitions of Web-related terms | MDN (mozilla.org)","categories":[],"tags":[{"name":"Cache","slug":"Cache","permalink":"https://toyo0103.github.io/tags/Cache/"}]},{"title":"HttpClient doesn't change cookie value per request","slug":"http_client_does_not_change_cookie_value_per_request","date":"2022-08-08T03:00:00.000Z","updated":"2022-08-09T14:30:13.203Z","comments":true,"path":"2022/08/08/http_client_does_not_change_cookie_value_per_request/","link":"","permalink":"https://toyo0103.github.io/2022/08/08/http_client_does_not_change_cookie_value_per_request/","excerpt":"","text":"Recently I found that the HttpClient doesn’t change cookie value per request, and it will cache the value for 2 minutes after the first request which have set the cookie value sent. Environment dotnet 5 runtime image: mcr.microsoft.com/dotnet/aspnet:5.0 DescriptionI use typed client in our project and use HttpRequestMessage to set the cookie “user.token” in every request. 1234567891011121314151617181920212223242526public class MyHttpClient : IMyHttpClient&#123; private readonly HttpClient _httpClient; public MyHttpClient(HttpClient httpClient) &#123; this._httpClient = httpClient; &#125; public async Task CallAPI() &#123; ... var request = new HttpRequestMessage(HttpMethod.Post, &quot;/the/api&quot;); // set request content request.Content = new StringContent(&quot;mydata&quot;, Encoding.UTF8, &quot;application/json&quot;); // set cookie here request.Headers.Add(&quot;Cookie&quot;, $&quot;user.token=&#123;token&#125;&quot;); var response = await _httpClient.SendAsync(request); response.EnsureSuccessStatusCode(); var res = await response.Content.ReadAsStringAsync(); ... &#125;&#125; Register MyHttpClient to the Denpency Injection provider. 12345services.AddHttpClient&lt;IMyHttpClient, MyHttpClient&gt;(config =&gt;&#123; config.BaseAddress = new Uri(&quot;https://my.server.com&quot;);&#125;); When I use CallAPI() of MyHttpClient, I found the cookie doesn’t change value per request, and it will cache value for 2 minutes. WhyHttpClient is just a container of HttpClientHandler. If you trace the source code on Github you will see the code 1234567891011121314151617181920212223242526272829303132public HttpClient CreateClient(string name)&#123; if (name == null) &#123; throw new ArgumentNullException(nameof(name)); &#125; var handler = CreateHandler(name); var client = new HttpClient(handler, disposeHandler: false); var options = _optionsMonitor.Get(name); for (var i = 0; i &lt; options.HttpClientActions.Count; i++) &#123; options.HttpClientActions[i](client); &#125; return client;&#125;public HttpMessageHandler CreateHandler(string name)&#123; if (name == null) &#123; throw new ArgumentNullException(nameof(name)); &#125; var entry = _activeHandlers.GetOrAdd(name, _entryFactory).Value; StartHandlerEntryTimer(entry); return entry.Handler;&#125; When you are asking for HttpClient, HttpClientFactory will generate a HttpClient instance everytime and try to get HttpMessageHandler from the pool. Why HttpClientFactory maintains HttpMessageHandler pool for us? Because creating TCP connections are extremely expensive, so we should reuse it as we can as possible. So multiple HttpClients will possibly use same HttpMessageHandler. HttpMessageHandler has Property named CookieContainer. It will store cookie value when you first time to set the value. So it will cause different requests using same cookie value until HttpMessageHandler expired. SolutionThere is a way to stop HttpMessageHandler using CookieContainer. 123456789services.AddHttpClient&lt;IPortalShellClient, PortalShellHttpClient&gt;(config =&gt;&#123; config.BaseAddress = new Uri(clientConfig.PortalSiteEndpoint);&#125;).ConfigurePrimaryHttpMessageHandler(() =&gt;&#123; //Tell HttpMessageHandler to stop using CookieContainer return new HttpClientHandler &#123; UseCookies = false &#125;;&#125;); Then you can set cookie value per request now. References Do pooled HttpClient instances keep the CookieContainer? HttpClientHandler.cs","categories":[],"tags":[{"name":"dotnet core","slug":"dotnet-core","permalink":"https://toyo0103.github.io/tags/dotnet-core/"}]},{"title":"[讀書心得][領域驅動設計與 .Net Core] Chapter2: 語言與情境","slug":"book_hands_on_ddd_with_dotnet_ch2","date":"2022-05-25T14:00:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2022/05/25/book_hands_on_ddd_with_dotnet_ch2/","link":"","permalink":"https://toyo0103.github.io/2022/05/25/book_hands_on_ddd_with_dotnet_ch2/","excerpt":"","text":"建立共同語言這章主是在講述語言的重要性，而語言又如何直接間接的影響到系統的成敗。這邊的語言並非指程式語言，而是指在相同情境下大家所共同理解的語言，就用 User 這個詞來舉例，在不同情境下就可能代表著不同意義 對購物網站而言 : User 可能代表的是逛商城的消費者 對商城平台而言 : User 可能代表是進駐的廠商 對商城後台而言 : User 可能代表的是進駐廠商的員工 一個 User 在各個情境下代表著不同意義，想關注的事情也不盡相同，當我們沒有情境為背景下，單單用 User 做為溝通可能會陷入雞同鴨講的狀況，這就是情境之於語言為何重要的地方。 過去開會時發現一個現象，時常開發單位與需求單位在溝通時，彼此對於同一個東西用的詞是完全不同的，當需求單位在描述事情時，較新進或對 Domain 不熟的開發人員可能會弄不清楚對方在說什麼，這時候就需要熟的人在旁邊補充「他指的是系統裡的 xxx」，而會產生這樣的差距，常常是因為開發人員將他們的工作視為”將需求翻譯成程式語言”，所以程式內的語言可能自成一格，並與現實用語脫鉤，而這類的情況一多，當不同背景的人共同溝通時就會需要彼此一直翻譯，翻譯的狀況越多，中間遺失掉的”知識”可能就越多，大家應該都有看過翻譯很爛的書的經驗吧… 所以書中建議為不同背景的人找尋共同用語相當重要，這可以減少溝通時因為翻譯而導致的落差，書中舉了一個很真實的案例：當使用者在廣告系統中發佈 (publish) 廣告時，為了避免帶有惡意或不適當的內容，會讓該廣告進入審核的流程 ….，而當這個需求轉化為程式語言後可能會變成 當使用者按下 publish 按鈕時，將廣告狀態更新為 Published，並且發出廣告狀態已變更(AdStatusUpdated)的事件 審核系統收到 廣告狀態已變更(AdStatusUpdated) 事件時將廣告撈出來排入審核流程 看出這中間有多大的落差了嗎？我們在系統中不用 廣告已被發佈(AdPublished)，取而代之的是廣告狀態已變更（AdStatusUpdated），發佈的動作轉化成狀態的變更，需求在這大量轉化為系統程式碼的過程中，很有可能原始的意圖早已消失，而這可能正是關鍵知識遺失的過程。 精準需求的迷失每當我們交付功能給客戶，面對客戶的不滿意時，常常歸因於需求描述的失準，開發團隊內會互相抱怨、指責，開發者埋怨開需求的人規格亂寫，開需求的人埋怨開發者搞不清楚也不問，導致開發出來的系統與最終想解決的問題有一大段落差，所以團隊可能會開始找更厲害的 PO 或 PM，開始要求規格書的格式，試圖用鉅細彌遺厚厚一本的規格書來彌補與真實之間的落差。 而事實真的是這樣嗎？很多時候開發人員是沒有機會直接面對需求單位或業務人員的，所以當這些需求單位透過與系統分析師描述後，再透過系統分析師的理解轉化成規格書，這中間可能就已經遺失了一部分真實。 很多時候會議內所謂的共識，是你以為你的共識，我以為我的共識，實際上彼此認知的事情根本不是一回事，等雙方都告一段落後回來一對才發現跟當時說的不一樣，但彼此都覺得自己是照當時的決議實作的啊，所以問題可能不是雙方背信，而是彼此認知根本不在同一個點上。 書中提到可以嘗試在溝通中，用視覺化的方式彌平彼此認知的落差，而我自己的經驗也發現，大量的文字描述常常聽者很難聚焦，當開始把各個會議中談到的東西視覺化，輔助上依賴關係與線性流程，有助於幫助與會人員更能聚焦在同一個點上。圖片來源: 領域驅動設計與 .Net Core 書中 p.26 透過新的術語發現新的情境最前面提到在不同情境下，User 可能代表的意義完全不同，當我們在討論過程中可能會脫口而出前台的消費者、平台的廠商、後台的管理者…等等，而當這些用語的不同時，其實也幫助了我們發現了新的情境，針對這些新出現的情境建立對應的模型是需要的，對比於前面只用 使用者(User)來描述，後者更精準也更貼近真實，這也可以避免開發者寫出近乎於上帝類別的 User 來。 雖然短短一小篇，但發現要把讀完的東西用自己的話再說一次真的還有一段差距啊","categories":[{"name":"領域驅動設計與.Net Core","slug":"領域驅動設計與-Net-Core","permalink":"https://toyo0103.github.io/categories/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"}],"tags":[{"name":"DDD","slug":"DDD","permalink":"https://toyo0103.github.io/tags/DDD/"},{"name":"讀書心得","slug":"讀書心得","permalink":"https://toyo0103.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"},{"name":"領域驅動設計與 .Net Core","slug":"領域驅動設計與-Net-Core","permalink":"https://toyo0103.github.io/tags/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"}]},{"title":"[讀書心得][領域驅動設計與 .Net Core] Chapter1: 為什麼需要領域驅動設計","slug":"book_hands_on_ddd_with_dotnet","date":"2022-05-23T14:52:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2022/05/23/book_hands_on_ddd_with_dotnet/","link":"","permalink":"https://toyo0103.github.io/2022/05/23/book_hands_on_ddd_with_dotnet/","excerpt":"","text":"圖片來源: https://www.tenlong.com.tw/products/9789864348602 第一章講述了軟體發展史中，為了解決軟體開發上的困境許多方法被發明了出來，而雖然每個方法都宣稱能有效解決（或部分解決）專案上的問題，但經過統計，成功的專案始終不超過 22%。而 DDD 也是為了解決軟體開發時所碰到的困境所被提出來的一種方法。 軟體通常是為了解決某些問題而被研發的，所以當錯誤的理解問題就很容易導致失敗，人類在解決問題上有著豐富的經驗，所以當人類看到問題時，通常會有一些直覺的解決方案浮出腦中（快思慢想也有提到這點），這可能源自於你的經驗或是過往學經歷，而這直覺的好點子很高的可能是錯誤的方向，而人往往又會傾向於找盡各種方法試圖說服自己剛剛的好點子是正確的，即便在實作的過程中隱約察覺到不對勁了… 個人經驗中有察覺到這個現象，常常誤以為自己一開始的想法是正確的，所以即便過程中發現問題也會用各種變形方法試圖將問題套入其中，而這往往會將問題變得更複雜。我曾經跟專案成員討論目前框架使用上的困境，而我發現大部分人會傾向在框架中設計各種 Config 、環境變數切換來滿足所謂的特殊情境，而沒有去思考框架設計是否瞄準錯了問題。又或是為了解決部署環境問題，直接聯想到 Container 解決方案，結果為了管理 Container 所以引入更複雜的 k8s 做為編排的工具，也許本質想解決的問題沒這麼複雜，卻在解決的過程中意外的把問題變得更複雜。 避免無知書本中將無知分類成五個層級 缺少無知(lack of ignorance) : 表示你擁有大部分的知識，知道「該做什麼」、「怎麼做」 缺乏知識(lack of knowledge) : 你意識到自己的無知，所以你獲取更多知識來填補知識的落差 缺乏意識(lack of awareness) : 「不知道自己不知道」，連意識到無知都沒有，例如拿到規格就覺得自己知道要解決的問題是什麼了，而忽略了其實自己根本不知道本質問題是什麼狀況，人往往會做出錯誤決策都屬這層 缺乏流程(lack of process) : 你不知道你自己不知道是什麼，也無管道能弄清楚 元無知(meta igonorance) : 連無知的五個層次都不知道 DDD 之父 Eric Evans 對於「提前設計」提出了見解 : 我們在專案的初期會進行提前設計的動作，而此時恰好也是我們擁有「最少知識」並且是最無知的時期。在專案開始時幾乎沒有知識的情況下，就對軟體的設計和架構做出大多數的「重要決策」，這不會是個好的做法。 個人覺得這跟敏捷中提到的小增量多迭代道理是一樣的，我們很難在專案初期就了解問題的全貌，所以小步前進，並且因應碰到的問題即時快速的調整，才能讓我們越來越貼近真實情況的樣貌，也可以降低在專案初期的過度設計，導致架構一直調整的窘境。 隨著現代專案要處理的問題越來越複雜（可能是質或是量的複雜度），有效的處理領域知識、減少無知，準確將問題分類，避免實現目標路途中的認知偏誤，DDD 就是想要解決這些問題所被提出的。","categories":[{"name":"領域驅動設計與.Net Core","slug":"領域驅動設計與-Net-Core","permalink":"https://toyo0103.github.io/categories/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"}],"tags":[{"name":"DDD","slug":"DDD","permalink":"https://toyo0103.github.io/tags/DDD/"},{"name":"讀書心得","slug":"讀書心得","permalink":"https://toyo0103.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"},{"name":"領域驅動設計與 .Net Core","slug":"領域驅動設計與-Net-Core","permalink":"https://toyo0103.github.io/tags/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"}]},{"title":"弱雞 Tech Lead 初體驗","slug":"become_a_tech_lead","date":"2022-05-20T15:39:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2022/05/20/become_a_tech_lead/","link":"","permalink":"https://toyo0103.github.io/2022/05/20/become_a_tech_lead/","excerpt":"","text":"近期很後悔自己中斷了寫部落格的習慣，為了重新養成這個習慣，所以有了這開春第一篇文章（都快夏天了老闆～），而既然是開春第一篇，想說就來寫些較軟性的題目好了（絕對不是我技術都沒長進的關係啦…），所以今天就來聊聊近期與團隊共患難的事情好了。 可能老闆知道我今年犯太歲的關係，不能讓我太好過，所以年初就派我去擔任一個 5 人小團隊的 tech lead，一開始本來懷抱著 “大家都很優秀，我應該只要去幫大家打打雜就好”的心態加入，殊不知考驗才剛剛開始。 這個團隊負責的是一個架構與開發框架性質的專案，亦即它的設計未來可能會直接影響 N 個團隊的開發習慣與 N 個服務掛在上面的行為，所以它的難度不低，加上初期時程壓力、人力吃緊的情況下，體質並不是很好，例如： 專案幾乎沒有測試，上線常常發生改 A 壞 B 的情況 文件非常多，但跟實際系統運作邏輯有不小的落差 系統在還不穩固的情況下已經釋出 SDK 給團隊使用，加大改版向下相容的挑戰 Release 純手工，過程中需要人工介入調整許多地方，不熟的人看文件還要花半天以上才能搞定 框架本身的目標與使用該框架的服務需求間的拉扯，導致初期就有高度客製化的狀況，增加了後續入住這個框架得複雜度 資料庫版控管理不佳，每次更版幾乎都要倒資料，間接也讓服務開不出 API，因為實時的資料異動會導致資料遺失 基於上述原因，團隊士氣其實並不高，因為即便是看似簡單的功能上線都如履薄冰，加上該專案是受到重視的專案（被定位為乘載公司未來性的框架），人員陸續補進來，團隊的壓力也隨之增加，因為人力往往與產值掛鉤，給予對應的人力沒有對應的產值是無法被接受的。 所以初期我花最多時間思考的不是怎麼滿足需求，反而是該如何穩住系統跟增加開發成員的信心，在軟體業也快 10 年了，新需求與改需求是不會有停止的一天，每個跟你談的需求都會很急很趕，不急不趕才是新聞，所以與其追著需求跑，我更在思考的是 該如何穩住這個系統 ? 讓開發人員有信心，讓新進人員能在最短時間成為戰力 這個框架到底想解決的本質問題是什麼？ 如果它沒有守住那條線，這個框架基本上也沒有存在的價值 所以我跟主管談了一個方案，農曆年前約三週時間需求我一律不收也不處理，一切請他幫我緩到農曆年後再說，對內開始跟團隊成員著手處理以下問題 重建系統核心我開始與團隊成員梳理目前系統運作的脈絡，對我來說系統要在不斷變動的環境下發展，不外乎讓你的程式碼能好好說明系統在做什麼，如果連幾個類別物件間的互動關係都說不清楚寫不好，又該如何期待這成千上萬行的程式碼堆疊出來系統會有一套清晰的邏輯在運作。又如何期待新進工程師能在眾多的文件中自己理出系統邏輯，縱然文件全然正確，理解文件後對應到程式碼的運作，這中間還有一段很長的路要走。所以我很喜歡 Uncle Bob 說的『世界上最好的文件應該是你的程式碼。』這個觀念剛好也契合 DDD 中所強調的，把你的專注力先放在解決核心問題上，把問題之外的資料庫、 Schema、 軟體分層、作業系統先切開，先用最簡單的類別與物件來展示你要解決的業務邏輯，當這些都說得通、運作得當，剩下的都是支撐這個核心的基礎建設而已。 建立單元測試我與團隊成員立下的第一個約定就是 “MR 只要沒有單元測試一律退回”，我認為確保寫出來的程式運作邏輯的正確性是身為工程師的基本素養，Code Review 應該是讓大家討論與互相學習的場域，並試著透過多人 Review 從不同角度尋找盲點，防止重大舞弊、效能、資安…等問題，不要期待 Reviewer 能用肉眼幫你找出所有漏洞，如果寫單元測試都無法保證系統百分之百正確了，更何況不寫。寫單元測試好處真的很多，除了能用最低成本快速驗證你的想法與程式碼之外，它也在保護你的團隊成員，當專案龐大到一個程度，團隊內成員對於 Code 與各個需求掌握度也都會有落差，所以當未來需求變動時，它能幫忙把關是否哪邊因為變動而出錯了。 重新梳理開發流程與 CI/CD與團隊成員討論了之前的分支策略後利弊後，我們開始改成 trunk-based 的跑法，試著降低大家解衝突的時間，並逼大家思考持續整合回 Master 的相容性問題，同時也開始投入資源建立 CI/CD ，讓一些明確與重複的流程自動化，降低部署的時間與負擔。穩固快速的部署流程不單單只是減少時間的浪費，往往也能增加團隊成員的信心，你會有信心即便真的最後出錯了，我們都有機會在很短的時間內迭代修復或退版，就像打籃球時有個超強中鋒幫你搶籃板一樣，各個投三分都跟 Curry 一樣有信心 (最近都在看 NBA 季後賽啦)。 經過一番奮戰後，我們終於在總共花了 4 週多的時間，將原本幾乎開不出 API 的系統，陸續釋出 20多支的 API 上線，並且交付批次工具幫助協作單位整合資料，解決了之前常常需要手動進資料庫塞資料與髒資料橫行的問題，也終於終於得到了團隊成員的第一次肯定（淚）。 但人生往往不會這麼簡單，你懂的 … 待續 …","categories":[{"name":"工程師的那些事","slug":"工程師的那些事","permalink":"https://toyo0103.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"}],"tags":[{"name":"工程師的那些事","slug":"工程師的那些事","permalink":"https://toyo0103.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"淺談 CQRS","slug":"intro_cqrs","date":"2021-08-15T15:37:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2021/08/15/intro_cqrs/","link":"","permalink":"https://toyo0103.github.io/2021/08/15/intro_cqrs/","excerpt":"","text":"前言之前專案就使用過 CQRS 做為系統的架構來開發，但一直覺得自己『知其然，而不知其所以然』，剛好最近出了一本CQRS 命令查詢職責分離模式 所以就買回來把他讀完了，趁記憶還很清晰時趕快做一下筆記，以下的內容參雜了許多自己的見解，歡迎大家一起討論 什麼是 CQRSCQRS 全名為 Command Query Responsibility Segregation ，意即命令與查詢分離的設計模式，而 Command : 會對系統狀態或資料做出異動的行為 Query : 單純取得資料不會對系統狀態造成異動的行為 以傳統 CRUD 類比的話，CUD = Command，R = Query 為什麼需要 CQRS降低複雜度我自己接觸過的大部分系統，大多都是以維護資料做為出發點來設計的系統，例如專案內一定會有所謂的 Repository Layer\b ： 一個提供各種 API 並能對資料做 CRUD 的封裝層。系統本來就是一系列對資料維護的過程，這樣做有錯嗎？ 只要商業情境不要太複雜的話，大部分都沒什麼問題，但如果系統規模越做越大，商業情境越來越複雜，如果只是用 CRUD 的思維來設計系統，往往會讓複雜度越疊越高，甚至到不可收拾的地步。舉個例子，你應該看過這樣的 API 1234567891011121314151617181920212223public void Update(MemberDto member)&#123; var memberEntity = MemberRepository.Get(member.Id); if(memberEntity == null) throw new NullReferenceException(&quot;Member not found.&quot;); if(string.IsNullOrEmpty(member.Name)) throw new ArgumentNullException(nameof(member.Name)); if(DateTime.TryParse(member.Birthday, out var birthday) == false) throw new ArgumentException(nameof(member.Birthday)); //bla bla bla .... if(string.IsNullOrEmpty(member.Password)) throw new ArgumentNullException(nameof(member.Password)); // Set Entity ... memberEntity.Password = member.Password; MemberRepository.Update(memberEntity);&#125; 這個 API 可能包含了對 Member 資料的各種邏輯驗證，而呼叫這個 API 的你可能只是為了完成密碼變更而已，這份 Code 硬要說沒什麼大問題，但也體現了從 CRUD 角度設計出的 API 可能隨著商業邏輯的日益複雜，複雜度可能會成長到非常可怕的地步，而這也是 CQRS 中想避免的事情。 Command 會這樣做1234567891011public void Handle(ResetPasswordCommand command)&#123; var member = MemberRepository.Get(command.Id); if(memberEntity == null) throw new NullReferenceException(&quot;Member not found.&quot;); //領域模型知道 ResetPassowrd 的相關驗證與知識 member.ResetPassword(command.Password); MemberRepository.Update(member);&#125; 1. 貼近現實世界的用語PO 會對我們說需要會員註冊的功能，而不會說需要新增會員的功能，而通常更換密碼與忘記密碼會是完全不一樣的流程，用 UpdatePassword 很難精準說明這裡面做了什麼，你可能需要翻程式碼看流程，才能說出這個方法內包含了哪些商業情境，而這正是 Command 想避免的。 2. 貼近商業邏輯一個 Command 只做一件事情，而 Command 所執行的流程跟邏輯應符合真實流程與情境 3. Command 內盡量不要再串其他 CommandCommand 通常會對應觸發系統 Event，當 Command 串 Command 時，後續的連鎖反應容易失控，盡量讓 Command 就是獨立完成一個商業邏輯。\b 也許看到這邊會覺得這好像有點 DDD 的影子，定義領域模型並封裝領域知識，外部透過 Command 觸發領域模型做事，就我目前的認識，的確 DDD 通常會採用 CQRS 的設計模式來實作，但 CQRS 卻不一定要實作 DDD，不過 DDD 我還是初學者就不獻醜了。 提升效能系統都希望提供各種角度的搜尋來滿足分析與功能需求，而這會加重資料庫的運算資源短缺問題，通常下一步就會開始將資料庫做讀寫分離的拆解，但最終逃離不了 Table Schema 需要同一套的束縛，而這個束縛在運算或是資料到達某個量級時就很難再往上提升了。 搜尋、寫入最佳化是個兩難的問題，搜尋要快通常要對 Index 設計下一些功夫，而偏偏 Index 越多寫入越慢，又或是 Table Schema 適度的反正規化對搜尋較為友善，但偏偏這會讓寫入資料維護時變得異常麻煩；反過來看，寫入要快需要盡量只寫入該寫入或該更新的資料，而正規化反而是有利於寫入的情境。當讀寫都對同一個 DB 或是同一張 Table 時這兩邊的平衡往往會讓 RD 抓狂，而 CQRS 正是能解決的問題的很好解決方案。CQRS 允許 Command 與 Query 可以是 Table 等級的隔離也可以是資料庫的實體隔離，更提供針對 Command 與 Query 各自選用最佳方案的資料庫，例如：Command 選用 RDB 而 Query 選擇 NoSQL 甚至是 Elasticsearch 這種重量級搜尋服務來滿足，兩邊資料則透過 Event Sync 的方式來同步。通常系統寫入與查詢的量也是不成比例的，一般系統大部分都在應付各種查詢，而寫入可能只有讀取不到 10 分之 1 的量，CQRS 是有辦法單獨對 Query DB 做橫向擴充，而這在傳統系統架構上是很難做到的一點。 既然這麼好，我是否該每個系統都這樣設計有優點就有缺點，而 CQRS 的缺點是對於開發的難度提升了不止一個檔次，等等！上面不是說為了簡化才選擇 CQRS，這邊又說開發變困難，筆者態度前後不一啦（怒噴兩萬字） 先冷靜聽我說，CQRS 是想讓你的程式碼符合商業情境，並盡量符合 Single responsibility principle，這是 Code Level 的簡化，但架構卻變得更為複雜，第一你得面對兩邊資料庫的選擇問題，就算退一步說，我系統量不大，選擇同一座資料庫切 Table 可以吧，但 Command 與 Query 就是會有同步時間差，資料只能做到最終一致性，而你準備好面對這樣的改變了嗎？你應該不會想要採用 CQRS ，但抄寫兩張 Table 卻用同步的作法，這樣用單張 Table 採用 CRUD 的方式還更快一些。 當你的開始對 Command / Query 各自選用最佳的資料庫解決方案時，Event Sync 抄寫資料的實作想好解決方案了嗎？中間是透過 Queue 實作 Pub / Sub 同步嗎？ 資料同步延遲的 SLO 定好了嗎？ Consumer 同步速度跟不上寫入發過來的 Event 時，橫向擴充的機制是否想好了？ 當開始要面對最終一致性時，不單單只是系統層面的調整，有時甚至從需求到 RD 觀念都是需要做些改變，現實世界最終一致性例子比比皆是，但在過去的大單體時代強一致性才是顯學，如今系統需要乘載的量體已經不可同日而語，除非有革命性的物理突破，不然我們都要開始習慣這個改變 延伸閱讀Starbucks Does Not Use Two-Phase Commit 講這麼多，那到底怎樣才需要用到 CQRS 實作系統？ 我的建議是如果這個系統流量或資料量預期成長不大，或需求不太會隨著商業情境一直改變的，例如後台系統，這種真的套個 Template 用 CRUD 簡單搞定就好，引入 CQRS 只會增加複雜度且不會有多大效益的，反之如果這個系統預期未來會持續成長，商業需求也會一直調整，那我會建議可以考慮引入 CQRS，但在前期可以選擇單一資料庫切 Table 的方式就好，等到真的量開始起來時再開始 Migration 都還來得及。","categories":[],"tags":[{"name":"CQRS","slug":"CQRS","permalink":"https://toyo0103.github.io/tags/CQRS/"}]},{"title":"擷取封包練習","slug":"packet_capture","date":"2021-04-29T05:45:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2021/04/29/packet_capture/","link":"","permalink":"https://toyo0103.github.io/2021/04/29/packet_capture/","excerpt":"","text":"最近接到一個任務，需要協助團隊重現幾個 DB 連線時的錯誤，例如: connection pool 超過上限爆掉、connection timeout 等等，而其中一個錯誤 Pre-Login handshack 最難重現 12System.Data.SqlClient.SqlException (0x80131904): Connection Timeout Expired. The timeout period elapsed while attempting to consume the pre-login handshake acknowledgement. This could be because the pre-login handshake failed or the server was unable to respond back in time. The duration spent while attempting to connect to this server was - [Pre-Login] initialization=2846; handshake=6765; 這個錯誤推測是在與 SQL Server 連線時 three-way handshake 沒有收到回應導致的失敗，可能屬於網路不穩掉封包問題導致，但問題怎麼證明? Wireshark首先得先確認與 SQL Server 連線時到底傳了哪些封包出去，可以透過 wireshark 側錄封包的功能來達成 1. 設定 Capture1dst host xxx.xxx.xxx.xxx &amp;&amp; port 1433 2. 嘗試對 SQL 做一次連線並觀察封包可以發現 Pre-login handshake 應該會有三次封包傳輸 Packet Loss接著得想辦法重現封包丟失的狀況下，是否會引發相同的 Exception，因為不知道怎麼精準的特定封包攔下來 (如果有人會的話也歡迎留言教學一下)，所以這邊透過 Clumsy 這個套件來輔助達成 1. 指定目的地的封包多少比例被攔截下來1outbound and ip.DstAddr = xxx.xxx.xxx.xxx 2. 增加連線 handshake 的機率因為無法精準攔截封包，所以採取短時間快速重複連線來增加封包被攔截的碰撞機率，所以我將 Connection Pool 關閉，並且開多執行序只做最簡單的連線與關閉連線，果然很快就碰到 handshake 的封包被攔掉的狀況 而最後也證實了只要連線時網路不穩定導致掉封包等狀況時，底層是會引發上述錯誤的狀況","categories":[],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"https://toyo0103.github.io/tags/wireshark/"},{"name":"clumsy","slug":"clumsy","permalink":"https://toyo0103.github.io/tags/clumsy/"}]},{"title":"dotnet core 3 container 無法連線 MSSQL 2016","slug":"dotnet_core_3_container_ms_sql_2016","date":"2020-12-01T14:22:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2020/12/01/dotnet_core_3_container_ms_sql_2016/","link":"","permalink":"https://toyo0103.github.io/2020/12/01/dotnet_core_3_container_ms_sql_2016/","excerpt":"","text":"情境最近踩到 dotnet core 3 contaienr + ms sql 2016 的問題，問題的現象是，程式只要跑到建 sql connection 那行就會 hang 在那邊，沒有 timeout 也沒有 Exception … 追查之下後發現，原來 MS SQL 2016 如果沒有調整更新，預設 TLS 好像只支援 1.0、1.1 (待確認)，而我用的 base image : mcr.microsoft.com/dotnet/core/runtime:3.1 的 TLS 設定要求最低版本是 1.2，這也就引發了上述的狀況 1234# cat /etc/ssl/openssl.cnf [system_default_sect]MinProtocol = TLSv1.2CipherString = DEFAULT@SECLEVEL=2 解法一般來說，基於安全性會建議至少停用 TLS 1.0 並支援 1.2 才是比較好的做法，但如果你跟我一樣只是在測試，那可以採用以下比較 workaround 的做法，在 dockerfile 加上以下幾行來調整 container tls 最低支援版本 1234RUN sed -i &#x27;s/DEFAULT@SECLEVEL=2/DEFAULT@SECLEVEL=1/g&#x27; /etc/ssl/openssl.cnfRUN sed -i &#x27;s/MinProtocol = TLSv1.2/MinProtocol = TLSv1/g&#x27; /etc/ssl/openssl.cnfRUN sed -i &#x27;s/DEFAULT@SECLEVEL=2/DEFAULT@SECLEVEL=1/g&#x27; /usr/lib/ssl/openssl.cnfRUN sed -i &#x27;s/MinProtocol = TLSv1.2/MinProtocol = TLSv1/g&#x27; /usr/lib/ssl/openssl.cnf 這樣重新啟動也就會正常了 參考文章.NET Core 3.0 Docker Container Won’t Connect to SQL Server","categories":[],"tags":[{"name":"dotnet core","slug":"dotnet-core","permalink":"https://toyo0103.github.io/tags/dotnet-core/"},{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"}]},{"title":"【C#】 關於 Async 的三兩事","slug":"about_async","date":"2020-09-19T09:07:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2020/09/19/about_async/","link":"","permalink":"https://toyo0103.github.io/2020/09/19/about_async/","excerpt":"","text":"說來真的好久沒有寫文章了，除了工作很忙之外，目前碰到的問題也通常不是一兩篇文章可以交代的清，所以也就更新部落格的時間也就間隔越來越長了。 這次主要是想把最近針對 Async 的一些測試研究記錄下來，那我們就開始吧 ！ # Async 是什麼？Async 在 C# 語言中用來支援非同步處理的一種語法，而它的使用往往搭配 Await 一起使用，先來看看一段簡單的程式碼 123456789101112131415161718192021222324252627class Program&#123; static async Task Main(string[] args) &#123; Console.WriteLine($&quot;1. Hi I&#x27;m Async Demo&quot;); //拿到非同步的任務 var task = DoAsync(); //繼續執行 Console.WriteLine($&quot;2. Hello World!&quot;); //等待非同步任務執行完成 await task; Console.WriteLine($&quot;4. End!&quot;); &#125; public static async Task DoAsync() &#123; //碰到 await 時，會將控制項回傳給呼叫端，並且等待非同步的方法執行完成 await Task.Run(()=&gt; &#123; Thread.Sleep(TimeSpan.FromSeconds(5)); Console.WriteLine($&quot;3. Async method Done&quot;); &#125;); &#125;&#125; 這段程式碼執行後可以看到以下結果 12341. Hi I&#39;m Async Demo2. Hello World!3. Async method Done4. End! 觀察執行緒的切換接著加上執行緒 Id 看看，讓我們更清楚執行緒之間是如何切換的 執行結果 1234[1] 1. Hi I&#39;m Async Demo[1] 2. Hello World![4] 3. Async method Done[4] 4. End! 執行流程 執行緒_1 在 11 行印出了 [1] 1. Hi I&#39;m Async Demo 執行緒_1 在 14 行進入了 DoAsync 的方法中 執行緒_1 在 27 行碰到 Task.Run 開啟了非同步執行的方法，並因為 await 跳出了這個 DoAsync() 執行緒_1 在 16 行碰到印出了 [1] 2. Hello World! 執行緒_1 在 19 行碰到 await task ，開始等待 task 執行完成，執行緒_1 釋放回到 Thread Pool 執行緒_4 在非同步方法的第 30 行 印出了 [4] 3. Async method Done ，並通知 await task 執行完成 TaskScheduler（通常，這會是以執行緒集區為目標的預設工作排程器）依據最有效率的判斷，讓 執行緒_4 往下執行未完的部分 執行緒_4 接手繼續將 await 之後還沒做完的工作執行完成，意即 21 行，印出 [4] 4. End! 稍微修改一下程式…123456789101112131415161718192021222324class Program&#123; static async Task Main(string[] args) &#123; Console.WriteLine($&quot;[&#123;Thread.CurrentThread.ManagedThreadId&#125;] 1. Hi I&#x27;m Async Demo&quot;); //強制將非同步方法改成同步 DoAsync().Wait(); Console.WriteLine($&quot;[&#123;Thread.CurrentThread.ManagedThreadId&#125;] 2. Hello World!&quot;); Console.WriteLine($&quot;[&#123;Thread.CurrentThread.ManagedThreadId&#125;] 4. End!&quot;); &#125; public static async Task DoAsync() &#123; //碰到 await 時，會將控制項回傳給呼叫端，並且等待非同步的方法執行完成 await Task.Run(()=&gt; &#123; Thread.Sleep(TimeSpan.FromSeconds(5)); Console.WriteLine($&quot;[&#123;Thread.CurrentThread.ManagedThreadId&#125;] 3. Async method Done&quot;); &#125;); &#125;&#125; 執行結果 1234[1] 1. Hi I&#39;m Async Demo[4] 3. Async method Done[1] 2. Hello World![1] 4. End! 這邊可以看到 執行緒_1 在執行到 await Task.Run(()=&gt; …) 時跳出，但因為我們下了 Wait()，所以強迫 執行緒_1 進行同步的等待。 執行緒_4 印完 [4] 3. Async method Done 後，通知 執行緒_1 繼續往下進行，所以看到 執行緒_1 接著將剩下的程式跑完 差別在哪？當呼叫非同步執行方法時，如果一路都是用 await 並不會造成任何執行緒被封鎖，換言之該執行緒還可以在別的地方繼續服務，一旦呼叫了 Result 或 Wait() 這類的強制同步方法，則該執行緒會被封鎖，並等待到非同步方法執行完成後才繼續完成尚未完成的後續工作，這會嚴重消耗執行緒的使用效率。 我曾經對一個 Web API 專案進行壓測，在資源給得非常有限的情境下 (約 0.5 core cpu)，await 搭配 Task.Run() 跟 Result 搭配 Task.Run ，兩個 RPS 測起來差了快一倍之多，在資源極度有限下，執行緒的使用效率將大大影響整體服務的效率。 # SynchronizationContextSynchronizationContext 是用來記錄當前執行緒環境的類別，在 ASP.NET、WPF、WinForm 都有類似的類別只是名字可能有些差異，其最主要的目的都是在非同步方法中要能調用 UI 執行緒來更新介面之類的操作，而 SynchronizationContext 就紀錄著 UI 執行緒。 Deadlock過去寫 ASP.NET 的時候曾經踩過一次 SynchronizationContext 的雷，在 ASP.NET 中如果如果呼叫 SynchronizationContext.Currnt 會發現並不為 Null，且型別是 AspNetSynchronizationContext ，當我們用上述的 Result / Wait() 搭配 await 將會導致 Deadlock。 原因是程式碰到 await 時會先判斷 SynchronizationContext.Currnt 是否為 Null，如果是則會在 Task 結束時呼叫 TaskScheduler （通常為 Thread Pool）來安排後續工作。反之，如果 SynchronizationContext.Currnt 不為 Null 時，就會透過 SynchronizationContext.Currnt 來繼續後續的動作。 123456//碰到 await 時，記住了 SynchronizationContext.Currntawait Task.Run(()=&gt; &#123; Thread.Sleep(TimeSpan.FromSeconds(5)); Console.WriteLine($&quot;[&#123;Thread.CurrentThread.ManagedThreadId&#125;] 3. Async method Done&quot;); &#125;); 而 .Result / Wait() 的方法會封鎖住 SynchronizationContext.Currnt，造成兩邊互等的情況發生，產生了 Deadlock 1DoAsync().Wait(); //封鎖 SynchronizationContext.Currnt 的物件等待 Task 完成 而這只會發生在 SynchronizationContext.Currnt 不為 Null 的系統中，像是前述提到的 ASP.NET、WPF、WinForm，在 Console Application 並不會發生。 解決方法 ConfigureAwait(false)如果要避免上述所提到的 Deadlock ，可以在呼叫非同步方法時加上 ConfigureAwait(false)，這樣非同工作完成時就會透過另一條執行緒繼續完成後續工作 1234await Task.Run(()=&gt; &#123; .... &#125;).ConfigureAwait(false); 在 ASP.Net Core 的時代…在 ASP.Net core 呼叫 SynchronizationContext.Current 現在只會得到 Null ，換言之剛剛發生 deadlock 的情境已經不會發生，所以過往在非同步的地方常常要用 ConfigureAwait(false) 可以不用寫了，不過如果你是寫元件或 SDK 類的，並無法預測會被使用在怎樣的環境的話，建議還是都加上會比較保險。 # Best Practice在使用 Async / await 等非同步技巧時，最好的方式還是都盡量使用非阻斷式的寫法 await ，避免使用 Result / Wait() ，即使你已經是寫 ASP.Net core 不會發生 Deadlock 的情況，阻斷式的寫法對於執行緒的使用效率來說還是會有影響的。 參考文章使用以工作為基礎的非同步模式ASP.NET Core SynchronizationContextConfigureAwait FAQ.NET 程式鎖死與 SynchronizationContext搞懂 SynchronizationContext（第一部分)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Async","slug":"Async","permalink":"https://toyo0103.github.io/tags/Async/"}]},{"title":"initialize RabbitMQ container's Queue and Exchange","slug":"rabbitmq_container_initial_queue","date":"2020-06-06T15:48:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2020/06/06/rabbitmq_container_initial_queue/","link":"","permalink":"https://toyo0103.github.io/2020/06/06/rabbitmq_container_initial_queue/","excerpt":"","text":"為了測試方便常常會在本機起 RabbitMQ Container，但隨著系統的演進初始化 RabbitMQ 變得越來越複雜，例如：每次都要先設定 8 組 Queue，Exchange binding …等等 工程師的美德就是懶，所以開始找辦法是不是可以讓 RabbitMQ Container 起來時就自己設定好呢？ 解法RabbitMQ 有提供設定檔來初始化，分別為放在 12&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.config&#x2F;etc&#x2F;rabbitmq&#x2F;definitions.json 而這兩個檔案裡面可以設定 VirtualHost、Authorization、Exchange、Queue rabbitmq.config這邊特別提醒一下，內容最後面那個小點不是打錯喔，是規定就是要有的! 1234567891011121314[ &#123; rabbit, [ &#123; loopback_users, [] &#125; ] &#125;, &#123; rabbitmq_management, [ &#123; load_definitions, &quot;&#x2F;etc&#x2F;rabbitmq&#x2F;definitions.json&quot; &#125; ] &#125;]. definitions.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; &quot;rabbit_version&quot;: &quot;3.8&quot;, &quot;users&quot;: [ &#123; &quot;name&quot;: &quot;guest&quot;, &quot;password&quot;: &quot;guest&quot;, &quot;tags&quot;: &quot;administrator&quot; &#125; ], &quot;vhosts&quot;: [ &#123; &quot;name&quot;: &quot;&#x2F;&quot; &#125; ], &quot;permissions&quot;: [ &#123; &quot;user&quot;: &quot;guest&quot;, &quot;vhost&quot;: &quot;&#x2F;&quot;, &quot;configure&quot;: &quot;.*&quot;, &quot;write&quot;: &quot;.*&quot;, &quot;read&quot;: &quot;.*&quot; &#125; ], &quot;parameters&quot;: [], &quot;policies&quot;: [], &quot;exchanges&quot;: [ &#123; &quot;name&quot;: &quot;nmq&quot;, &quot;vhost&quot;: &quot;&#x2F;&quot;, &quot;type&quot;: &quot;direct&quot;, &quot;durable&quot;: true, &quot;auto_delete&quot;: false, &quot;internal&quot;: false, &quot;arguments&quot;: &#123;&#125; &#125; ], &quot;queues&quot;: [ &#123; &quot;name&quot;: &quot;command&quot;, &quot;vhost&quot;: &quot;&#x2F;&quot;, &quot;durable&quot;: true, &quot;auto_delete&quot;: false, &quot;arguments&quot;: &#123;&#125; &#125; ], &quot;bindings&quot;: [ &#123; &quot;source&quot;: &quot;nmq&quot;, &quot;vhost&quot;: &quot;&#x2F;&quot;, &quot;destination&quot;: &quot;command&quot;, &quot;destination_type&quot;: &quot;queue&quot;, &quot;routing_key&quot;: &quot;command&quot;, &quot;arguments&quot;: &#123;&#125; &#125; ]&#125; 方案一在啟動 rabbitmq container 的時候將這兩個檔案透過 volume 的方式丟進去，這樣就可以達成目的了 123$ docker run -it \\ -v /etc/so/rabbitmq.config:/etc/rabbitmq/rabbitmq.config:ro \\ -v /etc/so/definitions.json:/etc/rabbitmq/definitions.json:ro rabbitmq:3.8-management 方案二如過你不幸 (?) 的跟我一樣是使用 windows container，volume 這個選擇不屬於你，因為 windows container 只能將整個資料夾 volume 進去，並不能指定單一檔案，所以如果將整個資料夾放進去，需要額外將一些本該在 /etc/rabbitmq 底下的檔案也都 copy 出來，才不會跑起來的時候少東少西的，但這個方法總覺得有點麻煩，所以我採用自己 build image 的方案 dockerfile 1234FROM rabbitmq:3.8-managementADD rabbitmq.config /etc/rabbitmq/ADD definitions.json /etc/rabbitmq/ 透過 build image 的過程中將檔案放進去，之後起起來也都不用在下 volume 指令，也算是簡單不少 How to add initial users when starting a RabbitMQ Docker container?Creating a custom RabbitMQ container with preconfigured queues","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://toyo0103.github.io/tags/RabbitMQ/"}]},{"title":"hnsCall failed in Win32 The object already exists","slug":"windows_docker_hnscall_error","date":"2020-02-26T02:28:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2020/02/26/windows_docker_hnscall_error/","link":"","permalink":"https://toyo0103.github.io/2020/02/26/windows_docker_hnscall_error/","excerpt":"","text":"windows server 2019 重開機後，自建 container nat networks 會消失。來源 : Windows container network drivers 1NAT networks created on Windows Server 2019 (or above) are no longer persisted after reboot. 所以我有寫一些重啟機器時檢查 network ，如果不存在就再建立一組並且啟動 docker，但時不時會碰到 Error response from daemon: hnsCall failed in Win32: The object already exists. (0x1392) 的錯誤。 但透過以下指令卻又都找不到已經存在的 network mapping 12$ docker network ls$ Get-NetNatStaticMapping 直接下指令砍掉要建立的 network 名稱，會回傳這物件不存在，但你要建立又會說這物件已經存在的鬼擋牆狀況… 這應該是 windows container bug ，之前只要碰到這個問題都直接重長機器，而剛剛終於找到解法了 (灑花) 解法12345678# 先停掉 docker service$Stop-Service docker# 停掉 hns $Stop-Service hns# 重啟 docker service, 這會連帶的 hns 也會被啟動$Start-Service docker 這時候再重新跑 docker network create 就會過了，這問題卡了我很長一段時間，終於找到解法了 Docker Network Create Fails: HNS failed with error : The object already exists. #1384","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"}]},{"title":"powershell筆記","slug":"powershell_note","date":"2020-02-25T16:03:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2020/02/26/powershell_note/","link":"","permalink":"https://toyo0103.github.io/2020/02/26/powershell_note/","excerpt":"","text":"(圖片出處: https://sploot.tw/2018/06/powershell-suite-windows-attack-tookit/) powershell 苦手如我，最近有越來越多的需求要從頭到尾自建 CI/CD 與自動化佈署流程，每次寫都要查一次覺得很煩(越老越金魚腦)，決定把常常用到的筆記方便查找 ENV12345678#列出所有的環境變數$gci env:* | Sort-Object name#resultName Value---- -----ALLUSERSPROFILE C:\\ProgramDataAPPDATA C:\\Users\\Steven Tsai\\AppData\\Roaming 123456#設定環境變數$env:test=&quot;123&quot;$env:test#result123 Variable1234$test=&quot;123&quot;$test#result123 If … Else1234$test=&quot;123&quot;$if($test -eq &quot;123&quot;) &#123;echo &quot;yes&quot;&#125; else &#123;echo &quot;no&quot;&#125;#resultyes 123456#把判斷的結果存到變數中$test=&quot;123&quot;$result=if($test -eq &quot;123&quot;) &#123;echo &quot;yes&quot;&#125; else &#123;echo &quot;no&quot;&#125;$result#resultyes Split123456$test=&quot;a,b,c&quot;$test.Split(&quot;,&quot;)#resultabc 1234$test=&quot;a,b,c&quot;$test.Split(&quot;,&quot;)[0]#resulta Invoke-WebRequest12345#需要帳密上傳檔案$PASSWORD = ConvertTo-SecureString -String &quot;your_password&quot; -AsPlainText -Force$CREDENTIAL = New-Object -TypeName &quot;System.Management.Automation.PSCredential&quot; -ArgumentList &quot;your_account&quot;, $PASSWORD$Invoke-WebRequest -Method PUT -Uri https://server/file.zip -UseBasicParsing -Credential $CREDENTIAL -Infile &quot;.\\file.zip&quot; Remove-Item12#force強制刪除$Remove-Item .\\file.zip -Force New-Item12345678#建立 logs 資料夾$New-Item -ItemType directory -Path C:\\logs#result目錄: C:\\Mode LastWriteTime Length Name---- ------------- ------ ----d----- 2020/2/26 上午 12:28 test Copy-Item1$Copy-Item c:\\source_folder C:\\target_folder\\ -Recurse Out-File123#將文字寫成檔案$test=&quot;123&quot;$test | Out-File &quot;C:\\log.txt&quot; -Encoding utf8 -Force Write file without BOM12$test=&quot;123&quot;$[System.IO.File]::WriteAllLines(&quot;C:\\log.txt&quot;, $test) Start-Transcript通常腳本會在長機器的時候自動執行，這時候並不會有人工介入，如果發生錯誤就很需要事後追查 Log ，但一段腳本可能上百上千行，到底錯在哪很難找，這時候就可以透過以下方法把執行的過程跟 output 都儲存下來 123$Start-Transcript -Path &quot;c:\\logs.txt&quot; -Append$New-Item -Type Directory C:\\TestData2\\ -Force$Stop-Transcript 執行結束後打開 logs.txt 就可以看到以下輸出 1234567891011121314151617181920**********************Windows PowerShell 轉譯開始**********************已啟動轉譯，輸出檔為 c:\\logs.txtPS C:\\Users\\Steven Tsai&gt; New-Item -Type Directory C:\\TestData2\\ -Force 目錄: C:\\Mode LastWriteTime Length Name---- ------------- ------ ----d----- 2020&#x2F;2&#x2F;26 上午 12:40 TestData2PS C:\\Users\\Steven Tsai&gt; Stop-Transcript**********************Windows PowerShell 轉譯結束結束時間: 20200226004058********************** Set Global Enviroment這是用在自動化安裝一些套件，例如 : Git , consul 後需要設定全域的環境變數，才能讓之後的指令能夠認得 consul –version 這類指令。 如果手動安裝，就是去把環境變數中 Path 加上 consul.exe 的位置，以下範例是抓出 Path 本來的設定值，並在尾段補上新的路徑設定 12345$oldpath = (Get-ItemProperty -Path &#x27;Registry::HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Environment&#x27; -Name PATH).path$newpath = &quot;$&#123;oldpath&#125;;C:\\consul\\&quot;$Set-ItemProperty -Path &#x27;Registry::HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Environment&#x27; -Name PATH -Value $newPath Start-Service1$Start-Service your_service_name register task scheduler1234567891011#要執行的動作$action= (New-ScheduledTaskAction -Execute &quot;powershell.exe&quot; -Argument &quot;-ExecutionPolicy bypass C:\\start.ps1&quot;)#執行權限$ProvisionPrincipal = New-ScheduledTaskPrincipal -UserId &quot;NT AUTHORITY\\SYSTEM&quot; -RunLevel Highest -LogonType S4U#觸發的時機$ProvisionTrigger = New-ScheduledTaskTrigger -AtStartup#註冊 task Schedule $Register-ScheduledTask -TaskName &quot;StartConsul&quot; -TaskPath &quot;\\&quot; -Action $action -Trigger $ProvisionTrigger -Principal $ProvisionPrincipal Create User12345678910111213#設定 User 密碼$Secure_String_Pwd=ConvertTo-SecureString &quot;user_password&quot; -AsPlainText -Force#建立User$New-LocalUser &quot;teamuser&quot; -Password $Secure_String_Pwd -FullName &quot;Arch team user&quot; -Description &quot;for arch team&quot; -PasswordNeverExpires:$true#將此 User 加入 Administrators$Add-LocalGroupMember -Group &quot;Administrators&quot; -Member &quot;teamuser&quot;#建立一個全新的 Group$New-LocalGroup -Name &quot;docker-users&quot;#將此 User 加進去$Add-LocalGroupMember -Group &quot;docker-users&quot; -Member &quot;archteamuser&quot; Expand-Archive123$curl https://source_file.zip -o c:\\targe_file.zip$Expand-Archive c:\\targe_file.zip c:\\file -force","categories":[],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://toyo0103.github.io/tags/CI-CD/"},{"name":"powershell","slug":"powershell","permalink":"https://toyo0103.github.io/tags/powershell/"}]},{"title":"透過容器建置專案","slug":"docker_ci_build","date":"2020-02-17T15:06:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2020/02/17/docker_ci_build/","link":"","permalink":"https://toyo0103.github.io/2020/02/17/docker_ci_build/","excerpt":"","text":"(圖片出處 : http://ezvivi2.com/article/200483.asp) 有在處理 CI/CD 的人應該都碰到過維護建置環境的問題，舉例來說，當今天開發 C# 專案可能有 dotnet framework、dotnet core、有些人開發前端會需要 npm …等等，CI 機器就需要裝一堆為了建置佈署的軟體，如果開發人員變多，建置排隊久候，可能就會將環境升級為 Master、Slave 架構，但又面臨了多台 Slave 如何快速增長(通常只有上班時間才會同時這麼多人在建置，所以動態增長 CI 機器有其必要)，如何維護多台 Slave 環境，有時候遇到需要的套件版本打架的時候，處理起來真的是會抓狂。 透過容器來建置專案其實綜觀上述的問題可以發現，每個專案建置所需要的東西可能不盡相同，為了讓 CI 機器能夠滿足所有建置的條件往往會把環境搞得過於複雜，這時候容器就是一個非常好的選擇，它滿足了每次建置環境都是獨立、隔離的條件且方便佈署。 一旦使用容器來做為建置的媒介，需要長一台新的 CI 機器時，只要將機器開起來並安裝完 docker 就搞定了(甚至 AWS 都有做好的現成 AMI 連自己安裝都省了)，不再需要寫一狗票的腳本來安裝機器。 實例以下是我一個專案建置時的 dockerfile，沒幾行的 script 就快速講一下，因為我這個專案裡面同時有 dotnet framework 與 dotnet core ，所以找個微軟官方提供的 mcr.microsoft.com/dotnet/framework/sdk:4.8, 裡面已經安裝了下列套件。 Docker Hub 連結 123456.NET Framework RuntimeVisual Studio Build ToolsVisual Studio Test AgentNuGet CLI.NET Framework Targeting PacksASP.NET Web Targets 我用這個 base image 開了 workspace 資料夾並把 source code 複製進去後，接著就是大家熟悉的 nuget restore 、 dotnet build、 dotnet publish 在容器的環境內建置專案。 第二段是起另一個 base image windows servercore 2019，將剛剛建置好的 artifact 放到指定的資料夾，最後這一包會建置成 image 並推到公司的 Artifact management 上，其它人只要拉下這個 image 就可以執行了。 1234567891011121314151617181920FROM mcr.microsoft.com/dotnet/framework/sdk:4.8 AS build-envWORKDIR c:/workspaceCOPY . ./RUN nuget restore src\\nmqv3.slnRUN dotnet restore --configfile src\\.nuget\\NuGet.Config src\\my_project.slnrun dotnet build -c release src\\my_project.sln run dotnet publish -c Release -r win-x64 --self-contained true src\\Router\\Router.csprojFROM mcr.microsoft.com/windows/servercore:ltsc2019WORKDIR c:/workerCOPY --from=build-env c:/workspace/src/Worker/bin/release/ .WORKDIR c:/routerCOPY --from=build-env c:/workspace/src/Router/bin/Release/netcoreapp3.0/win-x64/publish/ . 從建置到最後要交付的 container image 一氣呵成，全部都濃縮在一份 dockerfile 裡面，這份 dockerfile 會跟著專案內，只要任何一台機器可以執行 docker container 就可以建置佈署這個專案，是不是方便許多 XD","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://toyo0103.github.io/tags/CI-CD/"}]},{"title":"AsyncLocal and ThreadLocal","slug":"aynclocal_threadlocal","date":"2020-01-22T06:00:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2020/01/22/aynclocal_threadlocal/","link":"","permalink":"https://toyo0103.github.io/2020/01/22/aynclocal_threadlocal/","excerpt":"","text":"ThreadLocal1234567891011121314151617181920212223242526272829303132static ThreadLocal&lt;string&gt; LocalString = new ThreadLocal&lt;string&gt;();static async Task Main(string[] args)&#123; LocalString.Value = &quot;Value 1&quot;; Console.WriteLine($&quot;【A】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); var t1 = AsyncMethod(); Console.WriteLine($&quot;【D】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); await t1;&#125;static async Task AsyncMethod()&#123; Console.WriteLine($&quot;【B】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); LocalString.Value = &quot;Value 3&quot;; Console.WriteLine($&quot;【C】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); await Task.Delay(100); Console.WriteLine($&quot;【E】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;);&#125;//【A】 Thread: 14, ExcutionContext: 37151951 ,value: Value 1//【B】 Thread: 14, ExcutionContext: 51676517 ,value: Value 1//【C】 Thread: 14, ExcutionContext: 51676517 ,value: Value 3//【D】 Thread: 14, ExcutionContext: 37151951 ,value: Value 3//【E】 Thread: 16, ExcutionContext: 46128400 ,value: ThreadLocal 非常容易理解, 每個 Thread 之間彼此是隔離的, 即便 ExcutionContext 不同, 但只要是同一個 Thread 都會是共用的。 所以可以看到 await 之後, 因為不同 Thread 執行剩下的 Code , ThreadLocal 的值就變成預設的空值 AsyncLocal123456789101112131415161718192021222324252627282930313233static AsyncLocal&lt;string&gt; LocalString = new AsyncLocal&lt;string&gt;();static async Task Main(string[] args)&#123; LocalString.Value = &quot;Value 1&quot;; Console.WriteLine($&quot;【A】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); var t1 = AsyncMethod(); Console.WriteLine($&quot;【D】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); await t1;&#125;static async Task AsyncMethod()&#123; Console.WriteLine($&quot;【B】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); LocalString.Value = &quot;Value 3&quot;; Console.WriteLine($&quot;【C】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;); await Task.Delay(100); Console.WriteLine($&quot;【E】 Thread: &#123;Thread.CurrentThread.ManagedThreadId&#125;, ExcutionContext: &#123;Thread.CurrentThread.ExecutionContext.GetHashCode()&#125; ,value: &#123;LocalString.Value&#125;&quot;);&#125;//【A】 Thread: 14, ExcutionContext: 5705933 ,value: Value 1//【B】 Thread: 14, ExcutionContext: 12517624 ,value: Value 1//【C】 Thread: 14, ExcutionContext: 12517624 ,value: Value 3//【D】 Thread: 14, ExcutionContext: 5705933 ,value: Value 1//【E】 Thread: 8, ExcutionContext: 35765882 ,value: Value 3 AsyncLocal 會在每次需要切出 ExcutionContext 時複製一份給新的 ExcutionContext , 所以每個 ExcutionContext間的 AsyncLocal 都是獨立的，但同時可達跨 Thread , ExcutionContext 往下傳遞的特性。 參考文章AsyncLocal的运作机制和陷阱【.NET深呼吸】基於異步上下文的本地變量（AsyncLocal）ExecutionContext 類別","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"Service Discovery","slug":"service_discovery","date":"2019-11-09T04:32:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2019/11/09/service_discovery/","link":"","permalink":"https://toyo0103.github.io/2019/11/09/service_discovery/","excerpt":"","text":"( https://www.codeprimers.com/service-discovery-in-microservice-architecture/ ) 前言傳統上一組服務通常都會搭配 DNS + Load balance + serivce cluster, 服務要呼叫時也都是直接打 Domain 讓 Load balance 去導流。 不過這也面臨了管理 Domain 與服務間的複雜度, 例如服務要加一台新的機器需要去設定 Load balance 才有辦法服務(當然也是可以搭配一些 cloud autoscaling 機制來簡化流程); Client 在呼叫 Service 時通常需要真的打打看才有辦法知道服務是否還正常, 無法事先知道服務狀態再決定是否要呼叫。 近年微服務與容器化運用的盛行, 上述方式就顯得有點卡卡的，如果你的服務在 k8s 內那可能還好, 大部分它都幫忙處理掉了, 但如果像我們公司一樣, 很多服務雖然容器化但還無法進到 k8s 內, container 可以在短時間內 scale 成數倍來因應大流量, 但卡在這些服務需要去 load balance 註冊才有辦法讓流量導進來, 那顯然就有點做半套的感覺， Service Discovery 的應用就成為了重要的課題 什麼是 Service Discovery翻譯成中文就是服務發現(廢話…)，顧名思義就是呼叫端在需要時先透過搜尋來找到對應的服務，而要達成這點需要一些配合才能達成。 首先第一步, 當某個服務起來時應該主動向提供 service discovery 註冊自己是什麼服務? 位置在哪? 是否已經可以開始服務了? 註冊時會搭配著 Health check 的機制, 告訴 service discovery 如何檢核這個節點是否健康的 Client 在要叫用 service 時, 先透過 service name 詢問有哪些節點可用, 而 service discovery 也能準確地回應有哪些目前還是健康的節點可供呼叫 當節點損壞時, 以 container 的案例, 會直接換掉不健康的 container 重長一組, 而這又會回到圖一註冊的流程。 更細緻一點的作法還有對 service discovery 回應的列表做快取，例如快取 1 秒，當服務自己要被收掉時, 做好 graceful shutdown 先把自己從服務列表中 deregister , 並且等待 3 秒後才關機，避免快取到的 Client 打來你剛好停止服務。 或是對服務加上 Tag ，當特定用戶或 VIP 連進來時可以透過搜尋特定機器去執行 面臨的問題但並不是所有事情都是如此美好, 公司目前導入這些機制雖然可以大幅簡化管理內部服務 domain 這類的問題, 但對於 load balance，即選取適合的節點這點上還有一些問題要克服，例如傳統 ELB 這類的服務都會依據每個節點的回應速度來判斷接下來導流的分配，但 service discovery 因為 request 並不會經過它，所以相關 latancy 也無從監控與觀察, 所以 load balance 這題必須額外拉出來做相對應的監控機制。 再來當服務橫跨 vm 跟 k8s 時情境就變得更複雜，不過這些題目等到之後有明確的方向再做整理好了，久違的文章雖然都沒寫到 code，但還是把一些觀念記錄下來。相關的實作等之後有空再補吧 (逃)","categories":[],"tags":[{"name":"microservice","slug":"microservice","permalink":"https://toyo0103.github.io/tags/microservice/"},{"name":"service discovery","slug":"service-discovery","permalink":"https://toyo0103.github.io/tags/service-discovery/"}]},{"title":"NATS Streaming 調查報告書","slug":"nats_streaming","date":"2019-08-19T15:00:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2019/08/19/nats_streaming/","link":"","permalink":"https://toyo0103.github.io/2019/08/19/nats_streaming/","excerpt":"","text":"最近因為任務關係對 NATS Streaming 做了一些研究跟 POC，這邊把一些研究到的NATS Streaming 特性記錄下來 什麼是 NATSNATS 是一種 Queue , 它效能比一般的 Queue 好上許多，號稱 Sender / Reciever 每秒可高達 20 萬筆 Message，這是非常驚人的數字。 （來源：https://bravenewgeek.com/dissecting-message-queues/） 可以看到 RabbitMQ 在它旁邊矮了一大截…. NATS 支援 Subscribe 模式，Subscriber 訂閱需要的 subject，當 NATS 收到 Message 時就會同時派發給所有訂閱者。 （來源：https://nats-io.github.io/docs/developer/concepts/pubsub.html） NATS 也支援 Queu Group，NATS 會對同一個 Queue Group 的所有 Subscriber 分配訂閱的 Message，而不會重複 （來源：https://nats-io.github.io/docs/developer/concepts/queue.html） 不過這些都不算太特別，畢竟 RabbitMQ 一樣能做到相同的功能，最特別的是 NATS Streaming 什麼是 NATS StreamingNATS Streaming 是附加在 NATS 之上的加值功能，他可以永久的保留所有的 Message，並且支援 Cursor（指標）功能，你可以任意的讓 Subscriber 回到特定的點 重播 所有的 Message。 這一點相當有用，試想一下，如果今天我們將所有交易的過程都透過 NATS Streaming 記錄下來，假設資料庫或記錄的地方損毀，我們只要重新 Replay 所有 Message，即能重建最後的結果。這也是 Event Sourcing 中最重要的的一環。 為了達成 Event Sourcing 這個設計模式的目標，演練了一些特定的情境 為了達成 HA 及加快處理速度的需求，需要多個 Subscriber 同時訂閱相同 Subject，並且彼此不會做到重複的 Message。 演練災難還原，Subscriber 必須能回朔到過去的的定時間點，重新 Replay 所有歷程 1. Queue Group其實第一項相對於容易，只要用 Queue Group 即可輕鬆達成，只要每個 Subscriber 給定同一組 Queue Group Name 即可。 1234567891011121314151617181920var options = StanOptions.GetDefaultOptions();var subOptions = StanSubscriptionOptions.GetDefaultOptions();subOptions.MaxInflight = 1; // MaxInflightvar cf = new StanConnectionFactory();var c = cf.CreateConnection(&quot;test-cluster&quot;, clientId, options);var s = c.Subscribe(&quot;foo&quot;, queueGroup, subOptions, (obj, args) =&gt; &#123; ...... &#125;);//等待接收關機訊號//關閉連線s.Close(); c.Close();c.Dispose(); 這邊需要特別注意 MaxInflight 這個參數，為了效率 NATS 預設會一次派給 Subscriber 1000 則Message（預設值有點忘記），好讓 Subscriber 不需要每做完一筆才透過網路要下一筆 Message，但這也讓我測出一個問題，當預收的訊息太多並且 Subscriber 根本來不及消化掉，這時候 NATS 會判定該則訊息 timeout，轉而派給同群別的Subscriber 來處理，這時候可能會發生兩個 Subscriber 執行到同一筆 Message 的狀況，所以請估算好 MaxInflight 的值，避免抓一堆做不完重派的狀況發生。 當最後一個 Subscriber 離線後，Queue Group 即會被刪除 2. Durable Name前面有提到 NATS Streaming 支援 Cursor 的功能，當 Subscriber 都離線時，如果有給它 Durable Name，他會記得上次你執行到哪一筆，當下次 Subscriber 重新連上時會從那個點繼續往下派發 12var subOptions = StanSubscriptionOptions.GetDefaultOptions();subOptions.DurableName = _appSetting.DURABLENAME; 3. StartAt接著來實作災難還原的步驟，首先如何讓特定的 Queue Group 退到特定的點，呈上，同時多個 Subscriber 與 Durable Name 都還是要能符合。 SDK 其實有提供 StartAt() 的 API 123// Receive messages starting at a specific sequence numbervar subOptions = StanSubscriptionOptions.GetDefaultOptions();subOptions.StartAt(22); 不過這邊需特別注意，同一個 Queue Group 只有在第一個 Subscriber 進來時（也就建立這個 Queue Group 的時候）StartAt 才會生效，之後進來的 Subscriber 帶這個值都會被直接忽略掉。 這邊問題就來了，當我們帶了 Queue Group ＋ Durable Name，即便所有的 Subscriber 都離線了，NATS 還是會貼心的幫你記錄最後執行到的地方，所以之後進來的 Subscriber 也都不可能是第一個了，換言之這樣的狀況是無法重新設定指標的。 所以如果要刪除 Queue Group ＋ Durable Name 的 Queue Group 唯一的方法只有讓所有的 Subscriber 退訂閱 12// 取消訂閱 刪除該Groups.Unsubscribe(); 這邊跟上面的範例程式不一樣，上面的是用 **Close()**，這樣並不會讓 Subscriber 退訂閱，只會是離線而已，唯有用 Unsubscribe() 將 Subscriber 全部退訂閱後，有 Durable Name 的 Queue Group 才會被刪除掉。 另外 NATS SDK 並沒有提供查詢 Queue Group 所有 Subscriber 的 Client ID，依據官方的說法，這份清單應該是使用者需要自己維護的，在上面這個案例上，就會需要將所有 Subscriber 用相同 Client ID 連上線後退訂閱。 4. ManualAcks用上述的方法成功刪除 Queue Group 後，下一步就是重新讓第一個 Subscriber 去建立 Queue Group 並指定 StartAt ，不過這邊有點麻煩的地方是，Subscriber 一連線後馬上就會開始拋 Message 過來，這時後如果你是希望災難還原與重新執行 Replay 分開做時就會很困擾。 預設 StanSubscriptionOptions 是收到 Message 後自動就幫你 Ack 回報 NATS 你收到了在處理了，NATS 也就會繼續往下把下一筆分配給別人，但我只是想指定位子不想要處理 Message 呢？ 這時候就要透過設定將 Ack 改成手動回報 123456789var subOptions = StanSubscriptionOptions.GetDefaultOptions();subOptions.ManualAcks = true;.......var s = c.Subscribe(&quot;foo&quot;, queueGroup, subOptions, (obj, args) =&gt; &#123; args.Message.Ack(); &#125;); 這樣只要不呼叫 **Ack()**，就等於不處理這筆 Message 了，當 Subscriber 離線或是 Message timeout，NATS 就會重新分派給其他 Subscriber 處理了，這樣也間接達到重建 Queue Group 與指定 Cursor 的目標。 參考文章NATS DocumentThe official NATS .NET C# Streaming Client","categories":[],"tags":[{"name":"microservice","slug":"microservice","permalink":"https://toyo0103.github.io/tags/microservice/"},{"name":"NATS","slug":"NATS","permalink":"https://toyo0103.github.io/tags/NATS/"}]},{"title":"ThreadPool","slug":"threadpool","date":"2019-08-01T11:14:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2019/08/01/threadpool/","link":"","permalink":"https://toyo0103.github.io/2019/08/01/threadpool/","excerpt":"","text":"GitHub SourceCode : 連結 自從加入精神時光屋團隊後，對於一些平行處理、多執行序等程式掌控力就越來越要求。為了不要當拖油瓶，這次練習的是 ThreadPoll，從這個練習可以更精準掌握 Thread 控制技巧。 目標建立 Thread 其實是需要成本的，所以頻繁的建立 Thread 砍掉 Thread 相當耗效能，另一方面，如果等到有 Task 才開始建立 Thread 可能會導致第一個 Task 回應速度過慢。例如 : IIS 底層就有 ThreadPool ，為了因應 Request 進來時能更快速的回應，但又不能為了一昧追求速度不管資源的有效運用，所以ThreadPool 應該有增長跟最低維持幾條的上下限。 依據上面描述定義以下目標 自製 ThreadPool 依據 Task 量決定 Thread 的數量，Task 過多會加開 Thread 處理，反之會減少 ThreadPool 可以設定 Thread 數量上下限 實作希望呼叫的方式如下 12345678910111213141516171819class Program&#123; static void Main(string[] args) &#123; // 建立自己的 ThreadPool ，設定 Thread 至少保持 3 條，上限不超過 10 條 MyThreadPool myTreadPool = new MyThreadPool(3,10); // 一值塞任務進去,不管任務執行完了沒 // 所以 ThreadPool 應該要能接住 Task 讓它們排隊消耗 for (int i = 0; i &lt; 200; i++) &#123; myTreadPool.Enqueue(i); &#125; Console.ReadKey(); // 等待執行結束 myTreadPool.WaitFinished(); &#125;&#125; MyThreadPool 1234567891011121314151617181920212223242526public class MyThreadPool&#123; private BlockingCollection&lt;int&gt; _jobQueue; private int _minThread; private int _maxThread; public MyThreadPool(int minThread,int maxThread) &#123; this._minThread = minThread; this._maxThread = maxThread; // 最多只能放 100 個 Task this._jobQueue = new BlockingCollection&lt;int&gt;(100); &#125; public void WaitFinished() &#123; throw new NotImplementedException(); &#125; public void Enqueue(int i) &#123; _jobQueue.TryAdd(i); &#125;&#125; 實作 ThreadPool 保有最少的 Thread 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyThreadPool&#123; private BlockingCollection&lt;int&gt; _jobQueue; private int _minThread; private int _maxThread; private int _currentThreadCount; private List&lt;Thread&gt; _threads; public MyThreadPool(int minThread,int maxThread) &#123; this._minThread = minThread; this._maxThread = maxThread; this._jobQueue = new BlockingCollection&lt;int&gt;(100); this._currentThreadCount = 0; this._threads = new List&lt;Thread&gt;(); for (int i = 0; i &lt; minThread; i++) &#123; this.CreateThread(); &#125; &#125; private void CreateThread() &#123; int id = Interlocked.Increment(ref _currentThreadCount); if (id &gt; _maxThread) &#123; // 可開的 Thread 到達極限, 無法加開 Interlocked.Decrement(ref _currentThreadCount); return; &#125; Thread thread = new Thread(ThreadBody); thread.Name = $&quot;Thread-&#123;id&#125;&quot;; thread.Start(); this._threads.Add(thread); Console.WriteLine($&quot;Thread count : &#123;this._currentThreadCount&#125;&quot;); &#125; private void ThreadBody() &#123; &#125;&#125; 實作 TheadBody 1234567891011121314151617181920212223private void ThreadBody()&#123; string name = Thread.CurrentThread.Name; Console.WriteLine(name + &quot; starts&quot;); // 如果有 Task 還沒有塞完就一直搶來處理 while (!this._jobQueue.IsCompleted) &#123; int task = 0; while(_jobQueue.TryTake(out task, 100)) &#123; // 模擬 Task 要執行的時間, 0.1 ~ 0.5秒不等 Random rnd = new Random(); int excuteTime = 0; excuteTime = rnd.Next(100, 500); Console.WriteLine($&quot;&#123;name&#125; do task_&#123;task&#125; spend &#123;excuteTime&#125; ms&quot;); Thread.Sleep(excuteTime); &#125; &#125; Console.WriteLine(name + &quot; are closed&quot;);&#125; 這邊會有一個問題, 如果塞 Task 的速度不定, 可能時快時慢, 如果中間間隔過長會導致 Thread 一直拿不到 Task 來工作卻又停不下來, 持續空轉 , 所以必須加一個機制讓它等待, 並在必要時刻喚醒 ManualResetEvent 123456789101112131415161718192021222324252627282930private ManualResetEvent _mre;public MyThreadPool(int minThread,int maxThread)&#123; ... this._mre = new ManualResetEvent(false); ...&#125;...private void ThreadBody()&#123; string name = Thread.CurrentThread.Name; Console.WriteLine(name + &quot; starts&quot;); // 如果有 Task 還沒有塞完就一直搶來處理 while (!this._jobQueue.IsCompleted) &#123; int task = 0; while(_jobQueue.TryTake(out task, 100)) &#123; Random rnd = new Random(); int excuteTime = 0; excuteTime = rnd.Next(100, 500); Console.WriteLine($&quot;&#123;name&#125; do task_&#123;task&#125; spend &#123;excuteTime&#125; ms&quot;); Thread.Sleep(excuteTime); &#125; _mre.WaitOne(); &#125;&#125; MSDN : ManualResetEvent Class ManualResetEvent 就像是個手動的紅綠燈, 可以將 Thread Block 在 WaitOne 這行, 直到呼叫 ManualResetEvent.Set()將燈號切成綠燈, 全部的 Thread 才會往下繼續執行。 與之相對的是 AutoResetEvent Class , 差別只在於 ManualResetEvent 呼叫 Set (綠燈), Reset (紅燈)。而 AutoResetEvent 呼叫 Set 每次只會隨機放一條 Thread , 不像 ManualRestEvent 是全部放 Enqueue 12345678910111213public void Enqueue(int i)&#123; // 表示容量滿了 while (_jobQueue.TryAdd(i) == false) &#123; // Queue Length 過長, 需加開 Thread this.CreateThread(); &#125; // 切成綠燈, 放掉所有 Thread 開始搶工作做 _mre.Set(); // 切成紅燈, 如果有 Tread 搶不到事情來做又會被 Block 在 _mre.WaitOne(); 那行 _mre.Reset();&#125; 實作動態伸縮 Thread 數量 1234567891011121314151617181920212223private void ThreadBody()&#123; ... while (!this._jobQueue.IsCompleted) &#123; if (_mre.WaitOne(5000) == false) &#123; // 進到這邊表示 Thread 並不是因為_mre.Set()被喚醒, 而是5秒 timeout // 嘗試回收 Thread if (Interlocked.Decrement(ref _currentThreadCount) &lt; _minThread) &#123; Interlocked.Increment(ref _currentThreadCount); &#125; else &#123; Console.WriteLine($&quot;Thread count : &#123;this._currentThreadCount&#125;&quot;); break; &#125; &#125; &#125; Console.WriteLine(name + &quot; are closed&quot;);&#125; WaitFinished 這個方法如果被呼叫時, 應該將所有 Thread 都喚醒, 並且等待每個 Thread 都執行完畢 12345678910111213public void WaitFinished()&#123; this._jobQueue.CompleteAdding(); _mre.Set(); foreach (var t in _threads) &#123; if (t != null) &#123; t.Join(); &#125; &#125;&#125; **完整版的 Code ** 12345678910111213141516171819class Program&#123; static void Main(string[] args) &#123; // 建立自己的 ThreadPool ，設定 Thread 至少保持 3 條，上限不超過 10 條 MyThreadPool myTreadPool = new MyThreadPool(3,10); // 一值塞任務進去,不管任務執行完了沒 // 所以 ThreadPool 應該要能接住 Task 讓它們排隊消耗 for (int i = 0; i &lt; 200; i++) &#123; myTreadPool.Enqueue(i); &#125; Console.ReadKey(); // 等待執行結束 myTreadPool.WaitFinished(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class MyThreadPool&#123; private BlockingCollection&lt;int&gt; _jobQueue; private int _minThread; private int _maxThread; private int _currentThreadCount; private ManualResetEvent _mre; private List&lt;Thread&gt; _threads; public MyThreadPool(int minThread,int maxThread) &#123; this._minThread = minThread; this._maxThread = maxThread; // 最多只能放 100 個 Task this._jobQueue = new BlockingCollection&lt;int&gt;(100); this._currentThreadCount = 0; this._mre = new ManualResetEvent(false); this._threads = new List&lt;Thread&gt;(); for (int i = 0; i &lt; minThread; i++) &#123; this.CreateThread(); &#125; &#125; private void CreateThread() &#123; int id = Interlocked.Increment(ref _currentThreadCount); if (id &gt; _maxThread) &#123; // 可開的 Thread 到達極限, 無法加開 Interlocked.Decrement(ref _currentThreadCount); return; &#125; Thread thread = new Thread(ThreadBody); thread.Name = $&quot;Thread-&#123;id&#125;&quot;; thread.Start(); this._threads.Add(thread); Console.WriteLine($&quot;Thread count : &#123;this._currentThreadCount&#125;&quot;); &#125; public void WaitFinished() &#123; this._jobQueue.CompleteAdding(); _mre.Set(); foreach (var t in _threads) &#123; if (t != null) &#123; t.Join(); &#125; &#125; &#125; public void Enqueue(int i) &#123; _mre.Set(); // 表示容量滿了 while (_jobQueue.TryAdd(i) == false) &#123; // Queue Length 過長, 需加開 Thread this.CreateThread(); &#125; _mre.Reset(); &#125; private void ThreadBody() &#123; string name = Thread.CurrentThread.Name; Console.WriteLine(name + &quot; starts&quot;); // 如果有 Task 還沒有塞完就一直搶來處理 while (!this._jobQueue.IsCompleted) &#123; int task = 0; while(_jobQueue.TryTake(out task, 100)) &#123; Random rnd = new Random(); int excuteTime = 0; excuteTime = rnd.Next(100, 500); Console.WriteLine($&quot;&#123;name&#125; do task_&#123;task&#125; spend &#123;excuteTime&#125; ms&quot;); Thread.Sleep(excuteTime); &#125; if (_mre.WaitOne(5000) == false) &#123; // 此條 Thread 5秒都沒有工作, 嘗試收掉 if (Interlocked.Decrement(ref _currentThreadCount) &lt; _minThread) &#123; Interlocked.Increment(ref _currentThreadCount); &#125; else &#123; Console.WriteLine($&quot;Thread count : &#123;this._currentThreadCount&#125;&quot;); break; &#125; &#125; &#125; Console.WriteLine(name + &quot; are closed&quot;); &#125;&#125; 執行結果執行中應該可以看到 Task 消化不夠快而加開 Thread 最後因為程式在等待 ReadKey(), 如果超過 5 秒不按會看到 Thread 收掉的訊息 按下任意鍵,就會全部收掉並關閉程式","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"},{"name":"精神時光屋","slug":"精神時光屋","permalink":"https://toyo0103.github.io/tags/%E7%B2%BE%E7%A5%9E%E6%99%82%E5%85%89%E5%B1%8B/"}]},{"title":"【.Net Core】dotnet tool","slug":"dotnet_tool","date":"2019-05-30T08:37:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2019/05/30/dotnet_tool/","link":"","permalink":"https://toyo0103.github.io/2019/05/30/dotnet_tool/","excerpt":"","text":"情境 最近在公司開發一支稱為 Linter 的小程式，負責檢查 Bitbucket PR 的異動內容，看看是否有符合公司規範 ，例如 : 加了 Config 後是否有確實在對應環境補上相關設定，盡量避免這種編譯檢查不出來但上線才壞掉的情況。 原本預想的架構圖如上圖，使用者發了 PR ，透過 Webhook 觸發 Jenkins Master ，由 Master 安排一台機器去執行檢查。 但面臨一個問題是，當 Linter 這支程式要更版時變得很麻煩，因為每台 Jenkins 都必須要更新這支程式，原本也有想說不如把 Linter 獨立一台機器寫成類似像 API 的服務好了，但未來勢必面臨太多 PR 導致瓶頸，之後在導入 ELB 加多台機器 …. 想著想著就覺得太麻煩了。 之後同事建議可以包成 dotnet tool 的工具，Linter 要更新時只是發佈新版 Nuget ，而不是去佈署每台 Jenkins Slave，而 Jenkins Slave 每次要執行檢查 PR 時，先檢查自己套件是否為最新版的再往下執行。 整個流程瞬間變得簡單乾淨許多，所以就動手開始將這套程式包成 dotnet tool 製作 dotnet tool首先將要包成 dotnet tool 的專案檔 csproj 加上 PackAsTool 設定 123456789&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp2.1&lt;/TargetFramework&gt; &lt;AssemblyName&gt;Linter&lt;/AssemblyName&gt; &lt;RootNamespace&gt;Linter&lt;/RootNamespace&gt; &lt;PackAsTool&gt;true&lt;/PackAsTool&gt; &lt;Version&gt;1.0.1&lt;/Version&gt; &lt;/PropertyGroup&gt; 將執行檔打包成 nupkg 1$ dotnet pack -c release -o nupkg -p:PackageVersion=1.0.0 src\\Linter.csproj 推上 Nuget Server 1$ nuget.exe push src\\nupkg\\Linter.1.0.0.nupkg &lt;Nuget Key&gt; -source &lt;Nuget Server&gt; 執行 dotnet toolInstall 1$ dotnet tool install --add-source &lt;Nuget Server&gt; -g Linter Update 1$ dotnet tool update -g --no-cache Linter 接著就看你原本怎麼封裝 Cli ，直接執行即可 1$ Linter check -n ....... 結語第一次使用 dotnet tool 有驚豔到，以前都只會傻傻的用 console application ，每次都覺得部屬超麻煩，以後透過 dotnet tool 真的是方便多了 保哥 - 體驗 .NET Core 2.1 全新的全域工具安裝與使用 (.NET Core Global Tools)使用 .NET Core CLI 建立 .NET Core 通用工具","categories":[],"tags":[{"name":"dotnet core","slug":"dotnet-core","permalink":"https://toyo0103.github.io/tags/dotnet-core/"}]},{"title":"【SQL】Output","slug":"sql_output","date":"2019-05-07T02:36:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2019/05/07/sql_output/","link":"","permalink":"https://toyo0103.github.io/2019/05/07/sql_output/","excerpt":"","text":"情境DBA 反應偵測到有個 Update Query 很頻繁，且通常緊接著 Update 後都會再進 Select 把剛剛 Update 的資料拉走，資料量太大時頻率太高導致 SQL 效能瓶頸，建議調整成 Update 後直接把剛剛異動的資料拉走，而不是拆兩段查詢。 解決方案當 SQL Server 執行 Update 時會 Lock 相關要異動的資料，並把異動前後的資料放入 Log 中，如果希望能在一次 Query 中就把資料 Update 並把影響到的資料回傳，可以透過 Ouput 這個子句來達成 Ouput 可用於以下情境DeleteInsertUpdateMerge 我們有一張表，紀載著每個人的名稱與學期分數 老師大發慈悲想把低於 60 分的人都改成 60 分及格，這時候語法可以這樣下 1234567891011121314151617DECLARE @UpdateLog table( Id int not null, Name nvarchar(20) not null, OriScore int not null, NewScore int not null)UPDATE dbo.[User]SET Score = 60OUTPUT INSERTED.Id, INSERTED.Name, DELETED.Score, INSERTED.ScoreINTO @UpdateLogWHERE Score &lt; 60SELECT * FROM @UpdateLog 參考資料Microsoft - OUTPUT 子句 (Transact-SQL)Use SQL UPDATE to Query and Modify Data","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【AWS】EC2 can't access metadata service","slug":"aws_windows_ec2_cant_access_metadata","date":"2019-04-30T07:52:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2019/04/30/aws_windows_ec2_cant_access_metadata/","link":"","permalink":"https://toyo0103.github.io/2019/04/30/aws_windows_ec2_cant_access_metadata/","excerpt":"","text":"情境EC2 上的 windows VM 突然無法存取相對應的 AWS 服務，而這些權限原本都是透過 IAM Role 賦予的，之前文章有提過 AWS 機器是如何透過 IAM Role 得知自己有哪些權限 Windows IAM Role 問題 在該機器呼叫 metadata service 會回應錯誤 1$ curl 169.254.169.254 詢問對 AWS 比較熟的一些同事，聽說在 windows server 2012 版本之後，更換 Instance Type 重新開機時會發生 解決方法執行 C:\\ProgramData\\Amazon\\EC2-Windows\\Launch\\Scripts\\InitializeInstance.ps1 ，它會重新 Binding 一些相關設定，執行完後就好了 參考文章[Stackoverflow] AWS EC2 Windows 10 can’t access metadata","categories":[],"tags":[{"name":"aws","slug":"aws","permalink":"https://toyo0103.github.io/tags/aws/"}]},{"title":"【Docker】透過 Jenkins 重新部屬遠端機器 Container","slug":"jenkins_update_remote_docker_container","date":"2019-04-30T02:00:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2019/04/30/jenkins_update_remote_docker_container/","link":"","permalink":"https://toyo0103.github.io/2019/04/30/jenkins_update_remote_docker_container/","excerpt":"","text":"前言公司慢慢在導入 Docker 等相關 Container 技術，但因為剛起步所以很多 CI/CD 流程都還在優化建構中，前幾天為了能讓 Jenkins 順利重新部屬新版 Container 搞得焦頭爛額，乾脆把這些過程記錄下來 部屬流程 這個服務是由三個 Component 來組成，分開維護開發，換句話說如果有任何一個組件更新，整個服務都需要更新並重新部屬，目前的流程是各個 Component 更新後都會觸發 CD 流程將完成品打包放到 S3。 而我這次做得線就是 Docker Image 那條，當有任何 Component 更新了都會觸發，我會將 S3 的各個 Component 最新版抓下來後整理，接著再打包一版 Build Docker Image 會需要的原料放到 S3。 接著 Jenkins 接手將 Docker Image Artifact 抓下來開始 build =&gt; push =&gt; 換掉遠端機器正在跑的 Container。 設定權限 所以第一步是釐清 Jenkins 所使用的 user 是否有執行 docker 相關指令的權限，後面都簡稱這位使用者為 ciuser。 因為 docker 為 service 等級的服務，預設是 admin 才能使用相關指令，所以理所當然地馬上卡關 要讓使用者有執行 docker 相關指令的權限有兩種方法 賦予該 User Admin 的權限 開一個群組，並設定 docker daemon ，賦予該群組權限 顯然 (1) 不太可能(雖然最簡單)，所以這邊採取 (2) 的方法 *** Windows 上右鍵 &gt; Computer Management** *** Local Users and Groups &gt;&gt; Groups ** *** New Group &gt;&gt; 建立一個群組 &gt;&gt; 將 ciuser 加進去** *** 到 C:\\ProgramData\\docker\\config 修改 daemon.json 檔案**(如果沒有這個檔案，請自己建一個) 將剛剛的群組加進去 123&#123; &quot;group&quot;: &quot;docker-users&quot;&#125; *** 重新啟動 docker service ** (這邊需要 admin 權限) 12# Powershell$ Restart-Service docker 做到這邊你在用 ciuser 下 docker command 應該就可以動了 PS. 如果還不行，請先登出 ciuser 再登入，因為將使用者加入一個群組或賦予權限，重登才會生效 參考文章Docker Engine on Windows 到這邊應該已經打通 ciuser 可以執行 docker command 的權限了，接著在 Jenkins 設定 build 、 push Image的流程測試會發現依然錯誤 error during connect: Get http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.40/containers/json: open //./pipe/docker_engine: The system cannot find the file specified. In the default daemon configuration on Windows, the docker client must be run elevated to connect. This error may also indicate that the docker daemon is not running. 但同樣的指令不透過 Jenkins 執行，而是用遠端登入直接執行會過，這個問題想了很久還是搞不懂為什麼，明明使用的 User 相同 … 但找到了一篇文章也提到相同的事情並提供了解決方案，主要是需要調整 docker_engine ACL 設定，但因為過程太麻煩，作者很貼心的還提供了小套件可以使用 1234# Powershell$ Install-Module -Name dockeraccesshelper$ Import-Module dockeraccesshelper$ Add-AccountToDockerAccess &quot;ciuser&quot; 再次執行 Jenkins 就真的成功了 參考文章Allow access to the Docker Engine without admin rights on Windows 設定 JenkinsBuild Image 、 Push Image 這些流程就直接省略了，重點是最後一步怎麼觸發遠端機器更新 Container 。 Docker Compose 提供 --host ，讓你可以操作遠端機器的 Container 但前提是你必須先去該機器開啟 2376 port 的防火牆，還有設定 docker daemon config，跟上面那段一樣檔案，只是上次設定的是 jenkins 機器，這次是跑 Container 的機器 路徑 : C:\\ProgramData\\docker\\config\\daemon.json 123&#123; &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2376&quot;, &quot;npipe://&quot;]&#125; 都開好後回頭在 Jenkins 的流程中埋下最後一段 123$ docker-compose -H machineIp:2376 pull$ docker-compose -H machineIp:2376 up -d 結語雖然只是短短的一篇，但是整個設定的過程其實卡很久，尤其是 windows 的權限不是很熟常常會把自己搞得很亂，但為了團隊能接手維運，這些過程又勢必有人需要去踩過一次，以前都覺得 DevOps 的 Dev 才是主力(自己大部分經歷也都是待在開發團隊)，對於維運一直都沒有很深入去了解並感受他們的痛。 但當角色從 Developer 漸漸轉成 Infra ，不同的角度去看這些事情有了完全不同的感受，維運真的才是整個軟體生命週期佔最大的部分，一套系統你可能開發個 1 ~ 3 年，但產品的維運可能是數十年，怎麼讓一套機制落地，讓人為介入越少越好，要考慮的面向真的比過去單純開發差非常多，果然還有得學阿。","categories":[],"tags":[{"name":"microservice","slug":"microservice","permalink":"https://toyo0103.github.io/tags/microservice/"},{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"}]},{"title":"【Docker】Build Image","slug":"Docker_build","date":"2019-04-22T02:19:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2019/04/22/Docker_build/","link":"","permalink":"https://toyo0103.github.io/2019/04/22/Docker_build/","excerpt":"","text":"前言剛開始使用 Docker 的時候，我常常都是使用別人已經包好的 Image，但難免會有不符使用需要客製的時候，又或是將公司的某些服務做成 Docker Image ，再從多台機器上 Pull Docker Image 直接執行，所以 Docker Build 幾乎是玩 Docker 必學的技巧了 從 Docker Hub 尋找適合的 Image 來使用 前陣子將公司一些服務包成 Docker Image 並部署執行 製作第一個 Docker Image下面的範例會透過一個簡單的範例來解說包 Docker Image 的過程，希望最後的成果是，我們透過執行自製的 Docker Image 就跑起來一個 ASP.Net 的網站 開新專案 直接用 VS 執行起來就是一個最原始的 MVC 網站 DockerfileDockerfile 是 Build Docker Image 的根本，這個檔案會告訴 Docker 該把什麼東西放進 Image ? 步驟是什麼 ? 怎麼啟動 ? 先新增一個 Docker File 到剛剛的專案中 調整屬性 這樣如果發行這個專案，dockerfile 就會一起過去 Dockerfile 內容 123FROM mcr.microsoft.com/dotnet/framework/aspnet:latestCOPY . /inetpub/wwwroot From : 表示你這個 Image 是以哪一個當作 Base，以這次的案例為例，我們選擇微軟官方提供的 mcr.microsoft.com/dotnet/framework/aspnet Image 作為 base，因為它已經幫我們安裝好 IIS 、.net Framework，這樣我們只要專注在我們開發的程式即可。 COPY : dockerfile 所屬資料夾所有的內容複製到 container 裡面的 c:/inetpub/wwwroot，也就是 IIS 的預設目錄 Docker build1$ docker build -t &lt;ImageName&gt;:&lt;Tag&gt; &lt;Dockerfile Path&gt; 1$ docker build -t my_first_docker_image:latest -t my_first_docker_image:1.0.0 . docker build 時我為這個 Image 下了兩個 tag，分別為 latest、1.0.0 Docker Run執行剛剛我們自建的 Image，並且將本機的 9999 port mapping 到 container 內的 80 port 1$ docker run -d -p 9999:80 my_first_docker_image:latest 這樣就可以看到網站啦 小結這邊只是小小演示如何 Build 一個最簡單的 docker image，其實 Dockerfile 還有很多可以發揮的地方，如果有需要，可以參考以下官方文件 參考文章Docker build將 ASP.NET MVC 應用程式遷移到 Windows 容器","categories":[],"tags":[{"name":"microservice","slug":"microservice","permalink":"https://toyo0103.github.io/tags/microservice/"},{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"}]},{"title":"【Docker】Widows Container SMB","slug":"windows_container_smb_","date":"2019-03-23T09:53:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2019/03/23/windows_container_smb_/","link":"","permalink":"https://toyo0103.github.io/2019/03/23/windows_container_smb_/","excerpt":"","text":"之前在將公司某支程式移植到 Windows Container 時碰到一個問題，該程式會透過網路磁碟 (SMB) Eamil Template 來套版並寄出，但將網路磁碟透過 Volume 的方式 Mount 到 Container 卻抓不到檔案，查了一下才知道原來需要用 SmbGlobalMapping 掛載的網路磁碟才行 Windows Server 容器儲存體 以下這段是先將要用到的網路磁碟透過 New-SmbGlobalMapping 指令掛成 T: 1234567$ $User=&quot;yourUSerAccount&quot;$ $PWD = ConvertTo-SecureString -String &quot;yourPassword&quot; -AsPlainText -Force$ $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User, $PWD$ New-SmbGlobalMapping -LocalPath T: -RemotePath \\\\my-company-Filer\\Files -Credential $Credential 然後在透過 Volume 即可 1$ docker run -it -v T:\\:C:\\Files myContainer 不過還要特別注意的是，在 Windows Server (版本 1709)，SMB 全域對應不支援 DFS、DFSN、DFSR 共用。 所以如果是 DFS 那就只好先強制指到某一台，期待哪一天 Windows Container 可以支援了","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"windows container","slug":"windows-container","permalink":"https://toyo0103.github.io/tags/windows-container/"}]},{"title":"微服務的戰場","slug":"microservice_battlefield","date":"2019-03-21T15:30:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2019/03/21/microservice_battlefield/","link":"","permalink":"https://toyo0103.github.io/2019/03/21/microservice_battlefield/","excerpt":"","text":"整理一下最近在學習的 Road map，大致上圍繞著微服務 微服務 什麼是微服務 微服務的好幫手 Container Docker for Windows 和 Docker on Windows Server 一樣嗎? Docker Build Image Docker Compose 偵錯技巧 Widows Container DNS Server 問題 Widows Container IAM Role 問題 Windosw Container SMB Queue RabbitMQ NATS Self Hosting Owin Graceful Shutdown Service Discovery 部署 K8S docker swarm 透過 Jenkins 重新部屬遠端機器 Container","categories":[],"tags":[{"name":"microservice","slug":"microservice","permalink":"https://toyo0103.github.io/tags/microservice/"},{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"}]},{"title":"【C#】Yield Return (二)","slug":"yield_return_2","date":"2019-03-15T09:30:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2019/03/15/yield_return_2/","link":"","permalink":"https://toyo0103.github.io/2019/03/15/yield_return_2/","excerpt":"","text":"最近經過大師的指導後，對於 Yield Return 又或是迭代器有更深的感受，先來看一段以前常常會寫的程式 12345678910111213void Main()&#123; var users = GetUser(idList); //過濾黑名單 var notInBlackList = users.Where(x=&gt; !x.InBlackList); //往下做其他邏輯&#125;public List&lt;User&gt; GetUser(List&lt;int&gt; ids)&#123; //透過 ID 取得會員的詳細資料&#125; 如果 Id 一次有一百萬筆，為了避免擊沉 Database 做了分批查詢也是很合理的 1234567891011121314151617181920212223void Main()&#123; var users = GetUser(idList); //過濾黑名單 var notInBlackList = users.Where(x=&gt; !x.InBlackList); //往下做其他邏輯&#125;public List&lt;User&gt; GetUser(List&lt;int&gt; ids)&#123; var Result = new List&lt;User&gt;(); // 每批搜尋 1000筆 var batchCount = 1000; //計算出搜尋次數後分批查詢 for (int i = 0; i &lt; 搜尋次數; i++) &#123; Result.AddRange( UserRepository.Get(ids.Skip(i * batchCount).Take(batchCount))); &#125;&#125; 當然也可以從呼叫端分批處理 12345678910111213141516171819void Main()&#123; // 每批搜尋 1000筆 var batchCount = 1000; for (int i = 0; i &lt; 搜尋次數; i++) &#123; var users = GetUser(idList); //過濾黑名單 var notInBlackList = users.Where(x=&gt; !x.InBlackList); //往下做其他邏輯 &#125; &#125;public List&lt;User&gt; GetUser(List&lt;int&gt; ids)&#123; //透過 ID 取得會員的詳細資料&#125; 如果需要再更複雜一些，要依據使用者的設定濾掉一些人，最終要將處理過程都填回 DB ，以便追蹤那些人是因為那些條件被過濾掉的 (不然被客戶抱怨沒收到通知，不知道往哪找)，這時候程式就會變成這樣…. 12345678910111213141516171819202122232425262728293031323334void Main()&#123; // 每批搜尋 1000筆 var batchCount = 1000; var temp = new List&lt;User&gt;() for (int i = 0; i &lt; 搜尋次數; i++) &#123; var users = GetUser(idList); var notInBlackList = users.Where(x=&gt; !x.InBlackList); var wantToReceiveThisMessage = notInBlackList.Where(x =&gt; x.BlockMessageType != ThisMessageType); //統計誰在黑名單被過濾掉 //統計誰不想收到這種類型的 DB //可能批次更新是 5000 筆最有效率 temp.Add(InBlackList); temp.Add(DontWantToReceiveThisMessage); if (temp.Count &gt; 5000) &#123; // Insert Log LogRepository.Add(temp); temp.Clear(); &#125; &#125; &#125;public List&lt;User&gt; GetUser(List&lt;int&gt; ids)&#123; //透過 ID 取得會員的詳細資料&#125; 條件可以無限增長上去，程式也會變得越來越複雜，當然這時候可以採取一些物件導向的設計將功能職責拆開，不過這不是這篇的重點所以跳過。 更符合語意的寫法如果有用過 FluentAssertion、Nsubstitute 等套件，應該會發現它 API 設計得非常好讀好懂 123customer.Active.Should().BeTrue(because, becauseArgs);theObject.Should().NotBeSameAs(otherObject); 讓程式不再是一段一段的，而是一看程式就能理解這邊在做什麼，而且也因為如此讓每個方法的職責更清楚單一，所以我們可以將上述的程式改成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void Main()&#123; //從使用端傳來一大批 Ids List Ids.GetUser().NotInBlackList().WantToReceiveThisMessage(ThisMessageType).Record();&#125;public static IEnumerable&lt;User&gt; GetUser(this IEnumerable&lt;int&gt; ids)&#123; var temp = new List&lt;int&gt;(); foreach (var id in ids) &#123; temp.Add(id); // 假設每 1000 筆是有最好的搜尋效率 if (temp.Count == 1000) &#123; foreach (var user in UserRepository.Get(temp)) &#123; yield return user; &#125; temp.Clear(); &#125; &#125; if (temp.Count &gt; 0 ) &#123; foreach (var user in UserRepository.Get(temp)) &#123; yield return user; &#125; &#125; yield break;&#125;public static IEnumerable&lt;User&gt; NotInBlackList(this IEnumerable&lt;User&gt; users)&#123; foreach (var user in users) &#123; if (user.InBlackList == false) &#123; yield return user; &#125; &#125; yield break;&#125;public static IEnumerable&lt;User&gt; NotInBlackList(this IEnumerable&lt;User&gt; users, MessageType type)&#123; foreach (var user in users) &#123; if (user.BlockMessageType != type) &#123; yield return user; &#125; &#125; yield break;&#125;public static IEnumerable&lt;User&gt; Record(this IEnumerable&lt;User&gt; users)&#123; var temp = new List&lt;User&gt;(); foreach (var user in users) &#123; temp.Add(user); if (temp.Count == 5000) &#123; // Insert Log LogRepository.Add(temp); temp.Clear(); &#125; yield return user; &#125; if (temp.Count &gt; 5000) &#123; LogRepository.Add(temp); &#125; yield break;&#125; 如果還需要紀錄每個過程的分別過濾的狀態，只需要在方法開個統計的物件參數，在每筆過程中做紀錄即可，不只讓整個程式可讀性更高、內聚更強，之後如果不想要紀錄或不想要過濾黑名單，也可以很快的調整完成 1Ids.GetUser().WantToReceiveThisMessage(ThisMessageType);","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"Jenkins,GitHub自動化部署Hexo","slug":"centos_jenkins_hexo","date":"2019-02-28T23:38:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2019/03/01/centos_jenkins_hexo/","link":"","permalink":"https://toyo0103.github.io/2019/03/01/centos_jenkins_hexo/","excerpt":"","text":"這個部落格是用 hexo 來製作的，優點是可以用 Markdown 寫法，且很多套件支援,讓我這個美感小白痴也可以輕鬆弄出富有質感的部落格(自己說)。 但也因為這樣,每次寫完文章都需要下 command 來編譯部落格、發佈到 Github ，讓我覺得不夠自動化 12$ hexo g $ hexo deploy 剛好最近在玩 AWS ，就想說來弄一台 t2.small Centos 機器來做 CI 機器好了 AWS EC2 Launch InstanceAMI ： CentOS 7 Type ： t2.small 原本用 t2.micro ，但經過測試在 Jenkins 執行 Job 的時候常常因為記憶體不足就當掉了，改 t2.small 後穩定許多 因為我之前已經有其他台 EC2 ，所以這邊我選擇用已經產過的 ssh key 來當作連線這台機器的 Key Security GroupSSH 連線需要開 22 Port，先確認一下 Security Group 有開啟 用剛剛產出的 pem 檔連線到機器 1$ ssh -i ~/.ssh/&#123;yourSSH.pem&#125; centos@&#123;yourEc2IP&#125; 如果登入成功應該會看到這樣 如果遇到 Permission denied ，你需要先調整剛剛下載下來的 pem 檔的權限 1$ chmod 400 yourSSH.pem @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for ‘amazonec2.pem’ are too open.It is recommended that your private key files are NOT accessible by others.This private key will be ignored.bad permissions: ignore key: amazonec2.pemPermission denied (publickey). 參考文章Trying to SSH into an Amazon Ec2 instance - permission error鳥哥的 Linux 私房菜 Jenkins 安裝 參考文章How To Install Jenkins on CentOS 7 基本上我完全是按照上面的文章教學一步一步完成的，在 Linux 還不是很熟的情況下，這邊只記下流水帳，詳細建議參考上述文章。 Install the OpenJDK 8 package 1$ sudo yum install java-1.8.0-openjdk-devel Import the GPG key 1$ curl --silent --location http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo | sudo tee /etc/yum.repos.d/jenkins.repo Add the Jenkins repository to your system 1$ sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key Install Jenkins 1$ sudo yum install jenkins Start the Jenkins service 1$ sudo systemctl start jenkins Check Jenkins Status 1$ systemctl status jenkins Enable the Jenkins service to start on system boot 1$ sudo systemctl enable jenkins 設定這時候透過瀏覽器連線 Jenkins，應該會得到 Timeout 的回應 1網址：http:&#x2F;&#x2F;yourEc2PublicIP:8080 原因是機器的 Security Group 並沒有開放 80 Port 可以連進來，所以需要設定一下 再次連線應該就可以看到設定畫面了 第一次設定需要透過機器取得密碼 1$ sudo cat /var/lib/jenkins/secrets/initialAdminPassword 將這段密碼貼上去後就可以進入下一步 選擇 Install Suggested plugins 設定 Admin User Hexo 安裝 Nodejs 、 NPM為了能在 Jenkins Build Hexo ，必須先安裝好 NodeJs 並安裝 Hexo 參考文章How to install Node.js and npm on CentOS 7 這邊一樣只節錄流水帳，詳細說明建議參考原文 Add NodeSource yum repository 1$ curl -sL https://rpm.nodesource.com/setup_10.x | sudo bash - Install NodeJs and NPM 1$ sudo yum install nodejs Check 12$ node --version$ npm --version Install Git12$ sudo yum install git$ git --version Build Hexo因為我原本就已經有 Hexo Blog Repository，所以我該先讓 Jenkins 機器能夠從 pull blog source 建立 ssh key 1$ ssh-keygen Add this ssh public key to github 1$ cat ~/.ssh/id_rsa.pub 將這整段 Public Key 加到 Github Install Hexo 1$ sudo npm install hexo-cli -g Test git clone and hexo build 12345$ git clone git@github.com:yourRepository/yourRepository.github.io.source.git$ cd yourRepository$ npm install$ hexo g$ hexo server 如果到這邊都正常，基本上 Jenkins 機器已經有能力幫你 Build Hexo了 Create Jenkins Job 新增作業 原始碼管理 設置 Credentials（點選 Add &gt; Jenkins） 將 Private Key 貼進去 1$ cat ~/.ssh/id_rsa 連線就正常了 建置觸發程序 建置 Github Webhook這邊是要設定，當 Github 發現 Repository 被更新時，主動打個 Request 觸發剛剛建立好的 Jenkins 先進到 Your Repository &gt; Settings &gt; Webhooks Add Webhooks 1http:&#x2F;&#x2F;yourEc2PublicIP:8080&#x2F;github-webhook&#x2F; 請特別注意！！ github-webhook/ 後面這個斜線一定要，不然會 302 錯誤 錯誤排除看似一切美好又順利的把 Webhooks 接了起來，但觸發 Jenkins 後發現以下錯誤 123INFO Deploying: gitPermission denied (publickey).fatal: Could not read from remote repository. 為什麼 ？ 剛剛不是遠端登進去都試過跟 Git 之前的操作沒問題嗎？ 原來是因為剛剛的 SSH Key 是建立在 centos 這個登入帳號底下，Jenkins 是透過自己的帳號權限在執行，所以我們必須將剛剛的SSH Key 搬過去給你，並賦予它權限 12$ cp ~/.ssh/id_rsa.pub /var/lib/jenkins/.ssh/$ cp ~/.ssh/id_rsa /var/lib/jenkins/.ssh/ 移過去後還需要將檔案擁有者改成 Jenkins，或是你可以針對 Jenkins 這跟帳號設定檔案權限，我這邊選擇直接把擁有者改成 Jenkins 12$ sudo chown jenkins /var/lib/jenkins/.ssh/id_rsa.pub$ sudo chown jenkins /var/lib/jenkins/.ssh/id_rsa 確認權限都正確就大功告成啦！！ 現在你看到的這篇，就是透過 Jenkins 自動建置部署上來的 參考文章[小题大做] Github + Jenkins 实现自动化部署 hexo 博客静态文件","categories":[],"tags":[{"name":"centos","slug":"centos","permalink":"https://toyo0103.github.io/tags/centos/"},{"name":"jenkins","slug":"jenkins","permalink":"https://toyo0103.github.io/tags/jenkins/"},{"name":"hexo","slug":"hexo","permalink":"https://toyo0103.github.io/tags/hexo/"}]},{"title":"【Docker】偵錯技巧","slug":"docker_debug_skill","date":"2019-02-22T08:48:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2019/02/22/docker_debug_skill/","link":"","permalink":"https://toyo0103.github.io/2019/02/22/docker_debug_skill/","excerpt":"","text":"學習 Docker 最先碰到的困擾應該都是究竟該如何偵錯 ，畢竟 Docker Run Container 如果沒有下一些指令，通常都是執行完就砍掉，什麼都沒留下，不像在本機可以透過開發的 IDE、Log … 等手段來 Debug，所以這邊就寫下一些我較常使用的偵錯方式 Run如果 Build Docker Image 時就有指定 CMD 或是 ENTRYPOINT，那 Container Run 起來後跑完就關掉了，這時候可以透過 Run 的最後一個參數來覆蓋過原本的 CMD 指令。 1$ docker run -it mcr.microsoft.com/windows/nanoserver:1809 cmd.exe 這邊的 cmd.exe 就是要覆蓋 Build Image 所指定的指令，讓你可以進入 Container 的 terminal 中執行你想做的指令 Docker ENTRYPOINT &amp; CMD: Dockerfile best practices Volume因為 Container 每次執行都是全新的，所以導致 Log 不易保留，但我們可以 Volume 的方式將 Host Folder 與 Container 內的 Log Folder Mount ，這樣就可以將 Container 內的 Log File 寫出來，達到持久化的效果。 (圖片來源 : Docker Docs ) 接著用簡單的範例來展示一下 1$ docker run -it mcr.microsoft.com/windows/nanoserver:1809 cmd.exe 進到 Container 後，隨便寫個檔案 1234$ mkdir log$ cd log$ echo &quot;hi&quot; &gt;&gt; test.txt$ dir 可以看到在 Container 內的確長出了 C:\\log 資料夾，並且裡面有個 test.txt 的檔案，檔案裡面寫著 “hi”。但這時候你在 host 機器應該找不到對應的檔案，因為 Container 是彼此獨立且隔離的。 這時候離開 Container 再重啟一次，會發現剛剛 log 的 Folder 已經消失，因為這個 Container 是全新的 123$ exit$ docker run -it mcr.microsoft.com/windows/nanoserver:1809 cmd.exe$ dir Volume 使用方式 1docker run -v HostFolderPath:ContainerFolderPath 加上 Volume 參數再重新執行一次剛剛的步驟 1$ docker run -it -v c:\\files:c:\\log mcr.microsoft.com/windows/nanoserver:1809 cmd.exe 將 Host 機器的 c:\\files Folder Mount 到 Container 內的 c:\\log 資料夾，所以在 Container 內新增檔案寫 Log 也會同時寫出來 這邊應該會注意到，因為 Volume 了 Container 內原本不存在的 log 資料夾，所以一進去的時候它就長出來了，並不需要特別另外建立。 EXEC有時候 Container 內執行的是常駐程式，它可能會持續執行直到任務完成，如果又沒有將 Log 寫出來的必要，其實很難知道它目前的狀況為何，這時候 EXEC 就派上用場了，它可以讓你進入一個正在執行中的 Container 中。 一樣用個簡單的範例來演練一下 先 Run 一個 Container 起來，並且一樣寫一個 log 下來 12345$ docker run -it mcr.microsoft.com/windows/nanoserver:1809 cmd.exe$ mkdir log$ cd log$ echo &quot;hi&quot; &gt;&gt; test.txt$ dir 這時候開另一個 terminal，先查詢剛剛的 Container ID 1$ docker ps 透過 EXEC 指定要執行哪個 Container 1$ docker exec -it d24e6db4de85 cmd.exe 可以看到一進去就已經有剛剛我們寫下的 test.txt，表示這是同一個 Container，或是可以透過 hostname 來做驗證，可以得到相同的 ID","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"windows container","slug":"windows-container","permalink":"https://toyo0103.github.io/tags/windows-container/"}]},{"title":"【Docker】Docker for Windows 和 Docker on Windows Server 一樣嗎?","slug":"dockerforwindows_vs_dockeronwindowserver","date":"2019-02-21T02:36:00.000Z","updated":"2022-08-09T13:36:17.080Z","comments":true,"path":"2019/02/21/dockerforwindows_vs_dockeronwindowserver/","link":"","permalink":"https://toyo0103.github.io/2019/02/21/dockerforwindows_vs_dockeronwindowserver/","excerpt":"","text":"一開始以為 Docker For Windows 跟 Windows Containers on Windows Server 是一樣的東西，結果在建置 CI 機器時碰到一些問題才發現原來是不同東西啊 Docker for WindowsDocker for Windows 底層是透過 Hyper-V 來乘載 Docker Engine，也因為需要多一層 Hyper-V ，所以執行效率比之後出的 Docker on Windows Server 直接原生 Docker Engine 效率來說差了一截，但也因為有 Hyper-V 的協助下，可切換成能執行 Linux Container 的模式。 Windows 10 Professional 版本就可以安裝 ( 因為Professional 版本才有 Hyper-V ) 圖片來源 : Microsoft Windows 10 上的 Windows 容器Get started with Docker for WindowsWindows 上的 Linux 容器 Windows Containers on Windows Server Install Docker Engine - Enterprise on Windows Servers Windows Server 2016 或更新的版本才可使用，直接在 OS 上執行 Docker Engine，所以效能比需要 Hyper-V 的 Docker for Windows 好上一大截，如果要跑 Linux 類的 Container 也可以透過 --isolation=hyperv 的方式，不過有個限制是這個方法不能在 VM 中用，也就是說如果你今天是用雲端的 Windows Server，本身已經是在 VM 裡面了，就無法在裡面執行 isolation。 圖片來源 : MSDN 目前因為公司內部很多既有專案都是用 .Net Framework 開發的，所以轉移到 Container 也是選擇用 Windows Containers on Windows Server，畢竟如果是 Production Service，效能還是非常重要的一個考量 參考文章Windows Container FAQ - 官網沒有說的事Docker FOR Windows vs. Docker ON Windows Server - vizuri","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"windows container","slug":"windows-container","permalink":"https://toyo0103.github.io/tags/windows-container/"}]},{"title":"【Docker】Widows Container DNS Server 問題","slug":"windows_container_dnsserver","date":"2019-02-20T07:10:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2019/02/20/windows_container_dnsserver/","link":"","permalink":"https://toyo0103.github.io/2019/02/20/windows_container_dnsserver/","excerpt":"","text":"情境Windows Container 執行起來的時候，DNS Server 預設會吃 Host 的設定，但第一組會擺 Default Gateway 的 IP 但會碰到當在解析 IP 時，只會走第一組 Name Server 去問，如果問不到並不會問第二組，導致解析失敗 (需明確指定 Name Server 才能查的到) 聽說這也是 Windows Container 才會碰到的問題，用 Linux 的同事們表示黑人問號 ??? 解法DotNet 人有 DotNet 人的玩法，果然找到有人有相同的問題 參考文章the –dns option is not working with windows container 解法就是當 Container 執行起來的時候，用 Powershell 去改 DNS Server 設定 …. 恩 …. 就改吧 1$ powershell Set-DnsClientServerAddress -InterfaceAlias vEthernet* -ServerAddresses 10.2.x.x,10.2.x.x 執行完後重新查詢網路設定會看到 DNS Server 第一組已經不是 Default Gateway 1$ ipconfig /all 這時候在重新查一次 IP ，不用特別指定 Name Server 就正確了 同場加映這邊特別介紹 dns_search 這個 docker 參數 因為公司測試機都有加入 AD 群組，所以伺服器別名即便不寫全名還是可以查的到，但在 Container 內就不是這麼回事了，必須寫完整的全名不可，原本以為要改 Config ，請大家都寫完整，還好同事提醒有這個參數可以使用。 只要在 Docker Run 時或是 Docker Compose 設定加上 Domain Name，這樣 Container 找不到時就會加上 Domain Name 在完整搜尋一次 1dns_search: your.domain 這參數又拯救了 IT 狗的一天…","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"windows container","slug":"windows-container","permalink":"https://toyo0103.github.io/tags/windows-container/"}]},{"title":"【Docker】Widows Container IAM Role 問題","slug":"windows_contianer_iamrole_","date":"2019-02-19T08:25:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2019/02/19/windows_contianer_iamrole_/","link":"","permalink":"https://toyo0103.github.io/2019/02/19/windows_contianer_iamrole_/","excerpt":"","text":"情境通常在使用 EC2 的建議上都是希望將機器掛上 IAM Role 的權限，在機器上面執行相關 AWS 資源時就可以透過該角色的權限來執行，避免將 Access Toke 、Secret Key 寫到程式中去跑。 但如果將程式包到 Container 裡面去執行時卻發現，Linux Container 可以吃到 Host 的 IAM Role 權限，而 Windows Container 卻不行，為何 ? 原因原來 AWS 之所以能夠讓機器能知道執行權限為何是否過一個叫 Metadata Service 的服務來達成 1$ curl 169.254.169.254 當在 EC2 上執行該指令應該能看到基本的回應 連線到 http://169.254.169.254/latest/meta-data/ 也可以看到一些對應的 Metadata 設定，而這個 Metadata Service IP 很巧的在 Azure 上也一模一樣 XD 參考文章Instance Metadata and User DataAzure 執行個體中繼資料服務 所以要能夠透過 IAM Role 的權限來執行 AWS 相關資源，169.254.169.254 就勢必要能通，接著將 Windows Container Run起來並執行相同指令會發現得到 Timeout 的回應 Windows Container 預設是走 NAT 的網路模式，如果你在 Host 與 Windows Container 內列出 Routing Table IPv4 的資料會發現，169.254.169.254 Gateway 是走同一條 1$ route print -4 這也是導致 Container 內得不到回應的原因 1$ ipconfig /all 應該透過 NAT Router default gateway 才出的去 解法先看看預設 Container 用的網路是如何設定的 1$ docker network ls 1$ docker network inspect nat 可以看到紅框處並沒有指定 Default Gateway，所以每次執行 Container 時都是動態分配 Subnet 與 Default Gateway，這樣讓我們設定上會有困難 自建一組網路給 Container 使用可以透過 Docker network create 來預先建立一組規範好的網路，並讓 Container 起起來的時候指定吃這組設定 1$ docker network create --driver nat --gateway 172.17.0.1 --subnet 172.17.0.0/20 mynetwork 1$ docker run -it --rm --network mynetwork mycontainer:latest 檢視 Container 起來後網路設定狀況，可以看到 Default Gateway 已經被定下來了 接著執行 1$ route -p add 169.254.169.254 172.17.0.1 至於 route add 怎麼在 Container 起起來時自動執行那就是另一個課題了，這邊不討論 Docker compose 動態建網路給 Container 使用第二種方法是透過 Docker compose 執行時動態建立一組網路來使用，方法大同小異，只是透過 Docker Compose 來設定而已 1234567891011121314version: &#x27;2.1&#x27;services: mycontainer: image: mycontainer:latest networks: - mynetworknetworks: mynetwork: driver: nat ipam: config: - subnet: 172.17.0.0/20 gateway: 172.17.0.1 結語最近跟著架構師還有一群很厲害的同事做新的專案，發現自己對於 Infra 與網路的知識真的相當不足，所以在Docker 一些設定與建置上常常卡的亂七八糟，也趁著這個機會把以前一堆已經還老師的知識又惡補了一翻，希望能越來越順利 參考文章AWSS IAM Roles in Windows Containerswiki - 保留IP位址","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"aws","slug":"aws","permalink":"https://toyo0103.github.io/tags/aws/"},{"name":"windows container","slug":"windows-container","permalink":"https://toyo0103.github.io/tags/windows-container/"}]},{"title":"將程式編譯成 x86、x64、Any CPU差別在哪","slug":"anycpu_x86_x64","date":"2019-02-12T03:09:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2019/02/12/anycpu_x86_x64/","link":"","permalink":"https://toyo0103.github.io/2019/02/12/anycpu_x86_x64/","excerpt":"","text":"相信用過 Visual Studio 的應該都注意過編譯時可以選擇 Any CPU、x86、x64 (x86、x64 需要編輯組態檔才會看的到) 這次踩到問題是，明明程式用 Any CPU 來編譯，但在 64 bit OS 上卻會用 32 bit Process 來執行 原來是因為專案建置的屬性勾到了 建議使用32位元的選項導致 解決的同時也引起了對於編譯成 x86、x64、Any CPU 有什麼差別的好奇心，找了文章後整理如下 差異 在 32 bit OS 上執行Any CPU : 會用 32 bit Process 來執行，可以載入 Any CPU 和 x86 方式編譯的組件，但如果載入 x64 編譯的組件將會引發 BadImageFormatException Any CPU (勾選建議使用32位元) : 運作方式同上 x86 : 運作方式同上 x64 : 引發 BadImageFormatException 在 64 bit OS 上執行Any CPU : 會用 64 bit Process 來執行，可以載入 Any CPU 和 x64 方式編譯的組件，但如果載入 x86 編譯的組件將會引發 BadImageFormatException Any CPU (勾選建議使用32位元) : 會用 32 bit Process 來執行，可以載入 Any CPU 和 x86 方式編譯的組件，但如果載入 x64 編譯的組件將會引發 BadImageFormatException x86 : 運作方式同 Any CPU (勾選建議使用32位元) x64 : 運作方式同 Any CPU Machine Config依據執行的 Process 位元決定 32 bit Process 吃的 Machine Config 位置 : C:\\Windows\\Microsoft.NET\\ Framework \\v4.0.30319\\Config 64 bit Process 吃的 Machine Config 位置 : C:\\Windows\\Microsoft.NET\\ Framework64 \\v4.0.30319\\Config 怎麼查是用哪種方式編譯的?可以透過 CorFlags.exe 的工具來查詢，該程式放在 C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v8.1A\\bin\\NETFX 4.5.1 Tools 路徑底下，設定為環境變數後就可以用 command 來檢視 PE 1$ corflags yourPE.exe PE : Process Executables (EXEs and DLLs) 意義如下 (圖片節錄至 : https://stackoverflow.com/questions/18608785/how-to-interpret-the-corflags-flags/23614024#23614024) 參考文章【茶包射手日記】檢查.NET程式平台目標(Platform Target)Dealing with 32-bit, 64-bit and Any CPU Compilation Options in .NETHow to interpret the CorFlags flags?","categories":[],"tags":[{"name":".Net","slug":"Net","permalink":"https://toyo0103.github.io/tags/Net/"}]},{"title":"【C#】Yield Return與迭代器","slug":"【C-】yield_retuen","date":"2018-12-21T05:54:00.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2018/12/21/【C-】yield_retuen/","link":"","permalink":"https://toyo0103.github.io/2018/12/21/%E3%80%90C-%E3%80%91yield_retuen/","excerpt":"","text":"什麼是 YieldYield 就是 .Net 中用來實作 iterator(迭代器) 設計模式的語法糖，雖然很早就知道這東西，但一直都不太知道怎麼用，剛好最近同事在翻寫寄送大量信件的程式有用到就跟他請教了一下。 以前的做法 將收件人從 DB 撈出來後 ，依據每封信的 Template 去置換內容，再批次送去給寄信服務執行 問題 如果這批收件人很多，把整批的信件都置換完 Template 再送出，會導致系統吃掉大量的記憶。當然最簡單的解決方法就是用迴圈組完一筆就送出一次，但其實用 Yield Return 可以更優雅的解決這個問題 範例同事提供了簡單的範例來理解這件事情 1234567891011121314151617181920212223242526272829303132333435static void Main(string[] args)&#123; foreach (var mail in GetData()) &#123; Console.WriteLine($&quot;- Received: &#123;mail.Title&#125;&quot;); &#125;&#125;static List&lt;Mail&gt; GetData()&#123; var mailList = new List&lt;Mail&gt;(); int buffer_size = 1024 * 1024 * 4; // 4MB Random _rnd = new Random(); for (int index = 0; index &lt; 1024; index++) &#123; var _buffer = new byte[buffer_size]; _rnd.NextBytes(_buffer); mailList.Add(new Mail() &#123; Title = $&quot;buffer[&#123;index&#125;], &#123;buffer_size / 1024 / 1024&#125; MB&quot;, Buffer = _buffer, &#125;); Task.Delay(50).Wait(); &#125; return mailList;&#125;public class Mail&#123; public string Title &#123; get; set; &#125; public byte[] Buffer &#123; get; set; &#125;&#125; GetData() 這是模擬處理信件的地方，每封信件假設 4MB (到底是寄啥…)，整批處理完後回傳 mailList 如果把這段 Code 放到 LINQPad 執行，會發現記憶體一直往上飆，因為會全部都做完放到 List 再回傳並寄信 Yield Return 版本12345678910111213141516171819202122232425262728293031323334static void Main(string[] args)&#123; foreach (var mail in GetData()) &#123; Console.WriteLine($&quot;- Received: &#123;mail.Title&#125;&quot;); &#125;&#125;static IEnumerable&lt;Mail&gt; GetData()&#123; int buffer_size = 1024 * 1024 * 4; // 4MB Random _rnd = new Random(); for (int index = 0; index &lt; 1024; index++) &#123; var _buffer = new byte[buffer_size]; _rnd.NextBytes(_buffer); yield return new Mail() &#123; Title = $&quot;buffer[&#123;index&#125;], &#123;buffer_size / 1024 / 1024&#125; MB&quot;, Buffer = _buffer, &#125;; Task.Delay(50).Wait(); &#125; yield break;&#125;public class Mail&#123; public string Title &#123; get; set; &#125; public byte[] Buffer &#123; get; set; &#125;&#125; 觀察記憶體會發現非常的平穩，因為逐筆處理完就被消滅掉了 小結至於如果不用語法糖 Yield 該如何實作迭代器，可參考安德魯的部落格裡面介紹非常詳細，希望這個方法以後可以更融會貫通的套在專案中使用 參考文章安德魯的部落格 - [C#: yield return] #1. How It Work ?Wiki - 迭代器","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【C#】Task WaitAll","slug":"Task_WaitAll","date":"2018-12-03T07:53:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2018/12/03/Task_WaitAll/","link":"","permalink":"https://toyo0103.github.io/2018/12/03/Task_WaitAll/","excerpt":"","text":"情境假設有一項任務，執行時會做三件事情，而這三件事情彼此並沒有相依關係，傳統程式寫法通常都是 1 &gt; 2 &gt; 3 依序呼叫下去做，但這樣有一個問題就是，假設 1 這個任務要執行特別久，那 2、3 都得等 1 做完才能執行到，整體來說效率並沒有最佳化。 跑一次需要 2.012 秒完成，如果需要重複 10 次 、100 次，那所需時間會相當可觀。 非同步版本改成非同步版本後，它執行順序就不會被第一步給拖累，三個工作是併行處理 但這會有一個問題，如果程式是 Run 在 Console Application 中，因為沒有等待非同步的程式都執行完，就已經跑到 Done ，而導致 Console Application 被關掉，其相應的 Process 也會被停掉，導致有些工作沒有執行完，所以必須要確保所有程式都執行完才關閉的機制在。 參考文章 MSDN : 以工作為基礎的非同步程式設計","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【日文】か、かどうか 如何使用","slug":"【日文】か_かどうか","date":"2018-11-21T07:52:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2018/11/21/【日文】か_かどうか/","link":"","permalink":"https://toyo0103.github.io/2018/11/21/%E3%80%90%E6%97%A5%E6%96%87%E3%80%91%E3%81%8B_%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B/","excerpt":"","text":"日文中的疑問子句 普通型 + かどうか + 子句 このカメラは日本で買ったかどうか、わからない這個相機是不是在日本買的,我不知道 先生が上手に歌えるかどうか、わからない老師唱歌拿不拿手,我不知道 (前面出現疑問詞)+普通型 + か + 子句 このカメラは誰のか、わからない這個相機是誰的,我並不知道 いつ日本へ行くか、知っていますか何時要去日本,你知道嗎？ 參考文章王可樂的日文教室【「かどうか」跟「か」快速解題法！】間接句型的用法","categories":[],"tags":[{"name":"日文學習","slug":"日文學習","permalink":"https://toyo0103.github.io/tags/%E6%97%A5%E6%96%87%E5%AD%B8%E7%BF%92/"}]},{"title":"MissingMethodException","slug":"MissingMethodException","date":"2018-11-14T09:04:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2018/11/14/MissingMethodException/","link":"","permalink":"https://toyo0103.github.io/2018/11/14/MissingMethodException/","excerpt":"","text":"情境寫單元測試的時候編譯都沒問題，但在執行時一直報錯 System.MissingMethodException 的錯誤，查了一下發現跟 System.Net.Http 有關 System.MissingMethodException with message“Method not found: ‘System.Web.Http.Results.ResponseMessageResultSystem.Web.Http.ApiController.ResponseMessage(System.Net.Http.HttpResponseMessage)” 檢查測試專案與受測專案的 System.Net.Http Nuget套件皆為同一個版本 但意外發現兩個專案的 System.Net.Http 參考卻為不同位置 照理來說應該都要參考到專案內的 packages 底下才對，檢查 .csproj 裡面的 Reference 並沒有寫錯 123&lt;Reference Include=&quot;System.Net.Http, Version=4.1.1.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL&quot;&gt; &lt;HintPath&gt;..\\..\\packages\\System.Net.Http.4.3.2\\lib\\net46\\System.Net.Http.dll&lt;/HintPath&gt;&lt;/Reference&gt; 在網路上也搜尋到相關文章討論似乎是 Visual Studio Bug 導致 這位仁兄也碰到一樣問題 他開啟了一個新專案 Nuget 安裝 System.Net.Http v4.3.3 建置時 System.Net.Http 參考都還是來自於 Package 資料夾底下 Nuget 安裝 System.Collections.Immutable v1.4.0 建置時 System.Net.Http 參考就跑到 C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Enterprise\\MSBuild\\Microsoft\\Microsoft.NET.Build.Extensions\\net461\\lib\\System.Net.Http.dll 底下 討論串System.Net.Http v4.2.0.0 being copied/loaded from MSBuild tooling 解決方法檢查 Microsoft.NET.Build.Extensions 資料夾底下的 dll 版本為 4.2.0.0 ，而 Nuget System.Net.Http 4.3.2 的 dll 版本則為 4.1.1.1 ，這也是間接導致發生此錯誤的原因。 但 Reference HintPath也沒寫錯，VS 裡面也沒辦法調整 dll 位置 ， 最後索性直接刪除 Microsoft.NET.Build.Extensions 資料夾底下的 System.Net.Http ，重新建置後 dll 就重新指向 Package了，此問題得到解決 世界又再一次恢復了和平，!@#$% 參考文章 MIssing method in System.Web.Http.ApiController.get_Request() System.Net.Http package 4.3.2 - redirect to 4.2.0.0, assembly loading failure","categories":[],"tags":[{"name":"神奇事件","slug":"神奇事件","permalink":"https://toyo0103.github.io/tags/%E7%A5%9E%E5%A5%87%E4%BA%8B%E4%BB%B6/"}]},{"title":"【英文】About time","slug":"【英文】About time","date":"2018-10-31T14:49:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2018/10/31/【英文】About time/","link":"","permalink":"https://toyo0103.github.io/2018/10/31/%E3%80%90%E8%8B%B1%E6%96%87%E3%80%91About%20time/","excerpt":"","text":"這篇是要記錄關於一些時間的用法 On time『片語』 準時; 準點 例句 ： The train is always on time. 這班火車總是非常準時 Ruth never arrives office on time. 魯斯總是沒有準時到公司 In time『片語』 即時;最後 例句 ： I arrived at the office in time for the meeting. 我及時趕上了公司的會議 I finished the test in time 我在最後一秒完成考試 Time off『片語』 請假;休假 例句 ： I have some time off in July, so I’m going to the beach. 我在7月有一些假日，所以我應該會去海邊 I can’t take time off to go to Iceland 我不能請假去冰島 Time out『片語』 暫停;休息時間 例句 ： I need to take some time out( time off ). I’ve been very stressed at work recently. 我需要一些休息時間.最近工作壓力太大 About time『片語』 是時候了 例句 ： It’s about time to go to Iceland. 是時候該去冰島了 Spend time花時間 例句 : I’m going to spend some time with my grandmother at the weekend. 我這週末會花些時間陪祖母 Kill time殺時間 例句： I love to kill time in the afternoon by reading a good book. 我喜歡花整個下午的時間讀本好書 Waste time浪費時間 例句 : I waste so much time using the internet on my phone. 我浪費很多時間在用手機上網 Pressed for time『片語』 時間緊迫 例句 ： Sorry, I can’t talk at the moment, I’m a bit pressed for time. 抱歉, 我現在無法說話, 因為我時間有點緊迫 Save time『片語』 節省時間 例句 ： You can save time by using an electronic dictionary. 用電子辭典可以替你省下很多時間","categories":[],"tags":[{"name":"英文學習","slug":"英文學習","permalink":"https://toyo0103.github.io/tags/%E8%8B%B1%E6%96%87%E5%AD%B8%E7%BF%92/"}]},{"title":"【英文】Down the line","slug":"【英文】Down the line","date":"2018-10-24T07:45:00.000Z","updated":"2022-08-09T13:36:17.097Z","comments":true,"path":"2018/10/24/【英文】Down the line/","link":"","permalink":"https://toyo0103.github.io/2018/10/24/%E3%80%90%E8%8B%B1%E6%96%87%E3%80%91Down%20the%20line/","excerpt":"","text":"幾天前聽強者我同事上課提到寫部落格跟筆記的重要，想一想的確自己這樣斷斷續續也寫了 5~6 年左右，漸漸也陷入了一種迷失之中 這篇的內容隨便google就有答案了還需要寫嗎？ 但忘了最初寫部落格的初衷不是為了給誰看，而是想記錄遇到的難題跟解決的方法，幫助自己能快速查找並系統的學習解。我的部落格其實也沒啥人看，不知道有啥好包袱的 重點一直都不在有沒有人想看，而是我從中又學到了什麼，所以打算來寫幾篇會長期更新的學習筆記，可能包含 AWS、英文、日文..等。希望幾年後，這些會成為自己的能量與成長的基石。 Down the line未來從字面解釋就是「沿著線往下」，有過段時間、未來的意思， 例句 ： Pick one OS for your production set-up. No need to get master of every OS out there. It would make your job diffcult down the line. 選一種 OS 做為你生產的設置，你不需要精通每一種 OS ，這只會讓你之後的工作變得困難。 If you don’t learn English now , you will get many problems down the line. 如果你現在不學習英文, 那你將來會碰到許多問題的 徹底、始終例句 ： Errors are to be found down the line. 錯誤總有一天會被找到的 If something should be yours , that will be yours down the line. 屬於你的,終究會是你的","categories":[],"tags":[{"name":"英文學習","slug":"英文學習","permalink":"https://toyo0103.github.io/tags/%E8%8B%B1%E6%96%87%E5%AD%B8%E7%BF%92/"}]},{"title":"【.Net Core】AWS Lambda + Chrome Headless + Snapshot","slug":"AWS_Lambda_Chrome_HeadLess","date":"2018-10-11T09:58:00.000Z","updated":"2022-08-09T13:36:17.076Z","comments":true,"path":"2018/10/11/AWS_Lambda_Chrome_HeadLess/","link":"","permalink":"https://toyo0103.github.io/2018/10/11/AWS_Lambda_Chrome_HeadLess/","excerpt":"","text":"2018-10-25 更新 :DotNet Core 版本已經找出解決方案了，更新在最下面注意 !! 這篇的結論是 DotNet Core + Selenium + Chrome headless + AWS Lambda 執行是失敗的，所以如果不想看失敗案例的可以直接跳過了，寫下來是因為過程踩了太多雷想記錄一下 ，如果想要簡單一點的作法，建議採用 NodeJs + Chrome Headless + AWS Lambda 的解決方案，幾乎不用什麼調整即可使用。NodeJs 版本參考: adieuadieu/serverless-chrome 情境近期公司希望將訂單快照從 PhantomJS 改成 Chrome Headless 來實作，然後放到 AWS Lambda 上透過 AWS SQS 來觸發，達成 Serverless 的架構。 隨著 Chrome Headless 的推出，PhantomJS 也宣布停止更新了，想當年也跟它奮戰許久，又一滴時代的眼淚阿，而要能在 Lambda 上執行，則必須是能在 Linux 上執行的程式，所以 .Net Core 成為這次的選擇，為了不要每次改程式都要佈署到 Lambda 上才能測試(跑一次大概5分鐘)，所以透過 Docker 模擬 AWS Lambda 的環境直接在本機測試。 環境安裝DotNet Core 2.1 : 下載Docker for Windows : 下載 實作因為大量使用到 AWS SDK，查找官方 API 文件會更清楚些，所以本篇不著重在程式內容本身，只會帶到自己覺得關鍵的地方。 建立 .Net Core 類別庫專案請選擇 .Net Core &gt; 類別庫 (.Net Core) 安裝 AWS 相關套件 實作 SQSHandler因為是接收 SQS 來的命令，所以我建立了一支類別 SQSHandler ，並且寫了一個名為 Snapshot 的方法 1234567891011121314151617/// &lt;summary&gt;/// 執行快照/// &lt;/summary&gt;/// &lt;param name=&quot;sqsEvent&quot;&gt;The SQS event.&lt;/param&gt;/// &lt;returns&gt;執行結果&lt;/returns&gt;public async Task&lt;ResponseEntity&gt; Snapshot(SQSEvent sqsEvent)&#123; ... var record = sqsEvent.Records.First(); var parameter = JsonConvert.DeserializeObject&lt;SqsEventBodyEntity&gt;(record.Body); //// 拍照 snapshotService.Do(parameter.TSCode, parameter.SalePageId); ... &#125; 要接收 SQS 來的命令， AWS SDK 有提供 SQSEvent 類別，傳入自訂的參數會放在 Records 中，我們是將要拍照的參數用 Json 組起來後透過 SQS 拋進來，所以讀出 Records 後返解 Json String 為 Object ，然後拋給實作的SnapshotServiece。 Snapshot 這個方法回傳值為自定義的，可以依照自己需求調整，避免誤會所以特別說明一下 12345678/// &lt;summary&gt;/// 執行快照/// &lt;/summary&gt;/// &lt;param name=&quot;sqsEvent&quot;&gt;The SQS event.&lt;/param&gt;/// &lt;returns&gt;執行結果&lt;/returns&gt;public bool Snapshot(SQSEvent sqsEvent)&#123;&#125; Chrome Headless什麼是 Chrome Headless ,簡單說就是透過無介面的方式要求Chrome執行一些快照、讀取頁面的服務。 為了能夠執行驅動 Chrome，所以這邊安裝 Selenium 來輔助 Selenium 還需要搭配 Chorme Driver 來操作 Chrome，所以需要先去http://chromedriver.chromium.org/下載，但需要特別注意的是要下載 Linux64 的版本，因為 AWS Lambda 是 Linux 環境 實作這邊將下載回來的 Chrome Driver 放在 Root 的資料夾，所以在建立 ChromeDriver Instance 需要告訴它 Driver的位置 123456789//chrome headless的參數ChromeOptions options = new ChromeOptions();options.AddArgument(&quot;no-sandbox&quot;);options.AddArgument(&quot;headless&quot;);//取得Driver的位置var root = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);var driver = new ChromeDriver(root, options); 拍照 123456789101112131415161718192021... //等待Timeout的設定WebDriverWait _wait = new WebDriverWait(driver, new TimeSpan(0, 0, 10));//要連的網址driver.Navigate().GoToUrl(targetUrl);//尋找要拍的Element Classvar targetElement = _wait.Until&lt;IWebElement&gt;(d =&gt; driver.FindElement(By.ClassName(targetElementClass)));//因為要拍的區塊可能超過預設螢幕大小，所以這邊抓到Element後將它的寬高設定給Chrome Windows Sizedriver.Manage().Window.Size = new Size(targetElement.Size.Width, targetElement.Size.Height);// 拍照Screenshot screenShot = ((ITakesScreenshot)driver).GetScreenshot();//處理圖片存到哪邊，我是存到S3，但因為不是本篇重點所以省略後面的程式碼var imgStream = new MemoryStream(screenShot.AsByteArray, 0, screenShot.AsByteArray.Length);... Docker 測試打開 Power Shell，先確定已正確安裝 Docker 1$ docker --version 將目錄移到 .csproj 那層，然後執行 1$ dotnet publish -c release -r linux-x64 dotnet publish command : 文件 如果發行成功應該可以在 \\bin\\release\\netcoreapp2.1\\linux-x64\\publish 找到發行好的檔案 透過 Docker Image 測試執行 1$ cat test.json | docker run -v $&#123;PWD&#125;/bin/QA/netcoreapp2.1/publish:/var/task/ -i -e DOCKER_LAMBDA_USE_STDIN=1 lambci/lambda:dotnetcore2.1 xxx.Slsa.Snapshot.Console::xxx.Slsa.Snapshot.Console.SqsHandler::Snapshot 解釋一下 Command cat test.json : 這是拿來模擬 SQS 的呼叫時傳遞的參數檔案，檔案內容如下，我會一直替換Body 的值來測試程式是否正確去拍我要求拍的頁面，所以可以理解成是把檔案讀取後丟到後面的指令執行。 123456789101112131415161718192021&#123;&quot;Records&quot;:[&#123;&quot;messageId&quot;:&quot;xxxxxxxx&quot;,&quot;receiptHandle&quot;:&quot;xxxxx&quot;,&quot;body&quot;:&quot;&#123;\\&quot;SalePageId\\&quot;: 12345,\\&quot;TSCode\\&quot;: \\&quot;abcde\\&quot;&#125;&quot;,&quot;attributes&quot;:&#123;&quot;ApproximateReceiveCount&quot;:&quot;x&quot;,&quot;SentTimestamp&quot;:&quot;xxxx&quot;,&quot;SenderId&quot;:&quot;xxxx&quot;,&quot;ApproximateFirstReceiveTimestamp&quot;:&quot;xxxxxx&quot;&#125;,&quot;messageAttributes&quot;:&#123;&#125;,&quot;md5OfBody&quot;:&quot;xxxxx&quot;,&quot;eventSource&quot;:&quot;aws:sqs&quot;,&quot;eventSourceARN&quot;:&quot;xxxxxx&quot;,&quot;awsRegion&quot;:&quot;xxxxxx&quot;&#125;]&#125; docker run -v $&#123;PWD&#125;/bin/QA/netcoreapp2.1/publish:/var/task/ : ${PWD} 為預設變數，表示目前的目路位置，加上 /bin/QA/netcoreapp2.1/publish 後就是剛剛發行的檔案位置，mount 到 Docker container 裡面的 /var/task 位置，而這也是 lambda 預設執行的位置 lambci/lambda:dotnetcore2.1 : Docker Image 的名稱，這是別人已經做好跟 AWS lambda 一模一樣環境的 Image ，透過它來建置我們要的環境做測試 xxx.Slsa.Snapshot.Console::xxx.Slsa.Snapshot.Console.SqsHandler::Snapshot : 格式為 Assembly Name :: Class Name :: FunctionName，表示請它執行剛剛我們開發的 SQSHandler 的 Snapshot 方法 找不到 Chrome binary 錯誤這時候應該會發生找不到 Chrome binary 的錯誤，原因是在 Lambda 的環境並不能安裝 Chrome，所以 Chrome Driver 想去預設環境找 Chrome 核心來執行時會找不到。 整個驅動 Chrome 的流程Selenum → Chrome Driver → Chrome binary 還好已經有網路上的大神解決了這問題，serverless-chrome這個 Project 就是將 Chrome 封裝成 Binary 檔後可以打包進專案中，在 Power Shell 執行以下指令來取得 Chrome Binary 123$ docker run -dt --rm --name headless-chromium adieuadieu/headless-chromium-for-aws-lambda:stable$ docker cp headless-chromium:/bin/headless-chromium ./$ docker stop headless-chromium 在目前 Power Shell 指的資料底下可以找到 headless-chromium 檔案，將這個檔案加到專案中 123456789101112//chrome headless的參數ChromeOptions options = new ChromeOptions();options.AddArgument(&quot;no-sandbox&quot;);options.AddArgument(&quot;headless&quot;);//取得Driver的位置var root = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);//指定Chrome Binary位置options.BinaryLocation = Path.Combine(root, &quot;headless-chromium&quot;);var driver = new ChromeDriver(root, options); 做到這邊再執行剛剛的指令應該可以正常拍照了。 掃雷亂碼問題因為 Chrome Binary 輕量化，所以作者並沒有把中文/日文/韓文包進來，所以拍一下遇到上述文字都會出現亂碼 詳細討論串Include Chinese/Japanese/Korean/more fonts in headless Chrome binary #49 依據該討論串下方的回應，已經有對應的解決方案 1.將需要的字典檔下載回來放在 Root 的 .fonts 資料夾中 2.將 $HOME 環境變數指到 /var/task 建立一個檔案 env.variable 裡面寫 1HOME=/var/task 接著透過 Docker Container 執行 1$ cat test.json | docker run --env-file ./env.variable -v $&#123;PWD&#125;/bin/QA/netcoreapp2.1/publish:/var/task/ -i -e DOCKER_LAMBDA_USE_STDIN=1 lambci/lambda:dotnetcore2.1 xxx.Slsa.Snapshot.Console::xxx.Slsa.Snapshot.Console.SqsHandler::Snapshot 這樣拍出來的中文、韓文、日文的畫面就不會亂碼了 權限將程式打包好放到 AWS Lambda 上面跑，隨即碰到以下錯誤 123456789101112Permission denied: Win32Exceptionat Interop.Sys.ForkAndExecProcess(String filename, String[] argv, String[] envp, String cwd, Boolean redirectStdin, Boolean redirectStdout, Boolean redirectStderr, Boolean setUser, UInt32 userId, UInt32 groupId, Int32&amp; lpChildPid, Int32&amp; stdinFd, Int32&amp; stdoutFd, Int32&amp; stderrFd, Boolean shouldThrow)at System.Diagnostics.Process.StartCore(ProcessStartInfo startInfo)at System.Diagnostics.Process.Start()at OpenQA.Selenium.DriverService.Start()at OpenQA.Selenium.Remote.DriverServiceCommandExecutor.Execute(Command commandToExecute)at OpenQA.Selenium.Remote.RemoteWebDriver.Execute(String driverCommandToExecute, Dictionary`2 parameters)at OpenQA.Selenium.Remote.RemoteWebDriver.StartSession(ICapabilities desiredCapabilities)at OpenQA.Selenium.Remote.RemoteWebDriver..ctor(ICommandExecutor commandExecutor, ICapabilities desiredCapabilities)at OpenQA.Selenium.Chrome.ChromeDriver..ctor(ChromeDriverService service, ChromeOptions options, TimeSpan commandTimeout)at ......... 原因是 Lambda 的 /var/task 是 read-only，所以要執行 Chrome Driver 與 Chrome Binary 時會沒有權限，只好用很 tricky 的方式，先把 Chrome Driver 與 Chrome Binary 搬到 /tmp 底下再授予權限 12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;summary&gt;/// Isinitialeds this instance./// &lt;/summary&gt;private void Initial()&#123; if(!File.Exists(&quot;/tmp/chromedriver&quot;)) &#123; File.Copy(&quot;/var/task/chromedriver&quot;, &quot;/tmp/chromedriver&quot;, true); Exec(&quot;chmod +x /tmp/chromedriver&quot;); &#125; if(!File.Exists(&quot;/tmp/headless-chromium&quot;)) &#123; File.Copy(&quot;/var/task/headless-chromium&quot;, &quot;/tmp/headless-chromium&quot;, true); Exec(&quot;chmod +x /tmp/headless-chromium&quot;); &#125;&#125;/// &lt;summary&gt;/// Executes the specified command./// &lt;/summary&gt;/// &lt;param name=&quot;cmd&quot;&gt;The command.&lt;/param&gt;private void Exec(string cmd)&#123; var escapedArgs = cmd.Replace(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;); var process = new Process &#123; StartInfo = new ProcessStartInfo &#123; RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true, WindowStyle = ProcessWindowStyle.Hidden, FileName = &quot;/bin/bash&quot;, Arguments = $&quot;-c \\&quot;&#123;escapedArgs&#125;\\&quot;&quot; &#125; &#125;; process.Start(); process.WaitForExit();&#125; 123456789//chrome headless的參數ChromeOptions options = new ChromeOptions();options.AddArgument(&quot;no-sandbox&quot;);options.AddArgument(&quot;headless&quot;);//指定Chrome Binary位置options.BinaryLocation = &quot;/tmp/headless-chromium&quot;;var driver = new ChromeDriver(&quot;/tmp&quot;, options); CreatePlatformSocket() Operation not permitted (1)接著遇到下個問題是， ChromeDriver Init 起來時會去呼叫 http://localhost:xxxx/Session ，而這時後就會因為沒有權限而失敗，但這個在 NodeJs 的版本不會發生，查了 Selenium 的 Source Code 也看不出原因，找了相當多的討論串，目前似乎依然無解，也是在這一題後不得不先放棄，改採用相容較高的 NodeJs 版本 相關討論串The HTTP request to the remote WebDriver server for URL http://localhost:42607/session timed out after 60 seconds.Message: OpenQA.Selenium.WebDriverException : The HTTP request to the remote WebDriver server for URL when using Chrome Headles #6234 2018-10-25 更新 在產生 ChromeDriver 的時候加上 disable-dev-shm-usage 、 single-process 兩個參數可以解決這個問題， 12345options.AddArguments(&quot;no-sandbox&quot;, &quot;headless&quot;, &quot;disable-dev-shm-usage&quot;, &quot;disable-gpu&quot;, &quot;single-process&quot;, &quot;no-zygote&quot;, &quot;hide-scrollbars&quot;, &quot;lang=zh-TW,zh&quot;);options.BinaryLocation = &quot;/tmp/headless-chromium&quot;;var driver = new ChromeDriver(&quot;/tmp&quot;, options); 其中 single-process 為 Chromium 的模式之一，詳細可以參考文件 [The Chromium Projects] - Process ModelsList of Chromium Command Line Switches disable-dev-shm-usage 1To fix, run the container with docker run --shm-size&#x3D;1gb to increase the size of &#x2F;dev&#x2F;shm . Since Chrome 65, this is no longer necessary. Instead, launch the browser with the --disable-dev-shm-usage flag 會找到這個解法是因為去看了 serverless-chrome 的 source code 發現他是這樣寫的，但這樣搭配為什麼會正常，說實在的目前我還看不出為什麼 ， 只能等之後讀更多文件再看看有沒有辦法解答。 加上這兩個參數後 Lambda 上面雖然還是會報 CreatePlatformSocket() Operation not permitted (1) 錯誤，但減少到只剩下兩次，就正常執行了 補充 : 環境問題最後雖然我們採用了 NodeJs 的版本，但還是踩了一個小小的雷，那就是要把檔案壓縮成 zip 檔放到 AWS Lambda 時，相同的程式用我的電腦壓出來是不能執行，但同事壓出來的 zip 檔案卻可以，經過測試後發現，因為我的 Mac 語系環境是中文，壓縮出來時預設會是封裝.zip，不管是中文的的放上去，或是改了檔名後放上去都會錯誤。 只能下 command 指定壓縮出來的檔名才可解決這個問題 1$ zip -r -j ./destination/pacakge ./source 相同的，在 Windows 壓出來放上去一樣會壞掉，推測是相同原因….真的是雷到你不要不要的 2018-10-25 更新 網路上找到有人討論 Windows 壓縮後放上去會壞掉的問題，解法是請安裝 7zip，並且直接到 root 層執行壓縮，壓完後解壓就要是Root，不要再包一層資料夾，另外…只能用 GUI 執行壓縮，我用 PowerShell 壓縮一樣不行，不知道為什麼(暈)，難怪論壇開宗明義第一句話就是，不要用 Windows ，Linux base 的東西跟 windows 真的是很不合… Lambda disdains ZIP files compressed with PowerShell","categories":[],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://toyo0103.github.io/tags/AWS/"},{"name":"Lambda","slug":"Lambda","permalink":"https://toyo0103.github.io/tags/Lambda/"},{"name":"dotnet core","slug":"dotnet-core","permalink":"https://toyo0103.github.io/tags/dotnet-core/"}]},{"title":"【生產力】自訂Google Search Engine","slug":"自訂Google_SearchEngine","date":"2018-09-14T02:04:00.000Z","updated":"2022-08-09T13:36:17.098Z","comments":true,"path":"2018/09/14/自訂Google_SearchEngine/","link":"","permalink":"https://toyo0103.github.io/2018/09/14/%E8%87%AA%E8%A8%82Google_SearchEngine/","excerpt":"","text":"常常會有需要查詢英文、日文單字的情形，以前都會先打開Yahoo或是Google的辭典然後查詢單字，直到今天學到了自訂Chrome Search Engine實在太好用了，所以決定寫下來記錄一下 #設定首先先打開Chrome瀏覽器，在網址列輸入 1chrome:&#x2F;&#x2F;settings&#x2F;searchEngines 接著點選**[新增]** 搜尋引擎 ​ 讓自己識別的名稱，可以隨便寫 關鍵字 ​ 這個是你啟動自訂Google Search Engine的關鍵字，請寫自己好記的 網址 告訴Chrome如何用你下的關鍵字去搜尋，以Google翻譯為例，當你輸入apple時網址會變成如圖，而紅框處就是我們要替換的地方，請以%s替代 #使用之後只要我在Chrome瀏覽器輸入gdic+空格，就會變成這樣 再次輸入Apple後Enter就會跑到Google翻譯頁並查好了","categories":[],"tags":[{"name":"生產力","slug":"生產力","permalink":"https://toyo0103.github.io/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"}]},{"title":"什麼是BOM(Byte-order mark)?","slug":"byte_order_mark","date":"2018-08-23T01:44:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2018/08/23/byte_order_mark/","link":"","permalink":"https://toyo0103.github.io/2018/08/23/byte_order_mark/","excerpt":"","text":"最近開發了一支收集資訊然後將資料轉成Json檔案給其它單位讀取，但收到對口單位回報Json格式不正確。但我將檔案內容貼到線上的Json解析網站，或是自己肉眼判斷都覺得格式沒問題，所以執行了一次對方的解析程式，錯誤訊息如下。 在字串0的位置有錯誤 打開我提供的檔案，字串0也就是最前面感覺很正常… 接著我將這段錯誤訊息貼Notepad++，轉成Hex碼來看看究竟是藏了什麼東西 #什麼是BOM把ef bb bf拿去Google最後查到了Wiki-位元組順序記號 節錄Wiki位元組順序記號（英語：byte-order mark，BOM）是位於碼點U+FEFF的統一碼字元的名稱。當以UTF-16或UTF-32來將UCS/統一碼字元所組成的字串編碼時，這個字元被用來標示其位元組序。它常被用來當做標示檔案是以UTF-8、UTF-16或UTF-32編碼的記號。 #解法而會塞入位元組序是因為在寫檔案時這樣指定編碼 123456using (StreamWriter file = new StreamWriter( new FileStream(path,FileMode.OpenOrCreate,FileAccess.Write), Encoding.UTF8))&#123; .....&#125; 只要將寫改改成 new UTF8Encoding(false) 即可 123456using (StreamWriter file = new StreamWriter( new FileStream(path, FileMode.OpenOrCreate, FileAccess.Write), new UTF8Encoding(false)))&#123; .....&#125;","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://toyo0103.github.io/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"【Entity Framework】The connection was not closed. The connection's current state is connecting","slug":"【Entity Framework】The_connection_was_not_closed_The_connection_s_current_state_is_connecting","date":"2018-07-24T03:28:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2018/07/24/【Entity Framework】The_connection_was_not_closed_The_connection_s_current_state_is_connecting/","link":"","permalink":"https://toyo0103.github.io/2018/07/24/%E3%80%90Entity%20Framework%E3%80%91The_connection_was_not_closed_The_connection_s_current_state_is_connecting/","excerpt":"","text":"#前情提要不定時、不定量、不特定API跳出**【System.InvalidOperationException】 - The connection was not closed. The connection’s current state is connecting.**錯誤，這個錯誤以前公司也遇到過，當時研判是Entity Framework與Unity套件生命週期的問題，當時專案不算太大又一直找不到確切解決方案，所以索性將Repository Layer整個用Dapper改寫讓問題得以解決了。 當時的筆記【Entity Framework】DBContext Dispose與否，與DB的連線數是否有關係 但這次退無可退，再次印證了一句話 你不解決問題，問題就會解決你 &nbsp; &nbsp; #分析透過Elmah的Log分析，發現共同點都壞在一支Token驗證的DelegatingHandler裡面，因為呼叫每支API都會經過這，可以解釋為何壞在不特定API。 而關鍵在其中的一行 12var Service = AutofacConfig.Container.Resolve&lt;ISupplierApiProfileService&gt;();var Profile = Service.GetSupplierApiProfileByToken(token); 透過Autofac Container取得ISupplierApiProfileService，猜測當時這樣撰寫是希望每次產生新的Service的實體來使用，在這之前先一下看一下整體的架構 而每個實體分別Autofac註冊的生命週期為 這導致了一個結果，因為Actofac Container為Singleton的實體，透過他Resolve出來的DBContext (InstancePerLifetimeScope)也會變成Singleton的生命週期。 而Entity Framework非Thread Safe的設計，所以如果不同Thread共用同一個DBContext時，如果前一個交易尚未完成，撞在一起時就會有機率產生這個錯誤 相關討論 https://github.com/aspnet/EntityFrameworkCore/issues/3887 #解法而DBContext會設定為InstancePerLifetimeScope的生命週期是希望DBContext隨著每次Request產生與消滅(亦即每個Request只會產生一次DBContext實體)，如果後續應用Transaction才不會發生問題，但在DelegatingHandler這邊的應用情境卻導致了Singleton的情況。 BeginLifetimeScope 官方文件 - Working with Lifetime Scopes Autofac提供給使用者產生一個動態的生命週期的方法，所有透過這個生命週期產生的實體會隨著它的消滅一併被Disposed掉，使用方式如下 12345using (var scope = AutofacConfig.Container.BeginLifetimeScope())&#123; var Service = scope.Resolve&lt;ISupplierApiProfileService&gt;(); var Profile = Service.GetSupplierApiProfileByToken(token);&#125; 這樣可以確保在DelegatingHandler裡面產生的DBContext不會變成Singleton，也不用動到最基底DBContext InstancePerLifetimeScope的生命週期，確保了每次Request共用同一個DBContext。 上線後觀察Elmah，確認這個伴隨著我將近三年的問題終於徹底消滅了，可喜可賀 可喜可賀。","categories":[],"tags":[{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://toyo0103.github.io/tags/Entity-Framework/"},{"name":"AutoFac","slug":"AutoFac","permalink":"https://toyo0103.github.io/tags/AutoFac/"}]},{"title":"【Autofac】生命週期","slug":"【Autofac】生命週期","date":"2018-07-12T08:06:00.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2018/07/12/【Autofac】生命週期/","link":"","permalink":"https://toyo0103.github.io/2018/07/12/%E3%80%90Autofac%E3%80%91%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F/","excerpt":"","text":"2019/08/21 補充 ： 將之前在公司分享的 Demo Code 整理並放到 Github，有興趣的可以下載來試試看。 #什麼是Autofac用來實作控制反轉(Inversion of Control, IoC)的套件,幫我們管理抽象與實體之間的對應關係, 除了Autofac之外還有Unity等其它套件可以實作,但概念都大同小異。 Autofac官網 #Autofac的生命週期有哪些 InstancePerDependency SingleInstance InstancePerLifetimeScope InstancePerRequest 下面會一一解說跟實作測試,在這之前先準備一個WebAPI的專案,並且將Autofac與Autofac WebAPI2裝起來 然後在App_Start資料夾新增AutofacConfig類別 1234567891011121314151617181920public static class AutofacConfig&#123; public static IContainer Container &#123; get; private set; &#125; public static void BuildContainer() &#123; var builder = new ContainerBuilder(); Register(builder); Container = builder.Build(); GlobalConfiguration.Configuration.DependencyResolver = new AutofacWebApiDependencyResolver(Container); &#125; private static void Register(ContainerBuilder builder) &#123; var assembly = typeof(AutofacConfig).Assembly; builder.RegisterApiControllers(assembly); &#125;&#125; Global.asax加上這行 1234567891011protected void Application_Start()&#123; //Autofac Init AutofacConfig.BuildContainer(); AreaRegistration.RegisterAllAreas(); GlobalConfiguration.Configure(WebApiConfig.Register); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles);&#125; InstancePerDependency Also called ‘transient’ or ‘factory’ in other containers. Using per-dependency scope, a unique instance will be returned from each request for a service. 每次呼叫都回傳一個新的實體,產生的Instance隨著呼叫者的生命週期消滅 123456789101112public class LiftTimeModel&#123; public static int Count; public int ID &#123; get; private set; &#125; public LiftTimeModel() &#123; Count++; this.ID = LiftTimeModel.Count; &#125;&#125; AutofacConfig 123456789101112public static class AutofacConfig&#123; ....省略.... private static void Register(ContainerBuilder builder) &#123; var assembly = typeof(AutofacConfig).Assembly; builder.RegisterApiControllers(assembly); builder.RegisterType&lt;LiftTimeModel&gt;().InstancePerDependency(); &#125;&#125; TestController 1234567891011121314151617public class TestController : ApiController&#123; private LifeTimeModel _lifeTimeModel; public TestController(LifeTimeModel lifeTimeModel) &#123; this._lifeTimeModel = lifeTimeModel; &#125; // GET api/&lt;controller&gt; public string Get() &#123; StringBuilder sb = new StringBuilder(); sb.AppendLine(string.Concat(&quot;PerDependencyModel ID :&quot;, this._lifeTimeModel.ID)); return sb.ToString(); &#125;&#125; 呼叫/api/test會發現隨著呼叫的次數增加，LifeTimeModel ID 也會一直增加，因為每次Request呼叫開始都會產生新的TestController Instance，隨著Request結束TestController也會被消滅，依賴在它身上的LifeTimeModel也隨之產生與消滅。而每次產生新的LifeTimeModel Instance都會在建構子將static的Count加1，這是數字一直增加的緣故。 此外Autofac預設使用的生命週期即為InstancePerDependency，所以這兩行的意思是一樣的 12builder.RegisterType&lt;LiftTimeModel&gt;().InstancePerDependency();builder.RegisterType&lt;LiftTimeModel&gt;(); SingleInstance This is also known as ‘singleton.’ Using single instance scope, one instance is returned from all requests in the root and all nested scopes. 不管呼叫幾次都只有產生一個Instance，以WebAPI為例只有當Application Shut down的時候會消滅 123456789101112public static class AutofacConfig&#123; ...省略.... private static void Register(ContainerBuilder builder) &#123; var assembly = typeof(AutofacConfig).Assembly; builder.RegisterApiControllers(assembly); //改成SingleInstance builder.RegisterType&lt;LifeTimeModel&gt;().SingleInstance(); &#125;&#125; 會發現不管呼叫/api/test幾次ID永遠都是1,原因是LifeTimeModel只會產生一次 InstancePerLifetimeScope This scope applies to nested lifetimes. A component with per-lifetime scope will have at most a single instance per nested lifetime scope. 這個非常容易跟InstancePerRequest搞混,簡單理解方式就是,每個Scope只會最多產生一個Instance。 所以在Root只會產生一個，在Autofac WebRequest只會產生一組 新增TestPerLifetimeScopeModel做為觀察標的 12345678public class TestPerLifetimeScopeModel&#123; public LifeTimeModel LifeTimeModel &#123; get; set; &#125; public TestPerLifetimeScopeModel(LifeTimeModel lifeTimeModel) &#123; this.LifeTimeModel = lifeTimeModel; &#125;&#125; 1234567891011121314public static class AutofacConfig&#123; ...省略.... private static void Register(ContainerBuilder builder) &#123; var assembly = typeof(AutofacConfig).Assembly; builder.RegisterApiControllers(assembly); builder.RegisterType&lt;TestPerLifetimeScopeModel&gt;(); //改成InstancePerLifetimeScope builder.RegisterType&lt;LifeTimeModel&gt;().InstancePerLifetimeScope(); &#125;&#125; 1234567891011121314151617181920public class TestController : ApiController&#123; private LifeTimeModel _lifeTimeModel; private TestPerLifetimeScopeModel _testPerLifetimeScopeModel; public TestController(LifeTimeModel lifeTimeModel, TestPerLifetimeScopeModel testPerLifetimeScopeModel) &#123; this._lifeTimeModel = lifeTimeModel; this._testPerLifetimeScopeModel = testPerLifetimeScopeModel; &#125; // GET api/&lt;controller&gt; public string Get() &#123; StringBuilder sb = new StringBuilder(); sb.AppendLine(string.Concat(&quot;PerDependencyModel ID :&quot;, this._lifeTimeModel.ID)); sb.AppendLine(string.Concat(&quot;TestPerLifetimeScopeModel&#x27;s LifeTimeModel ID :&quot;, this._testPerLifetimeScopeModel.LifeTimeModel.ID)); return sb.ToString(); &#125;&#125; 會發現兩個得到的ID都是相同的，原因是Autofac WebRequest Scope中，一次Request只會產生一組LifeTimeModel，所以ID都會一樣 更進一步說，如果我們今天有使用WebAPI DelegatingHandler，因為Handler只會在Application起來時產生一次Instance，所以在這產生的LifeTimeModel也會變成Singleton *註1 12345678910public class TestHandler: DelegatingHandler&#123; protected override Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) &#123; var Model = AutofacConfig.Container.Resolve&lt;LifeTimeModel&gt;(); var TestID = Model.ID; return base.SendAsync(request, cancellationToken); &#125;&#125; 12345678910111213141516171819public static class WebApiConfig&#123; public static void Register(HttpConfiguration config) &#123; // Web API 設定和服務 // Web API 路由 config.MapHttpAttributeRoutes(); // 註冊Handler config.MessageHandlers.Add(new TestHandler()); config.Routes.MapHttpRoute( name: &quot;DefaultApi&quot;, routeTemplate: &quot;api/&#123;controller&#125;/&#123;id&#125;&quot;, defaults: new &#123; id = RouteParameter.Optional &#125; ); &#125;&#125; 會發現Handler裡面的ID永遠拿到的都是1，而API回傳的結果則會慢慢增加，兩邊是各自獨立的實體 註1這邊觀念有錯誤，會Singleton的原因不在於DelegatingHandler的問題，而是因為使用AutofacConfig.Container來產生實體，Container是Root層級也是Singleton，請它產生LifeTimeModel (InstancePerLifetimeScope)，所以會變成Singleton。交叉測試的方法是把這段 AutofacConfig.Container.Resolve()放到Controller的Action之中，產出來的實體也會是Singleton，所以癥結在AutofacConfig.Container而非DelegatingHandler或Controller Action的生命週期，特此更正 InstancePerRequest Some application types naturally lend themselves to “request” type semantics, for example ASP.NET web forms and MVC applications. In these application types, it’s helpful to have the ability to have a sort of “singleton per request.” 基本上跟InstancePerLifetimeScope認知是一致的，唯一差別是它無法Root Scope產生Instance，因為生命週期隨著Request產生與消滅，不會有Singleton的可能，所以如果改成InstancePerRequest，剛剛的TestHandler就會產生Exception。 Unity跟Autofac的生命週期一直都不是很好懂所以之前也踩了不少雷，筆記起來希望對大家能有幫助 補充產生在AutofacWebRequest Scope的實體，一定會在每次Request結束後被消滅 參考文件WebAPI, Autofac, and Lifetime Scopes","categories":[],"tags":[{"name":"AutoFac","slug":"AutoFac","permalink":"https://toyo0103.github.io/tags/AutoFac/"}]},{"title":"【生產力】Code Snippet","slug":"【生產力】Code Snippet","date":"2018-07-11T02:03:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2018/07/11/【生產力】Code Snippet/","link":"","permalink":"https://toyo0103.github.io/2018/07/11/%E3%80%90%E7%94%9F%E7%94%A2%E5%8A%9B%E3%80%91Code%20Snippet/","excerpt":"","text":"#什麼是Code Snippet從字面來看是程式碼片段，如果已經寫程式一段時間應該都有用到過，例如在Visual Studio打上Switch後按兩下Tab自動產生的程式碼就是Code Snippet功能做出來的。 所以將常常重複寫的程式碼做成Code Snippet是一件很方便的事情 #如何自訂因為寫單元測試常常需要寫3A原則,所以把它做成Code Snippet就可以重用。 12345678//// arrangevar sut = GetSystemUnderTest();var expected = true;//// actvar actual = sut.DoSomething();//// assert 建立3A Pattern.snippet的檔案打開一個記事本命名成3A Pattern，然後副檔名儲存成.snippet 撰寫內容12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;CodeSnippets xmlns=&quot;http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet&quot;&gt; &lt;CodeSnippet Format=&quot;1.0.0&quot;&gt; &lt;Header&gt; &lt;SnippetTypes&gt; &lt;SnippetType&gt;Expansion&lt;/SnippetType&gt; &lt;SnippetType&gt;SurroundsWith&lt;/SnippetType&gt; &lt;/SnippetTypes&gt; &lt;Title&gt;你的Code Snippet名稱&lt;/Title&gt; &lt;Author&gt;Steven&lt;/Author&gt; &lt;Description&gt; &lt;/Description&gt; &lt;HelpUrl&gt; &lt;/HelpUrl&gt; &lt;Shortcut&gt;你想要呼叫時的代碼&lt;/Shortcut&gt; &lt;/Header&gt; &lt;Snippet&gt; &lt;Declarations&gt; &lt;Literal Editable=&quot;true&quot;&gt; &lt;ID&gt;變數ID&lt;/ID&gt; &lt;ToolTip&gt;變數描述&lt;/ToolTip&gt; &lt;Default&gt;預設值&lt;/Default&gt; &lt;Function&gt; &lt;/Function&gt; &lt;/Literal&gt; &lt;/Declarations&gt; &lt;Code Language=&quot;csharp&quot; Delimiter=&quot;$&quot;&gt;&lt;![CDATA[ ...... 放入程式碼的地方 ...... ]]&gt;&lt;/Code&gt; &lt;/Snippet&gt; &lt;/CodeSnippet&gt;&lt;/CodeSnippets&gt; 依據上面的Template,將3A Pattern Code Snippet改成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;CodeSnippets xmlns=&quot;http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet&quot;&gt; &lt;CodeSnippet Format=&quot;1.0.0&quot;&gt; &lt;Header&gt; &lt;SnippetTypes&gt; &lt;SnippetType&gt;Expansion&lt;/SnippetType&gt; &lt;SnippetType&gt;SurroundsWith&lt;/SnippetType&gt; &lt;/SnippetTypes&gt; &lt;Title&gt;3A Pattern&lt;/Title&gt; &lt;Author&gt;Steven&lt;/Author&gt; &lt;Description&gt; &lt;/Description&gt; &lt;HelpUrl&gt; &lt;/HelpUrl&gt; &lt;Shortcut&gt;aaa&lt;/Shortcut&gt; &lt;/Header&gt; &lt;Snippet&gt; &lt;Declarations&gt; &lt;Literal Editable=&quot;true&quot;&gt; &lt;ID&gt;expected&lt;/ID&gt; &lt;ToolTip&gt;expected&lt;/ToolTip&gt; &lt;Default&gt;true&lt;/Default&gt; &lt;Function&gt; &lt;/Function&gt; &lt;/Literal&gt; &lt;Literal Editable=&quot;true&quot;&gt; &lt;ID&gt;DoSomthing&lt;/ID&gt; &lt;ToolTip&gt;DoSomthing&lt;/ToolTip&gt; &lt;Default&gt;DoSomething()&lt;/Default&gt; &lt;Function&gt; &lt;/Function&gt; &lt;/Literal&gt; &lt;/Declarations&gt; &lt;Code Language=&quot;csharp&quot; Delimiter=&quot;$&quot;&gt;&lt;![CDATA[ //// arrange var sut = GetSystemUnderTest(); var expected = $expected$; //// act var actual = sut.$DoSomthing$; //// assert ]]&gt;&lt;/Code&gt; &lt;/Snippet&gt; &lt;/CodeSnippet&gt;&lt;/CodeSnippets&gt; $變數$ , 兩個前字號中間的就是變數ID,在Snippet &gt; Declarations &gt; Literal 設定變數相關值 #匯入Visual Studio最後一步就是匯入Visual Studio中,點擊工具 &gt; 程式碼片段管理員 點擊匯入，選擇剛剛的3A Pattern.snippet檔案 匯入到My Code Snippets &gt; 完成 ，就可以看到3A Pattern了 #結果在程式碼中打aaa加兩次Tab就會呼叫出我們設定的Code Snippet 參考文章逐步解說：建立程式碼片段","categories":[],"tags":[{"name":"生產力","slug":"生產力","permalink":"https://toyo0103.github.io/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"}]},{"title":"【LeetCode】Fraction to Recurring Decimal","slug":"【LeetCode】Fraction to Recurring Decimal","date":"2018-06-27T06:41:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2018/06/27/【LeetCode】Fraction to Recurring Decimal/","link":"","permalink":"https://toyo0103.github.io/2018/06/27/%E3%80%90LeetCode%E3%80%91Fraction%20to%20Recurring%20Decimal/","excerpt":"","text":"#題目Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2Output: “0.5” Example 2: Input: numerator = 2, denominator = 1Output: “2” Example 3: Input: numerator = 2, denominator = 3Output: “0.(6)” 12345public class Solution &#123; public string FractionToDecimal(int numerator, int denominator) &#123; &#125;&#125; #解題案例一123456789101112131415[TestMethod]public void FractionToDecimalTest_輸入numerator_1_denominator_2()&#123; //arrange var sut = new Solution(); var numerator = 1; var denominator = 2; var expected = &quot;0.5&quot;; //act var actual = sut.FractionToDecimal(numerator, denominator); //assert actual.Should().Be(expected);&#125; 123456public string FractionToDecimal(int numerator, int denominator)&#123; decimal result = Convert.ToDecimal(numerator) / Convert.ToDecimal(denominator); return result.ToString();&#125; 案例二123456789101112131415[TestMethod]public void FractionToDecimalTest_輸入numerator_2_denominator_1()&#123; //arrange var sut = new Solution(); var numerator = 2; var denominator = 1; var expected = &quot;2&quot;; //act var actual = sut.FractionToDecimal(numerator, denominator); //assert actual.Should().Be(expected);&#125; 直接通過測試 案例三123456789101112131415[TestMethod]public void FractionToDecimalTest_輸入numerator_2_denominator_3()&#123; //arrange var sut = new Solution(); var numerator = 2; var denominator = 3; var expected = &quot;0.(6)&quot;; //act var actual = sut.FractionToDecimal(numerator, denominator); //assert actual.Should().Be(expected);&#125; 123456789101112131415161718192021222324252627282930313233public string FractionToDecimal(int numerator, int denominator)&#123; StringBuilder sb = new StringBuilder(); sb.Append(numerator / denominator); //餘數 var Remainder = (numerator % denominator); if (Remainder == 0) &#123; return sb.ToString(); &#125; sb.Append(&quot;.&quot;); var Map = new Dictionary&lt;int, int&gt;(); Map.Add(Remainder, sb.Length); while (Remainder != 0) &#123; sb.Append((Remainder *10) / denominator); Remainder = (Remainder * 10) % denominator; if (Map.ContainsKey(Remainder)) &#123; var Index = Map[Remainder]; //開始重複 sb.Insert(Index, &quot;(&quot;); sb.Append(&quot;)&quot;); break; &#125; Map.Add(Remainder, sb.Length); &#125; return sb.ToString();&#125; 關鍵在找出餘數相同時的那一刻，餘數開始重複代表規律產生了，因為餘數乘10等於下次的被除數，除數永遠不變的情況下將開始循環。 記錄下每次餘數當下字串的長度，當下次產生相同餘數，則從Dictionary取得上一次出現的位置補上括號即可 #解析溢位問題LeetCode測試錯誤 補上案例123456789101112131415[TestMethod]public void FractionToDecimalTest_輸入numerator_負2147483648_denominator_負1()&#123; //arrange var sut = new Solution(); var numerator = -2147483648; var denominator = -1; var expected = &quot;2147483648&quot;; //act var actual = sut.FractionToDecimal(numerator, denominator); //assert actual.Should().Be(expected);&#125; 123456789101112131415161718192021222324252627282930313233343536public string FractionToDecimal(int numerator, int denominator)&#123; StringBuilder sb = new StringBuilder(); var _numerator = Convert.ToInt64(numerator); var _denominator = Convert.ToInt64(denominator); sb.Append(_numerator / _denominator); //餘數 var Remainder = (_numerator % _denominator); if (Remainder == 0) &#123; return sb.ToString(); &#125; sb.Append(&quot;.&quot;); var Map = new Dictionary&lt;Int64, int&gt;(); Map.Add(Remainder, sb.Length); while (Remainder != 0) &#123; sb.Append((Remainder *10) / denominator); Remainder = (Remainder * 10) % denominator; if (Map.ContainsKey(Remainder)) &#123; var Index = Map[Remainder]; //開始重複 sb.Insert(Index, &quot;(&quot;); sb.Append(&quot;)&quot;); break; &#125; Map.Add(Remainder, sb.Length); &#125; return sb.ToString();&#125; 負數問題 補上案例123456789101112131415[TestMethod]public void FractionToDecimalTest_輸入numerator_負50_denominator_8()&#123; //arrange var sut = new Solution(); var numerator = -50; var denominator = 8; var expected = &quot;-6.25&quot;; //act var actual = sut.FractionToDecimal(numerator, denominator); //assert actual.Should().Be(expected);&#125; 如果運算之中有正負號時，則可能組出來的字串為 -6.-2-5，顯然這不是我們要的，要將負號在最前面優先處理，接著後面的計算都用正數來處理 結果為負數，只有在兩個數為一正一負時，當兩正或兩負算出來的皆還是會正值，可以用^(XOR)來判別 12345678910111213141516171819202122232425262728293031323334353637383940public string FractionToDecimal(int numerator, int denominator)&#123; StringBuilder sb = new StringBuilder(); //考慮負數 sb.Append((numerator &gt;= 0) ^ (denominator &gt;= 0) ? &quot;-&quot; : string.Empty); //只取正數 var _numerator =Math.Abs(Convert.ToInt64(numerator)); var _denominator = Math.Abs(Convert.ToInt64(denominator)); sb.Append(_numerator / _denominator); //餘數 var Remainder = (_numerator % _denominator); if (Remainder == 0) &#123; return sb.ToString(); &#125; sb.Append(&quot;.&quot;); var Map = new Dictionary&lt;Int64, int&gt;(); Map.Add(Remainder, sb.Length); while (Remainder != 0) &#123; sb.Append((Remainder *10) / _denominator); Remainder = (Remainder * 10) % _denominator; if (Map.ContainsKey(Remainder)) &#123; var Index = Map[Remainder]; //開始重複 sb.Insert(Index, &quot;(&quot;); sb.Append(&quot;)&quot;); break; &#125; Map.Add(Remainder, sb.Length); &#125; return sb.ToString();&#125; 被除數為0問題當被除數為0時，回傳結果應為0且無關正負 補上案例123456789101112131415[TestMethod]public void FractionToDecimalTest_輸入numerator_0_denominator_負5()&#123; //arrange var sut = new Solution(); var numerator = 0; var denominator = -5; var expected = &quot;0&quot;; //act var actual = sut.FractionToDecimal(numerator, denominator); //assert actual.Should().Be(expected);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public string FractionToDecimal(int numerator, int denominator)&#123; if (numerator == 0) &#123; return &quot;0&quot;; &#125; StringBuilder sb = new StringBuilder(); //考慮負數 sb.Append((numerator &gt;= 0) ^ (denominator &gt;= 0) ? &quot;-&quot; : string.Empty); //只取正數 var _numerator =Math.Abs(Convert.ToInt64(numerator)); var _denominator = Math.Abs(Convert.ToInt64(denominator)); sb.Append(_numerator / _denominator); //餘數 var Remainder = (_numerator % _denominator); if (Remainder == 0) &#123; return sb.ToString(); &#125; sb.Append(&quot;.&quot;); var Map = new Dictionary&lt;Int64, int&gt;(); Map.Add(Remainder, sb.Length); while (Remainder != 0) &#123; sb.Append((Remainder *10) / _denominator); Remainder = (Remainder * 10) % _denominator; if (Map.ContainsKey(Remainder)) &#123; var Index = Map[Remainder]; //開始重複 sb.Insert(Index, &quot;(&quot;); sb.Append(&quot;)&quot;); break; &#125; Map.Add(Remainder, sb.Length); &#125; return sb.ToString();&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"}]},{"title":"【MVC教學】8.View(一)","slug":"【MVC教學】8.View(一)","date":"2018-06-27T01:28:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2018/06/27/【MVC教學】8.View(一)/","link":"","permalink":"https://toyo0103.github.io/2018/06/27/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%918.View(%E4%B8%80)/","excerpt":"","text":"Demo範例 ：Git位置 #目標將網路上下載來的免費漂亮版型套進專案中，從實作中瞭解如何套版跟應用.Net提供的一些API方法，過程中或許會有許多小地方不懂，例如Html結構，View Render的機制等等，沒關係，這會在後續的篇章中慢慢補足，而此篇主要是希望讓讀者知道套版原理，並享受網頁隨著套版變漂亮的過程。 在Google搜尋中輸入free template download可以找到一大堆免費授權的版型，而這次從這個TEMPLATED挑了一個喜歡的，有興趣可以先看一下該版型的Live Demo 如果不方便從網路下載也無妨，我已經將下載好且解壓的版本放到Git的專案之中，如果要練習可以直接從裡面取得Source Code #實作套版前準備Chrome通常我會用Chrome瀏覽器來輔助套版的工作，所以以下的操作都是針對Chrome撰寫，不過現在各家瀏覽器其實都大同小異了，只要有相對應的功能即可。 Chrome下載 Web Server For Chrome(非必要)為了方便瀏覽下載的版型，可以安裝Web Server For Chrome這個套件 安裝完後應該會在Chrome的應用程式中看到Web Server 打開它並把資料夾選到版型的根目錄 點擊**Web Server URL(s)**，應該就可以看到網站出現了 首頁套版從Visual Studio中開啟Index.html 將所有內容複製貼到我們的/Home/Index.cshtml之中 這時候會發現第一個錯誤 跳脫字元原因是.Net MVC預設用的套版語法是Razor，而**@是它的保留字，所以要用跳脫字元來解決，只要將*@*templatedco變成@@templatedco**，它在顯示網頁的時候就會印出我們想要的@templatedco了 執行網站看首頁結果會發現，它怪怪的… Layout首先網頁最上面那排黑黑的Header，明明我們版型的Header沒這塊，它是從哪邊長出來的? 這邊就要瞭解Layout是什麼 很多網頁都會有一個特性，那就是不管切換到哪個頁面都會有共用的區塊，以Sony頁面為例 PlayStation頁面 消費性電子&gt;電視頁面 共通點就是Header不管到哪一頁都不會換 而如果每頁都要重新把Header套版一次會衍伸一些問題 重工 : 有一百頁就要把一樣的內容貼一百次 維護困難 : 如果想在Header多一顆按鈕，就要打開一百個頁面調整一百次 所以實務上會透過Layout來解決這問題，將全站幾乎都會共用的部分抽出來當Layout，而會變動的部分當作Body。 所以套用了新的版型還會跑出Header，那是因為Layout裡面有這個區塊 依照剛剛說的，我們把共用的區塊抽到Layout裡面去放 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;!-- Hielo by TEMPLATED templated.co @@templatedco Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hielo by TEMPLATED&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/main.css&quot; /&gt;&lt;/head&gt; &lt;body&gt; .... &lt;/body&gt;&lt;/html&gt; Layout調整成 12345678910111213141516171819202122232425&lt;!DOCTYPE HTML&gt;&lt;!-- Hielo by TEMPLATED templated.co @@templatedco Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hielo by TEMPLATED&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/main.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; @RenderBody() @RenderSection(&quot;scripts&quot;, required: false) &lt;script&gt; @if (TempData[&quot;Message&quot;] != null) &#123; &lt;text&gt;alert(&#x27;@TempData[&quot;Message&quot;]&#x27;)&lt;/text&gt; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Index調整成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179@&#123; ViewBag.Title = &quot;Home Page&quot;;&#125;&lt;!-- Header --&gt;&lt;header id=&quot;header&quot; class=&quot;alt&quot;&gt; &lt;div class=&quot;logo&quot;&gt;&lt;a href=&quot;index.html&quot;&gt;Hielo &lt;span&gt;by TEMPLATED&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; &lt;a href=&quot;#menu&quot;&gt;Menu&lt;/a&gt;&lt;/header&gt;&lt;!-- Nav --&gt;&lt;nav id=&quot;menu&quot;&gt; &lt;ul class=&quot;links&quot;&gt; &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;generic.html&quot;&gt;Generic&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;elements.html&quot;&gt;Elements&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;!-- Banner --&gt;&lt;section class=&quot;banner full&quot;&gt; &lt;article&gt; &lt;img src=&quot;images/slide01.jpg&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header&gt; &lt;p&gt;A free responsive web site template by &lt;a href=&quot;https://templated.co&quot;&gt;TEMPLATED&lt;/a&gt;&lt;/p&gt; &lt;h2&gt;Hielo&lt;/h2&gt; &lt;/header&gt; &lt;/div&gt; &lt;/article&gt; &lt;article&gt; &lt;img src=&quot;images/slide02.jpg&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header&gt; &lt;p&gt;Lorem ipsum dolor sit amet nullam feugiat&lt;/p&gt; &lt;h2&gt;Magna etiam&lt;/h2&gt; &lt;/header&gt; &lt;/div&gt; &lt;/article&gt; &lt;article&gt; &lt;img src=&quot;images/slide03.jpg&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header&gt; &lt;p&gt;Sed cursus aliuam veroeros lorem ipsum nullam&lt;/p&gt; &lt;h2&gt;Tempus dolor&lt;/h2&gt; &lt;/header&gt; &lt;/div&gt; &lt;/article&gt; &lt;article&gt; &lt;img src=&quot;images/slide04.jpg&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header&gt; &lt;p&gt;Adipiscing lorem ipsum feugiat sed phasellus consequat&lt;/p&gt; &lt;h2&gt;Etiam feugiat&lt;/h2&gt; &lt;/header&gt; &lt;/div&gt; &lt;/article&gt; &lt;article&gt; &lt;img src=&quot;images/slide05.jpg&quot; alt=&quot;&quot; /&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header&gt; &lt;p&gt;Ipsum dolor sed magna veroeros lorem ipsum&lt;/p&gt; &lt;h2&gt;Lorem adipiscing&lt;/h2&gt; &lt;/header&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt;&lt;!-- One --&gt;&lt;section id=&quot;one&quot; class=&quot;wrapper style2&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;grid-style&quot;&gt; &lt;div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;image fit&quot;&gt; &lt;img src=&quot;images/pic02.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;header class=&quot;align-center&quot;&gt; &lt;p&gt;maecenas sapien feugiat ex purus&lt;/p&gt; &lt;h2&gt;Lorem ipsum dolor&lt;/h2&gt; &lt;/header&gt; &lt;p&gt; Cras aliquet urna ut sapien tincidunt, quis malesuada elit facilisis. Vestibulum sit amet tortor velit. Nam elementum nibh a libero pharetra elementum. Maecenas feugiat ex purus, quis volutpat lacus placerat malesuada.&lt;/p&gt; &lt;footer class=&quot;align-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;button alt&quot;&gt;Learn More&lt;/a&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;image fit&quot;&gt; &lt;img src=&quot;images/pic03.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;header class=&quot;align-center&quot;&gt; &lt;p&gt;mattis elementum sapien pretium tellus&lt;/p&gt; &lt;h2&gt;Vestibulum sit amet&lt;/h2&gt; &lt;/header&gt; &lt;p&gt; Cras aliquet urna ut sapien tincidunt, quis malesuada elit facilisis. Vestibulum sit amet tortor velit. Nam elementum nibh a libero pharetra elementum. Maecenas feugiat ex purus, quis volutpat lacus placerat malesuada.&lt;/p&gt; &lt;footer class=&quot;align-center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;button alt&quot;&gt;Learn More&lt;/a&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt;&lt;!-- Two --&gt;&lt;section id=&quot;two&quot; class=&quot;wrapper style3&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header class=&quot;align-center&quot;&gt; &lt;p&gt;Nam vel ante sit amet libero scelerisque facilisis eleifend vitae urna&lt;/p&gt; &lt;h2&gt;Morbi maximus justo&lt;/h2&gt; &lt;/header&gt; &lt;/div&gt;&lt;/section&gt;&lt;!-- Three --&gt;&lt;section id=&quot;three&quot; class=&quot;wrapper style2&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;header class=&quot;align-center&quot;&gt; &lt;p class=&quot;special&quot;&gt;Nam vel ante sit amet libero scelerisque facilisis eleifend vitae urna&lt;/p&gt; &lt;h2&gt;Morbi maximus justo&lt;/h2&gt; &lt;/header&gt; &lt;div class=&quot;gallery&quot;&gt; &lt;div&gt; &lt;div class=&quot;image fit&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/pic01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;image fit&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/pic02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;image fit&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/pic03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class=&quot;image fit&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/pic04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt;&lt;!-- Footer --&gt;&lt;footer id=&quot;footer&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul class=&quot;icons&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;icon fa-twitter&quot;&gt;&lt;span class=&quot;label&quot;&gt;Twitter&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;icon fa-facebook&quot;&gt;&lt;span class=&quot;label&quot;&gt;Facebook&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;icon fa-instagram&quot;&gt;&lt;span class=&quot;label&quot;&gt;Instagram&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;icon fa-envelope-o&quot;&gt;&lt;span class=&quot;label&quot;&gt;Email&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;copyright&quot;&gt; &amp;copy; Untitled. All rights reserved. &lt;/div&gt;&lt;/footer&gt;&lt;!-- Scripts --&gt;&lt;script src=&quot;assets/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/jquery.scrollex.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/skel.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/util.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;assets/js/main.js&quot;&gt;&lt;/script&gt; @RenderBody()Layout中間有一行@RenderBody()這是Razor提供的方法，意思是所有套用這個Layout的頁面，它的內容會取代@RenderBody()。 假設我們的Index內容為 1&lt;p&gt;I&#x27;m Index&lt;/p&gt; 那套上Layout後產生給使用者看到的完整Html就會是這樣 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;!-- Hielo by TEMPLATED templated.co @@templatedco Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hielo by TEMPLATED&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/main.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;I&#x27;m Index&lt;/p&gt; .....&lt;/body&gt;&lt;/html&gt; @RenderSection()實務上會希望Javascript或是CSS在特定的地方載入，如果只是單純放在Index中將會變成這樣 Index 12&lt;p&gt;I&#x27;m Index&lt;/p&gt;&lt;script src=&quot;assets/js/jquery.min.js&quot;&gt;&lt;/script&gt; 結果 12345678910111213141516171819&lt;!DOCTYPE HTML&gt;&lt;!-- Hielo by TEMPLATED templated.co @@templatedco Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)--&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hielo by TEMPLATED&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/main.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;I&#x27;m Index&lt;/p&gt; &lt;script src=&quot;assets/js/jquery.min.js&quot;&gt;&lt;/script&gt; ....&lt;/body&gt;&lt;/html&gt; 此時就可以透過在Layout中挖**@RenderSection()**區塊來解決 Layout 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; .... @RenderSection(&quot;css&quot;, required: false)&lt;/head&gt;&lt;body&gt; @RenderBody() @RenderSection(&quot;scripts&quot;, required: false) ....&lt;/body&gt;&lt;/html&gt; Index 12345678@section scripts&#123; &lt;script src=&quot;assets/js/jquery.min.js&quot;&gt;&lt;/script&gt;&#125;@section css&#123; &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/main.css&quot; /&gt;&#125;&lt;p&gt;I&#x27;m Index&lt;/p&gt; 結果 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; .... &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/css/main.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;I&#x27;m Index&lt;/p&gt; &lt;script src=&quot;assets/js/jquery.min.js&quot;&gt;&lt;/script&gt; ....&lt;/body&gt;&lt;/html&gt; @RenderSection(“scripts”, required: false)required參數意義為 True :套用這個Layout的子版面一定要寫@section scripts{ }這個區段False :套用這個Layout的子版面可以沒有@section scripts{ }區段 _ViewStart檢視Index頁面，為何它知道要套用Layout呢?其實這寫在_ViewStart.cshtml之中 _ViewStart.cshtml 123@&#123; Layout = &quot;~/Views/Shared/_Layout.cshtml&quot;;&#125; 所有頁面如果沒有特別指定Layout的情況下，預設套用這個設定。 但這不意謂著不能自行修改，假設所有專案有兩三個頁面要套用_Layout2.cshtml，那我們可以在各自的頁面中指定Layout，而指定的Layout優先於預設。 Index 1234@&#123; Layout = &quot;~/Views/Shared/_Layout2.cshtml&quot;;&#125;&lt;p&gt;I&#x27;m Index&lt;/p&gt; 載入CSS、Javascript重新調整Layout與Index內容後，頁面依然沒有正常顯示 在Chrome按下F12點擊右上角的錯誤可以得知是因為沒有載入CSS與Javascript 將Javascript與CSS移到專案之中 同時我們也刪除掉原本在專案內的Javascript與CSS 修改Index中Javascript的位置 123456789....&lt;!-- Scripts --&gt;&lt;script src=&quot;~/assets/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;~/assets/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;~/assets/js/jquery.scrollex.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;~/assets/js/skel.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;~/assets/js/util.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;~/assets/js/main.js&quot;&gt;&lt;/script&gt; 修改_Layout中CSS的位置 12345678...&lt;head&gt; &lt;title&gt;Hielo by TEMPLATED&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link href=&quot;~/assets/css/main.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/head&gt;... ~/assets/css/main.css~/assets/js/main.js前面的 ~ 符號表示從根目錄開始算起 再次執行專案 發生錯誤，原因是BundleConfig的地方有抓原本放Javascript的資料夾但被我們砍掉了，Bundle基本上目前我們很少用到所以先暫時不理它，把內容清空不影響結果 1234567public class BundleConfig&#123; // 如需統合的詳細資訊，請瀏覽 https://go.microsoft.com/fwlink/?LinkId=301862 public static void RegisterBundles(BundleCollection bundles) &#123; &#125;&#125; 執行起來後 看起來正常許多但圖片還是沒有出來，將圖片移入 #小結 已經成功將首頁移入專案之中，下一篇將來客製化將之前完成的登入頁面也套進這個漂亮的版型之中，中間將會碰到更多套版的Razor API與一些小技巧。","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"【LeetCode】Poor Pigs","slug":"【LeetCode】Poor Pigs","date":"2018-06-19T07:00:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2018/06/19/【LeetCode】Poor Pigs/","link":"","permalink":"https://toyo0103.github.io/2018/06/19/%E3%80%90LeetCode%E3%80%91Poor%20Pigs/","excerpt":"","text":"#題目There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour. Answer this question, and write an algorithm for the follow-up general case. Follow-up: If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the “poison” bucket within p minutes? There is exact one bucket with poison. 12345public class Solution &#123; public int PoorPigs(int buckets, int minutesToDie, int minutesToTest) &#123; &#125;&#125; #解題喝下毒藥15分鐘毒發身亡，假設每15分鐘沒事就喝下一桶這樣循環，一隻豬一小時可喝下四桶水，假設中間喝到任一桶毒藥，則提前找到目標，如果沒有，則第五桶就會是毒藥。(全部五桶的狀況) 換句話說，假設2隻豬可以測試25桶水(二維)，依據豬隻毒發的時間可以知道哪桶水有毒 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 豬隻A每次喝一行(1,2,3,4,5)，豬隻B每次喝一列(1,6,11,16,21)，一小時剛好可以測試25桶水，毒發時即可推測哪一桶水有毒了 所以公式為**(測試時間/毒發時間 + 1 ) ^ n &gt;= 水桶數** ，求n的最小值 案例一1234567891011121314151617[TestMethod]public void PoorPigsTest_5桶水_1小時_毒發時間15分鐘_最少需要1隻豬來測試()&#123; //arrange var sut = new Solution(); var bukets = 5; var minutesToDie = 15; var minutesToTest = 60; var expected = 1; //act var actual = sut.PoorPigs(bukets, minutesToDie, minutesToTest); //assert actual.Should().Be(expected);&#125; 1234567891011121314public int PoorPigs(int buckets, int minutesToDie, int minutesToTest)&#123; var OnePigCanTestBukets = (minutesToTest / minutesToDie) + 1; var Pigs = 0; double TotalCanTestBukets = 0; while (TotalCanTestBukets &lt; buckets) &#123; Pigs++; TotalCanTestBukets = Math.Pow(OnePigCanTestBukets, Pigs); &#125; return Pigs;&#125; 案例二1234567891011121314151617[TestMethod]public void PoorPigsTest_6桶水_1小時_毒發時間15分鐘_最少需要2隻豬來測試()&#123; //arrange var sut = new Solution(); var bukets = 6; var minutesToDie = 15; var minutesToTest = 60; var expected = 2; //act var actual = sut.PoorPigs(bukets, minutesToDie, minutesToTest); //assert actual.Should().Be(expected);&#125; 直接通過單元測試 #解析LeetCode測試發生錯誤 補上案例 1234567891011121314151617[TestMethod]public void PoorPigsTest_1桶水_1分鐘測試時間_毒發時間1分鐘_最少需要0隻豬來測試()&#123; //arrange var sut = new Solution(); var bukets = 1; var minutesToDie = 1; var minutesToTest = 1; var expected = 0; //act var actual = sut.PoorPigs(bukets, minutesToDie, minutesToTest); //assert actual.Should().Be(expected);&#125; 一桶水根本不需要測試，所以修改一下Code 123456789101112131415161718public int PoorPigs(int buckets, int minutesToDie, int minutesToTest)&#123; var Pigs = 0; if (buckets &lt;= 1) &#123; return Pigs; &#125; var OnePigCanTestBukets = (minutesToTest / minutesToDie) + 1; double TotalCanTestBukets = 0; while (TotalCanTestBukets &lt; buckets) &#123; Pigs++; TotalCanTestBukets = Math.Pow(OnePigCanTestBukets, Pigs); &#125; return Pigs;&#125; 過關 心得一開始沒想清楚，想說算出一隻豬能測試幾桶後直接除即可，但這樣會發生一個狀況是剛好全部豬都活下來，那就會有一堆水桶還沒測試，參考了答案後想了一下才想通這是幾維的問題，只要讓這些豬喝下的水有交錯的可能，那有辦法推斷哪桶有毒。 另外Math.Pow的用法也是查了後才知道如何使用，雖然理解上不難，但也是很有收穫的一題 MSDN - Math.Pow","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"}]},{"title":"【LeetCode】Count The Repetitions","slug":"【LeetCode】Count The Repetitions","date":"2018-06-12T16:44:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2018/06/13/【LeetCode】Count The Repetitions/","link":"","permalink":"https://toyo0103.github.io/2018/06/13/%E3%80%90LeetCode%E3%80%91Count%20The%20Repetitions/","excerpt":"","text":"#題目Define S = [s,n] as the string S which consists of n connected strings s. For example, [&quot;abc&quot;, 3] =”abcabcabc”. On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc” can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”. You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1. Example: Input:s1=”acb”, n1=4s2=”ab”, n2=2Return:2 #解題如何判定S2會包含在S1的倍數之中，我採取的方法是將遍歷S1的每個字元，每當該字元與S2相同時，S2的指標往前一格。 [a]cbS1 : a[a]bS2 : a a[c]bS1 : ca[b]S2 : b ac[b]S1 : ba[b]S2 : b [a]cbS1 : a[a]bS2 : a 以下省略…. 直到S1 * N1的字元次數被跑完時，可以知道S2被重複了幾次，這時候將重複次數除以N2即為真正可重複的次數 案例一123456789101112131415161718[TestMethod()]public void GetMaxRepetitionsTest()&#123; //arrange var s1 = &quot;acb&quot;; var n1 = 4; var s2 = &quot;ab&quot;; var n2 = 2; var sut = new Solution(); var expected = 2; //act var actual = sut.GetMaxRepetitions(s1, n1, s2, n2); //assert actual.Should().Be(expected);&#125; 12345678910111213141516171819202122232425public int GetMaxRepetitions(string s1, int n1, string s2, int n2)&#123; var SlChars = s1.ToCharArray(); var S2Chars = s2.ToCharArray(); int Repetitions = 0; int Cursor = 0; for (int i = 0; i &lt; SlChars.Length * n1 ; i++) &#123; if (SlChars[i % SlChars.Length] == S2Chars[Cursor]) &#123; Cursor++; &#125; if (Cursor == S2Chars.Length) &#123; Repetitions++; Cursor = 0; &#125; &#125; return Repetitions / n2;&#125; 案例二123456789101112131415161718[TestMethod()]public void GetMaxRepetitionsTest_2()&#123; //arrange var s1 = &quot;ab&quot;; var n1 = 3; var s2 = &quot;ab&quot;; var n2 = 4; var sut = new Solution(); var expected = 0; //act var actual = sut.GetMaxRepetitions(s1, n1, s2, n2); //assert actual.Should().Be(expected);&#125; 單元測試直接通過 #解析LeetCode回傳Time Limit Exceeded，表示這效率不能接受，所以來試試看優化它 優化想先把迴圈內計算餘數的地方拿掉，這個地方應該卡掉一堆效能 1if (SlChars[i % SlChars.Length] == S2Chars[Cursor]) 改寫之後不再迴圈內計算餘數，讓每個變數的操作都盡量簡單化 12345678910111213141516171819202122232425262728293031323334353637public int GetMaxRepetitions(string s1, int n1, string s2, int n2)&#123; var SlChars = s1.ToCharArray(); var S2Chars = s2.ToCharArray(); int Repetitions = 0; int S1Cursor = 0; int S2Cursor = 0; int Count = 0; while (Count &lt; n1) &#123; if (SlChars[S1Cursor] == S2Chars[S2Cursor]) &#123; S2Cursor++; &#125; S1Cursor++; if (S2Cursor == S2Chars.Length) &#123; Repetitions++; S2Cursor = 0; &#125; if (S1Cursor == SlChars.Length) &#123; S1Cursor = 0; Count++; &#125; &#125; return Repetitions / n2;&#125; 結果LeetCode還是判定逾時,果然事情不是憨人我想的那麼簡單，暴力破解法行不通 尋找Loop Pattern在這邊決定改變作法，首先如果S1會重複表示有可能發生重複狀況的發生，例如 S1 = aabaabaabn1 = 3 S2 = aban2 = 1 0 4 7 1 4 7 a a b a a b a a b a a b a a b a a b a ….. a b a a b a a b a a b a a b a a b a ….. *第一列表示S2字首a比對到時，相對於各組S1的Index *第二列 S1的排序組 *第三列 S2比對相符組 可以發現第一次重複的Index為4，所以繼續往下排就會一直重複的狀況發生，也藉著這個特性可以找出一個算法。 第二次4在整個S1的排列組裡面Index為13，第一次4在整個排列組裡面Index也是4 兩者之間總共可以包含3組S2 所以之後只要每加9個字元，就會多出3組S2 依照此特性修改程式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int GetMaxRepetitions(string s1, int n1, string s2, int n2)&#123; var S1Chars = s1.ToCharArray(); var S2Chars = s2.ToCharArray(); int S2Cursor = 0; int Repetitions = 0; var LogFirstLetterMatchInS1Index = new Dictionary&lt;int, Tuple&lt;int, int&gt;&gt;(); for (int i = 0; i &lt; S1Chars.Length * n1 ; i++) &#123; var S1Index = i % s1.Length; if (S1Chars[S1Index] == S2Chars[S2Cursor]) &#123; if (S2Cursor == 0) &#123; if (LogFirstLetterMatchInS1Index.ContainsKey(S1Index)) &#123; //形成Loop了 var PreSameIndexValue = LogFirstLetterMatchInS1Index[S1Index]; //Repetitions var OneLoopS2Count = (Repetitions - PreSameIndexValue.Item2); var OneLoopDistance = i - PreSameIndexValue.Item1; while ((i + OneLoopDistance) &lt; S1Chars.Length * n1) &#123; Repetitions += OneLoopS2Count; i += OneLoopDistance; &#125; &#125; else &#123; LogFirstLetterMatchInS1Index.Add(S1Index,new Tuple&lt;int, int&gt;(i, Repetitions)); &#125; &#125; S2Cursor++; &#125; if (S2Cursor == S2Chars.Length) &#123; Repetitions++; S2Cursor = 0; &#125; &#125; return Repetitions / n2;&#125; 雖然終於通過LeetCode測驗，但成績依然不是很理想，不過一些大神的解法目前還沒完全了解，所以先用這個算法勉強過關，之後有懂更佳的方式再繼續優化。 這題寫了兩天且數次拿著計算紙在床上睡著後終於勉強想通，不愧是Hard等級的題目阿","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"}]},{"title":"【LeetCode】Serialize and Deserialize BST","slug":"【LeetCode】Serialize and Deserialize BST","date":"2018-06-09T12:00:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2018/06/09/【LeetCode】Serialize and Deserialize BST/","link":"","permalink":"https://toyo0103.github.io/2018/06/09/%E3%80%90LeetCode%E3%80%91Serialize%20and%20Deserialize%20BST/","excerpt":"","text":"#題目Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * public int val; * public TreeNode left; * public TreeNode right; * public TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public string serialize(TreeNode root) &#123; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(string data) &#123; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root)); #解題serialize案例一123456789101112131415[TestMethod()]public void serializeTest()&#123; //arrange var node = new TreeNode(1); var sut = new Codec(); var expected = &quot;1!#!#!&quot;; //act var actual = sut.serialize(node); //assert actual.Should().BeEquivalentTo(expected);&#125; 12345678910111213141516public class Codec&#123; public string serialize(TreeNode root) &#123; string res = root.val + &quot;!&quot;; res += serialize(root.left); res += serialize(root.right); return res; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(string data) &#123; return null; &#125;&#125; 案例二1234567891011121314[TestMethod()]public void serializeTest_傳入Null應回傳空字串()&#123; //arrange var sut = new Codec(); var expected = &quot;#!&quot;; //act var actual = sut.serialize(null); //assert actual.Should().Be(expected);&#125; 123456789101112131415161718192021public class Codec&#123; public string serialize(TreeNode root) &#123; if (root == null) &#123; return &quot;#!&quot;; &#125; string res = root.val + &quot;!&quot;; res += serialize(root.left); res += serialize(root.right); return res; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(string data) &#123; return null; &#125;&#125; 案例三1234567891011121314151617[TestMethod()]public void serializeTest_有左邊子節點()&#123; //arrange var node = new TreeNode(1); node.left = new TreeNode(2); var sut = new Codec(); var expected = &quot;1!2!#!#!#!&quot;; //act var actual = sut.serialize(node); //assert actual.Should().BeEquivalentTo(expected);&#125; 測試直接通過 案例四1234567891011121314151617[TestMethod()]public void serializeTest_有右邊子節點()&#123; //arrange var node = new TreeNode(1); node.right = new TreeNode(2); var sut = new Codec(); var expected = @&quot;1!#!2!#!#!&quot;; //act var actual = sut.serialize(node); //assert actual.Should().BeEquivalentTo(expected);&#125; 測試直接通過 案例五123456789101112131415161718192021[TestMethod()]public void serializeTest_三層節點()&#123; //arrange var node = new TreeNode(1); node.left = new TreeNode(2); node.right = new TreeNode(3); node.left.left = new TreeNode(4); node.right.right = new TreeNode(5); var sut = new Codec(); var expected = &quot;1!2!4!#!#!#!3!#!5!#!#!&quot;; //act var actual = sut.serialize(node); //assert actual.Should().BeEquivalentTo(expected);&#125; 圖解 deserialize案例一1234567891011121314[TestMethod()]public void deserializeTest()&#123; //arrange var nodeSerializeString = @&quot;1!#!#!&quot;; var sut = new Codec(); var expected = new TreeNode(1); //act var actual = sut.deserialize(nodeSerializeString); //assert actual.Should().BeEquivalentTo(expected);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Codec&#123; public string serialize(TreeNode root) &#123; if (root == null) &#123; return &quot;#!&quot;; &#125; string res = root.val + &quot;!&quot;; res += serialize(root.left); res += serialize(root.right); return res; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(string data) &#123; var nodeData = data.Split(new string[] &#123; &quot;!&quot; &#125;, StringSplitOptions.RemoveEmptyEntries); var queue = new Queue&lt;string&gt;(); foreach (var node in nodeData) &#123; queue.Enqueue(node); &#125; return RebuildNode(queue); &#125; private TreeNode RebuildNode(Queue&lt;string&gt; queue) &#123; var Value = queue.Dequeue(); if (Value == &quot;#&quot;) &#123; return null; &#125; TreeNode node = new TreeNode(int.Parse(Value)); node.left = RebuildNode(queue); node.right = RebuildNode(queue); return node; &#125;&#125; Queue類別為先進先出**(FIFO)，與Stack**後進先出(LIFO)使用方法相反 MSDN - Queue 類別 案例二12345678910111213[TestMethod()]public void deserializeTest_Null_Node()&#123; //arrange var nodeSerializeString = &quot;#!&quot;; var sut = new Codec(); //act var actual = sut.deserialize(nodeSerializeString); //assert actual.Should().BeNull();&#125; 直接通過測試 案例三123456789101112131415[TestMethod()]public void deserializeTest_有左邊子節點()&#123; //arrange var nodeSerializeString = @&quot;1!4!#!#!#!&quot;; var sut = new Codec(); var expected = new TreeNode(1); expected.left = new TreeNode(4); //act var actual = sut.deserialize(nodeSerializeString); //assert actual.Should().BeEquivalentTo(expected);&#125; 直接通過測試 案例四123456789101112131415[TestMethod()]public void deserializeTest_有右邊子節點()&#123; //arrange var nodeSerializeString = @&quot;1!#!2!#!#!&quot;; var sut = new Codec(); var expected = new TreeNode(1); expected.right = new TreeNode(2); //act var actual = sut.deserialize(nodeSerializeString); //assert actual.Should().BeEquivalentTo(expected);&#125; 直接通過測試 案例五123456789101112131415161718192021[TestMethod()]public void deserializeTest_三層節點()&#123; //arrange var nodeSerializeString = @&quot;1!2!4!#!#!#!3!#!5!#!#!&quot;; var sut = new Codec(); var expected = new TreeNode(1); expected.left = new TreeNode(2); expected.right = new TreeNode(3); expected.left.left = new TreeNode(4); expected.right.right = new TreeNode(5); //act var actual = sut.deserialize(nodeSerializeString); //assert actual.Should().BeEquivalentTo(expected);&#125; 直接通過測試 #解析 這題一樣是參考了別人的答案然後去理解，一開始搞得很複雜，想說回傳Json然後再去解析，忽略了二元樹遍歷規則，果然還要多練練才行。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"}]},{"title":"【LeetCode】Find the Difference","slug":"【LeetCode】Find the Difference","date":"2018-06-07T05:00:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2018/06/07/【LeetCode】Find the Difference/","link":"","permalink":"https://toyo0103.github.io/2018/06/07/%E3%80%90LeetCode%E3%80%91Find%20the%20Difference/","excerpt":"","text":"#題目Given two strings s and t which consist of only lowercase letters.String t is generated by random shuffling string s and then add one more letter at a random position.Find the letter that was added in t. Example: Input:s = “abcd”t = “abcde”Output:eExplanation:‘e’ is the letter that was added. 12345public class Solution &#123; public char FindTheDifference(string s, string t) &#123; &#125;&#125; #解題案例一12345678910111213141516[TestMethod()]public void FindTheDifferenceTest_輸入S為abcd_輸入T為abcde()&#123; //arrange var sut = new Solution(); var S = &quot;abcd&quot;; var T = &quot;abcde&quot;; char expected = &#x27;e&#x27;; //act var actual = sut.FindTheDifference(S, T); //assert actual.Should().Be(expected);&#125; 12345678910111213141516171819202122public char FindTheDifference(string s, string t)&#123; var originalString = s.ToCharArray(); var addSomeSaltString = t.ToCharArray(); for (int i = 0; i &lt; addSomeSaltString.Length; i++) &#123; var checkThisChar = addSomeSaltString[i]; if (i &gt; originalString.Length -1) &#123; return checkThisChar; &#125; if (originalString[i] != checkThisChar) &#123; return checkThisChar; &#125; &#125; return &#x27;\\0&#x27;;&#125; #解析LeetCode跑測試錯誤 補上錯誤案例1234567891011121314151617[TestMethod()]public void FindTheDifferenceTest_LeetCode_Error1()&#123; //arrange var sut = new Solution(); var S = &quot;ymbgaraibkfmvocpizdydugvalagaivdbfsfbepeyccqfepzvtpyxtbadkhmwmoswrcxnargtlswqemafandgkmydtimuzvjwxvlfwlhvkrgcsithaqlcvrihrwqkpjdhgfgreqoxzfvhjzojhghfwbvpfzectwwhexthbsndovxejsntmjihchaotbgcysfdaojkjldprwyrnischrgmtvjcorypvopfmegizfkvudubnejzfqffvgdoxohuinkyygbdzmshvyqyhsozwvlhevfepdvafgkqpkmcsikfyxczcovrmwqxxbnhfzcjjcpgzjjfateajnnvlbwhyppdleahgaypxidkpwmfqwqyofwdqgxhjaxvyrzupfwesmxbjszolgwqvfiozofncbohduqgiswuiyddmwlwubetyaummenkdfptjczxemryuotrrymrfdxtrebpbjtpnuhsbnovhectpjhfhahbqrfbyxggobsweefcwxpqsspyssrmdhuelkkvyjxswjwofngpwfxvknkjviiavorwyfzlnktmfwxkvwkrwdcxjfzikdyswsuxegmhtnxjraqrdchaauazfhtklxsksbhwgjphgbasfnlwqwukprgvihntsyymdrfovaszjywuqygpvjtvlsvvqbvzsmgweiayhlubnbsitvfxawhfmfiatxvqrcwjshvovxknnxnyyfexqycrlyksderlqarqhkxyaqwlwoqcribumrqjtelhwdvaiysgjlvksrfvjlcaiwrirtkkxbwgicyhvakxgdjwnwmubkiazdjkfmotglclqndqjxethoutvjchjbkoasnnfbgrnycucfpeovruguzumgmgddqwjgdvaujhyqsqtoexmnfuluaqbxoofvotvfoiexbnprrxptchmlctzgqtkivsilwgwgvpidpvasurraqfkcmxhdapjrlrnkbklwkrvoaziznlpor&quot;; var T = &quot;qhxepbshlrhoecdaodgpousbzfcqjxulatciapuftffahhlmxbufgjuxstfjvljybfxnenlacmjqoymvamphpxnolwijwcecgwbcjhgdybfffwoygikvoecdggplfohemfypxfsvdrseyhmvkoovxhdvoavsqqbrsqrkqhbtmgwaurgisloqjixfwfvwtszcxwktkwesaxsmhsvlitegrlzkvfqoiiwxbzskzoewbkxtphapavbyvhzvgrrfriddnsrftfowhdanvhjvurhljmpxvpddxmzfgwwpkjrfgqptrmumoemhfpojnxzwlrxkcafvbhlwrapubhveattfifsmiounhqusvhywnxhwrgamgnesxmzliyzisqrwvkiyderyotxhwspqrrkeczjysfujvovsfcfouykcqyjoobfdgnlswfzjmyucaxuaslzwfnetekymrwbvponiaojdqnbmboldvvitamntwnyaeppjaohwkrisrlrgwcjqqgxeqerjrbapfzurcwxhcwzugcgnirkkrxdthtbmdqgvqxilllrsbwjhwqszrjtzyetwubdrlyakzxcveufvhqugyawvkivwonvmrgnchkzdysngqdibhkyboyftxcvvjoggecjsajbuqkjjxfvynrjsnvtfvgpgveycxidhhfauvjovmnbqgoxsafknluyimkczykwdgvqwlvvgdmufxdypwnajkncoynqticfetcdafvtqszuwfmrdggifokwmkgzuxnhncmnsstffqpqbplypapctctfhqpihavligbrutxmmygiyaklqtakdidvnvrjfteazeqmbgklrgrorudayokxptswwkcircwuhcavhdparjfkjypkyxhbgwxbkvpvrtzjaetahmxevmkhdfyidhrdeejapfbafwmdqjqszwnwzgclitdhlnkaiyldwkwwzvhyorgbysyjbxsspnjdewjxbhpsvj&quot;; char expected = &#x27;t&#x27;; //act var actual = sut.FindTheDifference(S, T); //assert actual.Should().Be(expected);&#125; 顯然我的方向上完全錯誤，題目的意思是兩邊的每種字元個數應該會一樣，唯獨T會多插入一個隨機字元，找出那一個隨機字元，且與排序無關。 原本分別統計S與T包含的每個字元個數後，比較個數不一樣的即是多出來的(程式就不寫了，這種暴力破解法大家都會)，但總覺得哪裡不對，參考了LeetCode上面大大的答案後果然有更好的解法 將S與T的每個字元用ASCII內碼對應的數字相加後，差即為多出來的數字 12345678910111213public char FindTheDifference(string s, string t)&#123; int sumS = 0; foreach (char c in t) &#123; sumS += c; &#125; foreach (char c in s) &#123; sumS -= c; &#125; return (char)(sumS);&#125; 在這邊我學習到了 String直接Foreach即是Char的型別(我一開始還在那拆解) Char可以直接與Int相加，無須轉換 #優化既然都知道T一定只比S多一個字元，那這樣雙迴圈其實也可以省略掉 1234567891011121314151617public char FindTheDifference(string s, string t)&#123; //先加T的最後一個字元 int sum = t[t.Length -1]; for (int i = 0; i &lt; t.Length - 1; i++) &#123; //T加總 sum += t[i]; //扣掉S sum -= s[i]; &#125; //相差的值 return (char)(sum);&#125; 透過 ^= 運算子這邊也看到另一種做法，是透過**^= ** (XOR)的運算 Wiki在數位邏輯中，邏輯算符互斥或閘（exclusive or）是對兩個運算元的一種邏輯分析類型，符號為XOR或EOR或⊕。與一般的邏輯或OR不同，當兩兩數值相同為否，而數值不同時為真。 二進位舉例 1111 ^ 1111 = 0000 0000 ^ 0000 = 0000 0101 ^ 1101 = 1000 123456var a = 1;a ^= 5;//a:4a ^= 5;//a:1 123456var a = 1;a ^= 2;//a:3 a ^= 2;//a:1 所以碰到相同的數字會被返回來的特性下，可以將程式改成 12345678910111213public char FindTheDifference(string s, string t)&#123; //先加T的最後一個字元 int sum = t[t.Length -1]; for (int i = 0; i &lt; t.Length - 1; i++) &#123; sum ^= t[i]; sum ^= s[i]; &#125; return (char)(sum);&#125; 這題雖然被標註為Easy，但果然一些基礎還是要多加強，否則對弱弱的我來說還是不Easy","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"}]},{"title":"【LeetCode】Permutations II","slug":"【LeetCode】Permutations II","date":"2018-06-06T10:53:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2018/06/06/【LeetCode】Permutations II/","link":"","permalink":"https://toyo0103.github.io/2018/06/06/%E3%80%90LeetCode%E3%80%91Permutations%20II/","excerpt":"","text":"這題寫超級久，應該是自己邏輯不好的緣故，想不出邏輯最後只好直接用TDD的撰寫方式慢慢將範圍縮小，才歸納出結果，看來我的邏輯真的要好好加強了 #題目Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 12345public class Solution &#123; public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums) &#123; &#125;&#125; #解題案例一1234567891011121314151617[TestMethod]public void PermuteUniqueTest_輸入1_1()&#123; //arrange var sut = new Solution(); int[] input = new int []&#123; 1, 1 &#125;; var expected = new List&lt;List&lt;int&gt;&gt; &#123; new List&lt;int&gt;&#123; 1,1&#125; &#125;; //act var actual = sut.PermuteUnique(input); //assert actual.Should().BeEquivalentTo(expected);&#125; 123456789public partial class Solution&#123; public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums) &#123; var Result = new List&lt;IList&lt;int&gt;&gt;(); Result.Add(nums.ToList()); return Result; &#125;&#125; 案例二1234567891011121314[TestMethod]public void PermuteUniqueTest_輸入空Array()&#123; //arrange var sut = new Solution(); int[] input = new int[0]; var expected = new List&lt;List&lt;int&gt;&gt;(); //act var actual = sut.PermuteUnique(input); //assert actual.Should().BeEquivalentTo(expected);&#125; 1234567891011public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums)&#123; var Result = new List&lt;IList&lt;int&gt;&gt;(); if (nums.Length == 0) return Result; Result.Add(nums.ToList()); return Result;&#125; 案例三123456789101112131415161718[TestMethod]public void PermuteUniqueTest_輸入1_2()&#123; //arrange var sut = new Solution(); int[] input = new int[] &#123; 1, 2 &#125;; var expected = new List&lt;List&lt;int&gt;&gt; &#123; new List&lt;int&gt;&#123; 1,2&#125;, new List&lt;int&gt;&#123; 2,1&#125; &#125;; //act var actual = sut.PermuteUnique(input); //assert actual.Should().BeEquivalentTo(expected);&#125; 12345678910111213141516171819202122232425262728public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums)&#123; var Result = new List&lt;IList&lt;int&gt;&gt;(); if (nums.Length == 0) return Result; Result.Add(nums.ToList()); for (int i = 0; i &lt; nums.Length; i++) &#123; if (i == nums.Length - 1) continue; if (nums[i] != nums[ i+1]) &#123; //Swap var Temp = nums[i]; nums[i] = nums[i + 1]; nums[i + 1] = Temp; Result.Add(nums.ToList()); &#125; &#125; return Result;&#125; 重構123456789101112131415161718192021222324252627282930313233public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums)&#123; var Result = new List&lt;IList&lt;int&gt;&gt;(); if (nums.Length == 0) return Result; Result.Add(nums.ToList()); for (int i = 0; i &lt; nums.Length; i++) &#123; if (i == nums.Length - 1) continue; if (nums[i] != nums[ i+1]) &#123; //Swap Swap(nums, i); Result.Add(nums.ToList()); &#125; &#125; return Result;&#125;private void Swap(int[] nums, int index)&#123; var Temp = nums[index]; nums[index] = nums[index + 1]; nums[index + 1] = Temp;&#125; 案例四12345678910111213141516171819202122[TestMethod]public void PermuteUniqueTest_輸入1_2_3()&#123; //arrange var sut = new Solution(); int[] input = new int[] &#123; 1, 2 , 3&#125;; var expected = new List&lt;List&lt;int&gt;&gt; &#123; new List&lt;int&gt;&#123; 1,2,3&#125;, new List&lt;int&gt;&#123; 1,3,2&#125;, new List&lt;int&gt;&#123; 2,1,3&#125;, new List&lt;int&gt;&#123; 2,3,1&#125;, new List&lt;int&gt;&#123; 3,1,2&#125;, new List&lt;int&gt;&#123; 3,2,1&#125;, &#125;; //act var actual = sut.PermuteUnique(input); //assert actual.Should().BeEquivalentTo(expected);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public partial class Solution&#123; public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums) &#123; var Result = new List&lt;IList&lt;int&gt;&gt;(); if (nums.Length == 0) return Result; Result.Add(nums.ToList()); for (int i = 0; i &lt; nums.Length; i++) &#123; if (i == nums.Length - 1) continue; for (int s = i + 1 ; s &lt; nums.Length; s++) &#123; if (nums[i] != nums[s]) &#123; var SplitLeaft = new List&lt;int&gt;(nums); Swap(SplitLeaft, i, s); Recursive(SplitLeaft, i + 1, Result); &#125; &#125; &#125; return Result; &#125; private void Recursive(List&lt;int&gt; nums, int start, List&lt;IList&lt;int&gt;&gt; result) &#123; result.Add(nums); for (int i = start; i &lt; nums.Count; i++) &#123; if (i == nums.Count - 1) continue; if (nums[start] != nums[i + 1]) &#123; var SplitLeaft = new List&lt;int&gt;(nums); Swap(SplitLeaft, start, i + 1); Recursive(SplitLeaft, i + 1, result); &#125; &#125; &#125; private void Swap(List&lt;int&gt; nums, int index1,int index2) &#123; var Temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = Temp; &#125;&#125; 重構12345678910111213141516171819202122232425262728293031323334353637383940414243public partial class Solution&#123; public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums) &#123; var Result = new List&lt;IList&lt;int&gt;&gt;(); if (nums.Length == 0) return Result; Recursive(new List&lt;int&gt;(nums), 0 , Result); return Result; &#125; private void Recursive(List&lt;int&gt; nums, int start, List&lt;IList&lt;int&gt;&gt; result) &#123; result.Add(nums); for (int i = start; i &lt; nums.Count; i++) &#123; if (i == nums.Count - 1) &#123; continue; &#125; for (int j = i + 1; j &lt; nums.Count; j++) &#123; if (nums[i] != nums[j]) &#123; var SplitLeaft = new List&lt;int&gt;(nums); Swap(SplitLeaft, i, j); Recursive(SplitLeaft, i + 1, result); &#125; &#125; &#125; &#125; private void Swap(List&lt;int&gt; nums, int index1,int index2) &#123; var Temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = Temp; &#125;&#125; 案例五12345678910111213141516171819[TestMethod]public void PermuteUniqueTest_輸入1_1_2()&#123; //arrange var sut = new Solution(); int[] input = new int[] &#123; 1, 1, 2 &#125;; var expected = new List&lt;List&lt;int&gt;&gt; &#123; new List&lt;int&gt;&#123; 1,1,2&#125;, new List&lt;int&gt;&#123; 1,2,1&#125;, new List&lt;int&gt;&#123; 2,1,1&#125; &#125;; //act var actual = sut.PermuteUnique(input); //assert actual.Should().BeEquivalentTo(expected);&#125; 程式無需更動直接通過測試 #分析結果LeetCode跑單元測試錯誤 補上錯誤案例12345678910111213141516171819202122[TestMethod]public void PermuteUniqueTest_輸入2_2_1_1()&#123; //arrange var sut = new Solution(); int[] input = new int[] &#123; 2, 2, 1, 1 &#125;; var expected = new List&lt;List&lt;int&gt;&gt; &#123; new List&lt;int&gt;&#123; 1,1,2,2&#125;, new List&lt;int&gt;&#123; 1,2,1,2&#125;, new List&lt;int&gt;&#123; 1,2,2,1&#125;, new List&lt;int&gt;&#123; 2,1,1,2&#125;, new List&lt;int&gt;&#123; 2,1,2,1&#125;, new List&lt;int&gt;&#123; 2,2,1,1&#125; &#125;; //act var actual = sut.PermuteUnique(input); //assert actual.Should().BeEquivalentTo(expected);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public IList&lt;IList&lt;int&gt;&gt; PermuteUnique(int[] nums)&#123; var Result = new List&lt;IList&lt;int&gt;&gt;(); if (nums.Length == 0) return Result; Recursive(new List&lt;int&gt;(nums), 0 , Result); return Result;&#125;private void Recursive(List&lt;int&gt; nums, int start, List&lt;IList&lt;int&gt;&gt; result)&#123; result.Add(nums); for (int i = start; i &lt; nums.Count; i++) &#123; HashSet&lt;int&gt; used = new HashSet&lt;int&gt;(); if (i == nums.Count - 1) &#123; continue; &#125; for (int j = i + 1; j &lt; nums.Count; j++) &#123; if (nums[i] != nums[j]) &#123; if (used.Contains(nums[j])) &#123; continue; &#125; else &#123; used.Add(nums[j]); &#125; var SplitLeaft = new List&lt;int&gt;(nums); Swap(SplitLeaft, i, j); Recursive(SplitLeaft, i + 1, result); &#125; &#125; &#125;&#125;private void Swap(List&lt;int&gt; nums, int index1,int index2)&#123; var Temp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = Temp;&#125; 這邊的原因是，同一個位置只需要跟相同的數字互換一次即可，因為遞迴會把後面的各種可能補上，否則會發生重複的排列組合 1,1,2,2, index[0] 與後面所有後面的數相比 1,1,2,2 (index[0] = 1與index[1] = 1相同，不做動作) 2,1,1,2 (index[0] = 1與index[2] = 2不相同，互換並產生支線) 2,1,1,2 (index[1] = 1與index[2] = 1相同，不做動作) 2,2,1,1 (index[1] = 1與index[3] = 2不相同，互換並產生支線) 2,2,1,1 (index[2] = 1與index[3] = 1相同，不做動作，支線遞迴結束) 2,1,2,1 (index[2] = 1與index[3] = 2不相同，互換並產生支線) 1,1,1,2 (index[0] = 1與index[3] = 2不相同，但之前跟2互換過一次，所以不做動作) 1,1,2,2 , index[1] 與後面所有後面的數相比 1,2,1,2 (index[1] = 1與index[2] = 2不相同，互換並產生支線) 1,2,2,1(index[2] = 1與index[3] = 2不相同，互換並產生支線) 走到最末端，遞迴結束 1,1,2,2 (index[1] = 1與index[3] = 2不相同，但之前跟2互換過一次，所以不做動作) 這邊如果互換的話將導致重複的數列出現 …….以下省略…..","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"}]},{"title":"【LeetCode】Add Two Numbers","slug":"【LeetCode】Add Two Numbers","date":"2018-06-05T13:10:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2018/06/05/【LeetCode】Add Two Numbers/","link":"","permalink":"https://toyo0103.github.io/2018/06/05/%E3%80%90LeetCode%E3%80%91Add%20Two%20Numbers/","excerpt":"","text":"有感於自己是個廢物工程師，開了LeetCode帳號好幾個月一題都還沒刷，所以決定寫一系列紀錄自己刷LeetCode的過程跟解題方法，希望幾年後回頭能看見自己的進步，廢話不多說直接進入題目。 #題目You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807 12345678910111213/** * Definition for singly-linked list. * public class ListNode &#123; * public int val; * public ListNode next; * public ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode AddTwoNumbers(ListNode l1, ListNode l2) &#123; &#125;&#125; #解題12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public ListNode AddTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode Result = new ListNode(0); ListNode CN1 = l1; ListNode CN2 = l2; ListNode RCN = Result; bool Flag = true; while (Flag) &#123; var Sum = RCN.val + GetNodeValue(CN1) + GetNodeValue(CN2); RCN.val = Sum % 10; if (Sum &gt; 9) RCN.next = new ListNode(1); CN1 = CN1 == null ? null : CN1.next; CN2 = CN2 == null ? null : CN2.next; Flag = (CN1 != null || CN2 != null); if (Flag &amp;&amp; RCN.next == null) RCN.next = new ListNode(0); RCN = RCN.next; &#125; return Result; &#125; private int GetNodeValue(ListNode node) &#123; return node == null ? 0 : node.val; &#125; &#125; Unit Testing1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071[TestClass]public class SolutionTests&#123; [TestMethod] public void AddTwoNumbersTest_輸入L1為342_L2為456_應得到807() &#123; //arrange var l1 = new ListNode(2); l1.next = new ListNode(4); l1.next.next = new ListNode(3); var l2 = new ListNode(5); l2.next = new ListNode(6); l2.next.next = new ListNode(4); var sut = new Solution(); var expected = new ListNode(7); expected.next = new ListNode(0); expected.next.next = new ListNode(8); //act var actual = sut.AddTwoNumbers(l1,l2); //assert actual.Should().BeEquivalentTo(expected); &#125; [TestMethod] public void AddTwoNumbersTest_輸入L1為42_L2為708_應得到750() &#123; //arrange var l1 = new ListNode(2); l1.next = new ListNode(4); var l2 = new ListNode(8); l2.next = new ListNode(0); l2.next.next = new ListNode(7); var sut = new Solution(); var expected = new ListNode(0); expected.next = new ListNode(5); expected.next.next = new ListNode(7); //act var actual = sut.AddTwoNumbers(l1, l2); //assert actual.Should().BeEquivalentTo(expected); &#125; [TestMethod] public void AddTwoNumbersTest_輸入L1為1_L2為99_應得到100() &#123; //arrange var l1 = new ListNode(1); var l2 = new ListNode(9); l2.next = new ListNode(9); var sut = new Solution(); var expected = new ListNode(0); expected.next = new ListNode(0); expected.next.next = new ListNode(1); //act var actual = sut.AddTwoNumbers(l1, l2); //assert actual.Should().BeEquivalentTo(expected); &#125;&#125; #分析結果雖然過了但是效率不佳，執行完LeetCode全部的測試總共花費 176 ms只贏過38.84%的提交範例，所以試試看優化它 移除三元運算子基本上三元運算子比較耗效能，所以優先改進它 原本 1234private int GetNodeValue(ListNode node)&#123; return node == null ? 0 : node.val;&#125; 修改後 123456789private int GetNodeValue(ListNode node)&#123; if (node == null) &#123; return 0; &#125; return node.val;&#125; 原本 12CN1 = CN1 == null ? null : CN1.next;CN2 = CN2 == null ? null : CN2.next; 修改後 12345if (Node1Cursor != null) Node1Cursor = Node1Cursor.next;if (Node2Cursor != null) Node2Cursor = Node2Cursor.next; 測試結果 簡直是三元運算子定生死…. 優化可讀性 乾淨的程式碼，閱讀起來應該像是幾何證明般 Uncle Bob 所以試著讓變數命名更貼近意義一點 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution&#123; public ListNode AddTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode Result = new ListNode(0); ListNode Node1Cursor = l1; ListNode Node2Cursor = l2; ListNode Head = Result; bool NeedNextRun = true; while (NeedNextRun) &#123; var Sum = Head.val + GetNodeValue(Node1Cursor) + GetNodeValue(Node2Cursor); Head.val = Sum % 10; if (Sum &gt; 9) Head.next = new ListNode(1); if (Node1Cursor != null) Node1Cursor = Node1Cursor.next; if (Node2Cursor != null) Node2Cursor = Node2Cursor.next; NeedNextRun = (Node1Cursor != null || Node2Cursor != null); if (NeedNextRun &amp;&amp; Head.next == null) Head.next = new ListNode(0); Head = Head.next; &#125; return Result; &#125; private int GetNodeValue(ListNode node) &#123; if (node == null) &#123; return 0; &#125; return node.val; &#125;&#125; 也因為有寫單元測試的關係，上述的調整過程中都沒讓程式壞掉，最後希望藉由這樣的練習能讓自己TDD與重構的技巧再更純熟一些","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"}]},{"title":"【MVC教學】7.驗證參數-DataAnnotations","slug":"【MVC教學】7.驗證參數-DataAnnotations ","date":"2018-06-05T03:40:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2018/06/05/【MVC教學】7.驗證參數-DataAnnotations /","link":"","permalink":"https://toyo0103.github.io/2018/06/05/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%917.%E9%A9%97%E8%AD%89%E5%8F%83%E6%95%B8-DataAnnotations%20/","excerpt":"","text":"Demo範例 ：Git位置 #什麼是DataAnnotationsDataAnnotations是.Net Framework 3.5之後提供的一個命名空間，裡面包含了一些基本的驗證Attribute，同時也提供客製化的方法，希望開發人員能透過簡單的加上Attribute即達到驗證的效果。 12345678public class UserSignUpParameter&#123; /// &lt;summary&gt; /// 帳號 /// &lt;/summary&gt; [Required] public string Account &#123; get; set; &#125;&#125; #如何使用我們透過修改先前的範例，嘗試將UserSignUpParameter的驗證從FluentValidation改成用MVC預設提供的DataAnnotations來達成，從修改中學習他是如何運作的。 重新審視一下需求 帳號必填必須包含@密碼必填不得小於6個字元 RequiredAttributeRequiredAttribute為DataAnnotations預設提供的驗證方式，目標是驗證該欄位是否為Null或Empty 1234567891011121314151617181920212223242526272829303132333435//// 摘要:// 指定資料欄位值為必要。[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]public class RequiredAttribute : ValidationAttribute&#123; // // 摘要: // 初始化 System.ComponentModel.DataAnnotations.RequiredAttribute 類別的新執行個體。 public RequiredAttribute(); // // 摘要: // 取得或設定值，指出是否允許空字串。 // // 傳回: // true 如果允許空字串。否則， false。 預設值是 false。 public bool AllowEmptyStrings &#123; get; set; &#125; // // 摘要: // 檢查必要的資料欄位的值不是空的。 // // 參數: // value: // 要驗證的資料欄位值。 // // 傳回: // true 如果驗證成功。否則， false。 // // 例外狀況: // T:System.ComponentModel.DataAnnotations.ValidationException: // 資料欄位值為 null。 public override bool IsValid(object value);&#125; 從上述的程式碼可以看出它有提供AllowEmptyStrings的屬性可以設定，意義如同字面意思，可以EmptyString。 AllowEmptyStrings我們先將Account掛上Required，並且指定屬性AllowEmptyStrings為True，執行看看 繼承自Attribute的類別，在掛Attribute時可以省略後綴詞，所以可以看到程式碼只寫Required而不是RequiredAttribute 12345678910111213141516/// &lt;summary&gt;/// Parameter UserSignUp/// &lt;/summary&gt;public class UserSignUpParameter&#123; /// &lt;summary&gt; /// 帳號 /// &lt;/summary&gt; [Required(AllowEmptyStrings =true)] public string Account &#123; get; set; &#125; /// &lt;summary&gt; /// 密碼 /// &lt;/summary&gt; public string Password &#123; get; set; &#125;&#125; 當Account傳入為Null時 ModelState.IsValidate為False，在Values.Errors底下可以找到錯誤訊息Account 欄位是必要項。 接著改傳入空格 通過驗證 ErrorMessage如果想修改錯誤的回傳訊息時，可以透過ErrorMessage來處理 12345/// &lt;summary&gt;/// 帳號/// &lt;/summary&gt;[Required(ErrorMessage = &quot;帳號為必填欄位&quot;)]public string Account &#123; get; set; &#125; 或是 12345/// &lt;summary&gt;/// 帳號/// &lt;/summary&gt;[Required(ErrorMessage = &quot;&#123;0&#125;為必填欄位&quot;)]public string Account &#123; get; set; &#125; {0}的位置系統會自動帶入欄位名稱 介紹完RequiredAttribute的基本用法後，目前程式碼如下 1234567891011121314151617/// &lt;summary&gt;/// Parameter UserSignUp/// &lt;/summary&gt;public class UserSignUpParameter&#123; /// &lt;summary&gt; /// 帳號 /// &lt;/summary&gt; [Required(ErrorMessage = &quot;&#123;0&#125;為必填欄位&quot;)] public string Account &#123; get; set; &#125; /// &lt;summary&gt; /// 密碼. /// &lt;/summary&gt; [Required(ErrorMessage = &quot;&#123;0&#125;為必填欄位&quot;)] public string Password &#123; get; set; &#125;&#125; MinLengthAttributeMinLengthAttribute是用來檢查屬性的最小字數，與MaxLengthAttribute為剛好相反的一組 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// // 摘要: // 指定屬性中所允許之陣列或字串資料的最大長度。 [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)] public class MaxLengthAttribute : ValidationAttribute &#123; // // 摘要: // 初始化 System.ComponentModel.DataAnnotations.MaxLengthAttribute 類別的新執行個體。 public MaxLengthAttribute(); // // 摘要: // 初始化的新執行個體 System.ComponentModel.DataAnnotations.MaxLengthAttribute 類別根據 length // 參數。 // // 參數: // length: // 陣列或字串資料的最大容許長度。 public MaxLengthAttribute(int length); // // 摘要: // 取得陣列或字串資料所容許的最大長度。 // // 傳回: // 陣列或字串資料的最大容許長度。 public int Length &#123; get; &#125; // // 摘要: // 將格式套用到指定的錯誤訊息 // // 參數: // name: // 要包含在格式化字串中的名稱。 // // 傳回: // 描述可接受之最大長度的當地語系化字串。 public override string FormatErrorMessage(string name); // // 摘要: // 判斷指定的物件是否有效 // // 參數: // value: // 要驗證的物件。 // // 傳回: // 如果此值為 null 或是小於或等於指定的最大長度，則為 true，否則為 false。 // // 例外狀況: // T:System.InvalidOperationException: // 長度為零或小於 –1。 public override bool IsValid(object value); &#125; 密碼最少應為6個字元設定方式，當然它同時也提供修改ErrorMessage的方法 {0}的位置系統會自動帶入欄位名稱 {1}的位置系統會帶入所設定的最小字元數字 12345/// &lt;summary&gt;/// 密碼./// &lt;/summary&gt; [MinLength(6, ErrorMessage = &quot;&#123;0&#125;不得低於&#123;1&#125;個字元&quot;)]public string Password &#123; get; set; &#125; RegularExpressionAccount還有一個需求是必須包含@字元，這時候可以透過預設提供的RegularExpression來達成需求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// // 摘要: // 指定 ASP.NET 動態資料的資料欄位值必須符合指定的規則運算式。 [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)] public class RegularExpressionAttribute : ValidationAttribute &#123; // // 摘要: // 初始化 System.ComponentModel.DataAnnotations.RegularExpressionAttribute 類別的新執行個體。 // // 參數: // pattern: // 用來驗證資料欄位值的規則運算式。 // // 例外狀況: // T:System.ArgumentNullException: // pattern 為 null。 public RegularExpressionAttribute(string pattern); // // 摘要: // 取得規則運算式模式。 // // 傳回: // 要比對模式。 public string Pattern &#123; get; &#125; // // 摘要: // 取得或設定執行單一比對作業，直到作業逾時之前的時間 (以毫秒為單位)。 // // 傳回: // 執行單一比對作業的時間 (以毫秒為單位)。 public int MatchTimeoutInMilliseconds &#123; get; set; &#125; // // 摘要: // 格式化要顯示在規則運算式驗證失敗時的錯誤訊息。 // // 參數: // name: // 造成驗證失敗的欄位名稱。 // // 傳回: // 格式化的錯誤訊息。 public override string FormatErrorMessage(string name); // // 摘要: // 會檢查使用者輸入的值是否符合規則運算式模式。 // // 參數: // value: // 要驗證的資料欄位值。 // // 傳回: // true 如果驗證成功。否則， false。 // // 例外狀況: // T:System.ComponentModel.DataAnnotations.ValidationException: // 資料欄位值不符合規則運算式模式。 public override bool IsValid(object value); &#125; 可以透過寫正規表示法的方式來驗證想驗證的屬性，一樣有ErrorMessage可供使用 12345/// &lt;summary&gt;/// 帳號/// &lt;/summary&gt;[RegularExpression(&quot;[@]+&quot;,ErrorMessage =&quot;&#123;0&#125;必須包含@字元&quot;)]public string Account &#123; get; set; &#125; 其它AttributeDataAnnotations還有提供一些預設的Attribute可以使用，篇幅有限就不一一介紹，有興趣的可以參考以下文章 How To Validate MVC Model Using DataAnnotation AttributeMSDN - ValidationAttribute 類別 #客製如果碰到一個驗證需要在多個地方使用，且預設沒有提供的話，這時候就可以透過自製驗證Attribute來解決，我們以**字元需包含@**為例 繼承ValidationAttribute1234567891011121314public class MouseCharactersAttribute: ValidationAttribute &#123; /// &lt;summary&gt; /// Returns true if ... is valid. /// &lt;/summary&gt; /// &lt;param name=&quot;value&quot;&gt;要驗證之物件的值。&lt;/param&gt; /// &lt;returns&gt; /// &lt;see langword=&quot;true&quot; /&gt; 指定的值是否有效。否則， &lt;see langword=&quot;false&quot; /&gt;。 /// &lt;/returns&gt; public override bool IsValid(object value) &#123; return base.IsValid(value); &#125; &#125; Override IsValid Method1234567891011public override bool IsValid(object value) &#123; if (value == null) &#123; return false; &#125; var stringValue = value as string; return stringValue.Contains(&quot;@&quot;); &#125; 將原本的RegularExpression改成我們客製的MouseCharacters 12345/// &lt;summary&gt; /// 帳號 /// &lt;/summary&gt; [MouseCharacters(ErrorMessage =&quot;&#123;0&#125;必須包含@字元&quot;)] public string Account &#123; get; set; &#125; 實測會發現結果是一樣的 #比較FluentValidationDataAnnotations其實使用起來相當方便，且只要知道如何客製ValidationAttribute基本上大部分情境都能解決，加上套用Attribute的方式算是相當親民的寫法。 但我本身基於單一職責的原則下，還是喜歡將驗證邏輯等方法分離到不同的Class管理，而這也正是FluentValidation套件的特性，不過這是見仁見智，就像大部分Pattern一樣，永遠不會有最好的解法，只要能花最小的成本解決需求，同時盡量不犧牲維護及擴充性，那就稱得上是好方法了。","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"【演算法】Counting Sort","slug":"【演算法】Counting Sort","date":"2018-06-04T06:42:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2018/06/04/【演算法】Counting Sort/","link":"","permalink":"https://toyo0103.github.io/2018/06/04/%E3%80%90%E6%BC%94%E7%AE%97%E6%B3%95%E3%80%91Counting%20Sort/","excerpt":"","text":"何謂Counting Sort是一種排序的演算法，特色是不需要比較數字間的大小，而是透過計算在Array中的Index的位置來達到排序的效果，限制是必須先知道數字的範圍以及數字組的個數，屬於線性排序 O(n) 。 案例一 Suppose you have an array of 1000 integers. The integers are in random order, but you know each of the integers is between 1 and 5000 (inclusive). In addition, each number appears only once in the array. Assume that you can access each element of the array only once. Describe an algorithm to sort it. 假設你有個數字陣列其中包含1000個數字，且這些數字來自1~5000之間不重複，請用一組演算法來達成只讀取數字一次並排序完成。 解題欲排序的陣列 1234//隨機取1000個int Amount = 1000;//隨機從1~5000中取出不重複的1000個數字int[] IntPool = Enumerable.Range(1, 5000).OrderBy(x =&gt; Guid.NewGuid()).Take(Amount).ToArray(); 準備一個的數字陣列，空間為5000 1int[] IndexArray = new int[5000]; 計算哪些位置應該存在數字 1234foreach (var element in IntPool)&#123; IndexArray[ element -1 ] ++;&#125; 將IndexArray中值為1的挑出來 123456789101112int[] Result = new int[1000];var Index = 0;for (int i = 0; i &lt; IndexArray.Length; i++)&#123; if (IndexArray[i] &gt; 0) &#123; Result[Index] = i + 1; Index++; &#125;&#125;//此時Result即為排序後的結果 案例二 假設你有個數字陣列其中包含1000個數字，這些數字來自1~5000之間且可能會重複，如何用Counting Sort達成排序 解題欲排序的陣列 123456Random Rnd = new Random();int[] IntPool =new int[1000];for (int i = 0; i &lt; 1000; i++)&#123; IntPool[i] = Rnd.Next(1,5001);&#125; 找出最大值與最小值 12345678910int Min = IntPool[0];int Max = IntPool[0];for (int i = 1; i &lt; IntPool.Length; i++)&#123; if (IntPool[i] &gt; Max) Max = IntPool[i]; if (IntPool[i] &lt; Min) Min = IntPool[i];&#125; 準備一個能容納最大範圍的IndexArray 1int[] IndexArray = new int[Max - Min +1]; 計算每個數字在IndexArray中的相對位置，並統計每個位置重複的數字數 12345foreach (var element in IntPool)&#123; //統計每個位置有幾個重複的數字 IndexArray[element - Min] ++;&#125; 計算每個位置累積的數字個數這邊是我想比較久的地方，所以畫了一個圖希望能幫助理解，假設我們算出來後陣列長這樣，表示Index 0放著2個數字，Index 2有1個數字，Index 4有1個數字以此類推所以如果我們將每個位置的數字與前一格相加，可以得到該Index實際上已經排了幾個數字， 計算到達該位子時，實際上總共已經有幾個數字 1234for (int i = 1; i &lt; IndexArray.Length; i++)&#123; IndexArray[i] = IndexArray[i] + IndexArray[i - 1];&#125; 排序 12345678910int[] Result = new int[1000];foreach (var element in IntPool)&#123; var TotalCount = IndexArray[element - Min]; //第幾個數字-1，其實就表示他要放在Result的Index位置 Result[TotalCount- 1] = element; IndexArray[element - Min] --;&#125;//此時Result即為排序後的結果","categories":[],"tags":[{"name":"演算法","slug":"演算法","permalink":"https://toyo0103.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"}]},{"title":"【MVC教學】6.驗證參數- 透過FluentValidation","slug":"【MVC教學】6.驗證參數-透過FluentValidation","date":"2018-05-07T10:23:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2018/05/07/【MVC教學】6.驗證參數-透過FluentValidation/","link":"","permalink":"https://toyo0103.github.io/2018/05/07/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%916.%E9%A9%97%E8%AD%89%E5%8F%83%E6%95%B8-%E9%80%8F%E9%81%8EFluentValidation/","excerpt":"","text":"Demo範例 ：Git位置 上一篇簡介了Controller如何安排程式邏輯流程、驗證參數，卻也發現了驗證參數導致程式寫得冗長不易維護，這一篇要介紹【FluentValidation】這個套件來解決這個問題。 安裝 設定把之前的程式碼稍作整理，將Account與Password新建一個類型(Class)來封裝起來，原本Controller裡面的程式整理一下 自定義驗證Class建立一個Class命名為UserSignUpParameterValidation 將UserSignUpParameter掛上Validator Attribute，意思是UserSignUpParameter請幫我用UserSignUpParameterValidation裡面的邏輯來驗證 帳號密碼不能為空值 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// Validation UserSignUpParameter/// &lt;/summary&gt;/// &lt;seealso cref=&quot;FluentValidation.AbstractValidator&#123;HelloDotNetMVC.Parameters.UserSignUpParameter&#125;&quot; /&gt;public class UserSignUpParameterValidation:AbstractValidator&lt;UserSignUpParameter&gt;&#123; public UserSignUpParameterValidation() &#123; //AbstractValidator為FluentValidation提供的抽象類別 //目的是讓使用者可以透過繼承這個抽象類別後，實作自己的驗證邏輯 //而泛型T， AbstractValidator&lt;T&gt; ，則帶入你想驗證的類別 //所以這邊帶入UserSignUpParameter，這個我們剛剛製作的Class //Account RuleFor(x =&gt; x.Account) .NotEmpty() .WithMessage(&quot;帳號不能為Empty&quot;) .NotNull() .WithMessage(&quot;帳號不能為Null&quot;); //Password RuleFor(x=&gt;x.Password) .NotEmpty() .WithMessage(&quot;密碼不能為Empty&quot;) .NotNull() .WithMessage(&quot;密碼不能為Null&quot;); &#125;&#125; RuleFor是FluentValidation提供的方法，意思是我為Account這個屬性建立驗證的Rule，而Rule分別是，NotEmpty(不能為空值)、NotNull(不能為Null)，而緊接在每個驗證邏輯下面的WithMessage則是表示，當發生它上面的錯誤時，錯誤訊息請回傳這行。 接著我們可以將Controller的這塊驗證邏輯拿掉，交給UserSignUpParameterValidation專責處理就好。 帳號必須包含@字元，Password必須大於6個字因為判斷字元@並不像判斷空值與Null一樣，官方有實做好的方法，必須自己透過Must來定義，這邊提供兩種寫法給讀者參考 上面是匿名方法的寫法，但如果你對於匿名委派還不是很熟悉，也可以用比較簡單的方式寫 [![](https://4.bp.blogspot.com/-KmJSyZdiGb0/WvAWiccBedI/AAAAAAAAIvw/17gYP6xPzgIUFII1ptocXolNHkBXfGeegCLcBGAs/s400/11.png)](https://4.bp.blogspot.com/-KmJSyZdiGb0/WvAWiccBedI/AAAAAAAAIvw/17gYP6xPzgIUFII1ptocXolNHkBXfGeegCLcBGAs/s1600/11.png) 先寫好驗證的方法，然後在Must中帶入方法。 延伸閱讀 :MSDN : Func&lt;T,TResult&gt; 委派MSDN : 匿名方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// &lt;summary&gt;/// Validation UserSignUpParameter/// &lt;/summary&gt;/// &lt;seealso cref=&quot;FluentValidation.AbstractValidator&#123;HelloDotNetMVC.Parameters.UserSignUpParameter&#125;&quot; /&gt;public class UserSignUpParameterValidation:AbstractValidator&lt;UserSignUpParameter&gt;&#123; public UserSignUpParameterValidation() &#123; //AbstractValidator為FluentValidation提供的抽象類別 //目的是讓使用者可以透過繼承這個抽象類別後，實作自己的驗證邏輯 //而泛型T， AbstractValidator&lt;T&gt; ，則帶入你想驗證的類別 //所以這邊帶入UserSignUpParameter，這個我們剛剛製作的Class //Account RuleFor(x =&gt; x.Account) .NotEmpty() .WithMessage(&quot;帳號不能為Empty&quot;) .NotNull() .WithMessage(&quot;帳號不能為Null&quot;) .Must(IncludeAccountKeyword) .WithMessage(&quot;帳號不符合格式&quot;); //Password RuleFor(x=&gt;x.Password) .NotEmpty() .WithMessage(&quot;密碼不能為Empty&quot;) .NotNull() .WithMessage(&quot;密碼不能為Null&quot;) .MinimumLength(7) .WithMessage(&quot;密碼必須大於6個字元&quot;); &#125; /// &lt;summary&gt; /// Accounts 必須包含@. /// &lt;/summary&gt; /// &lt;param name=&quot;account&quot;&gt;The account.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private bool IncludeAccountKeyword(string account) &#123; if (!string.IsNullOrWhiteSpace(account)) &#123; return account.Contains(&quot;@&quot;); &#125; return false; &#125;&#125; 整理後的Controller 透過ModelState得知驗證結果 ModelState是本來MVC就有提供的參數驗證方式，而使用方法這邊提供幾篇文章給有興趣的讀者參考What is the ModelState? - ASP.NET MVC Demystified保哥 : ASP.NET MVC 開發心得分享 (28)：深入了解 ModelState 內部細節 而因為開發習慣的關係，我習慣用FluentValidation的方式來取代原本ModelState驗證方法與設定方式，接著我們在Global.asax中呼叫FluentValidationModelValidatorProvider.Configure() 1234567891011121314151617181920212223242526272829[HttpPost]public ActionResult SignUp(UserSignUpParameter parameter)&#123; if (!ModelState.IsValid) &#123; //IsValida為False時，表示驗證參數不過 //取出第一筆錯誤訊息回傳 var Error = ModelState.Values.SelectMany(x =&gt; x.Errors).First(); TempData[&quot;Message&quot;] = Error.ErrorMessage; return RedirectToAction(&quot;signup&quot;, &quot;user&quot;); &#125; //這邊沒有搬到FluentValidation去驗證的原因是 //使用者存在與否比較屬於服務層的事情，通常需要讀取資料庫才能判斷 //開發上習慣盡量讓驗證參數越乾淨簡單越好，而不是在裡面呼叫很多外部服務(例如資料庫)後做驗證 //這會讓職責過於複雜 if (parameter.Account != &quot;steven@mymail.com&quot;) &#123; TempData[&quot;Message&quot;] = &quot;註冊成功!!&quot;; //註冊成功,導到首頁 return RedirectToAction(&quot;index&quot;, &quot;home&quot;); &#125; else &#123; TempData[&quot;Message&quot;] = &quot;帳號已經存在&quot;; return RedirectToAction(&quot;signup&quot;, &quot;user&quot;); &#125;&#125; 接著執行程式，驗證看看是否之前的驗證邏輯都還是正常運作。 比較一下最一開始與套用FluentValidation後的程式碼，應該可以明顯感受到差異，這不僅僅只是讓程式變乾淨，更重要的是驗證參數的職責被分離到UserSignUpParameterValidation這個類別中，以後要改參數驗證的邏輯只要到這調整即可，不用再擔心Controller會被不小心改壞。 延伸閱讀FluentValidation : 官方文件、各種API使用方法FluentValidation : 擴充驗證方法FluentValidation : 繼承父類別的驗證","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"【MVC教學】5.Controller簡介","slug":"【MVC教學】5.Controller簡介","date":"2018-04-25T15:08:00.000Z","updated":"2022-08-09T13:36:17.090Z","comments":true,"path":"2018/04/25/【MVC教學】5.Controller簡介/","link":"","permalink":"https://toyo0103.github.io/2018/04/25/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%915.Controller%E7%B0%A1%E4%BB%8B/","excerpt":"","text":"Demo範例 ： Git位置 前面幾篇解說了Route設定，讓我們的程式能順利找到對應的Controller來執行，那今天要來談談Controller幫我們做些什麼？我們通常會在Controller這層就將使用者的參數驗證完畢，並且依據傳入的參數，找到對應的商業邏輯去執行，並且回傳結果給使用者知道，已註冊頁面作為實際應用來解說。 接著我們來實作上述的內容，但因為只是MVC初學，所以我們還不加入分層、資料庫溝通之類比較深的內容，只專注在Controller怎麼做。 &nbsp; 建立Controller&nbsp;我們先建立一個UserController，專門處理User相關的服務跟邏輯 接著寫一個SignUp的Action，這邊有看到我們掛HttpGet的Attribute，只是指定呼叫動詞必須是Get的方式才會執行到這個Action 如果不知道Http動詞的話可以參考 : HTTP請求方法 [![](https://1.bp.blogspot.com/-KA_M1a5AopU/WuCDeRZvUuI/AAAAAAAAIrI/C66BwZf0wvw7Z2PDngjof-IgAzSwUE3bwCEwYBhgL/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-25%2B%25E4%25B8%258B%25E5%258D%25889.32.27.png)](https://1.bp.blogspot.com/-KA_M1a5AopU/WuCDeRZvUuI/AAAAAAAAIrI/C66BwZf0wvw7Z2PDngjof-IgAzSwUE3bwCEwYBhgL/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-25%2B%25E4%25B8%258B%25E5%258D%25889.32.27.png) &nbsp; 建立View&nbsp;而這個Action沒有任何內容，只有回傳一個View而已，接著我們來實作出回傳的頁面，在這個Action中點擊右鍵 &gt; 新增檢視 接著直接執行，應該就能看到我們剛剛做出來的SignUp頁面 而這邊網址是 /user/signup，我覺得不夠直覺，所以到RouteConfig改一下 接著把頁面簡單做起來 寫一個Action來接收傳過來的資料 1234567891011121314151617181920212223242526272829303132333435363738394041424344[HttpPost]public ActionResult SignUp(string account,string password)&#123; bool Result = false; //帳號密碼都不能為空值 if (!string.IsNullOrWhiteSpace(account) &amp;amp;&amp;amp; !string.IsNullOrWhiteSpace(password)) &#123; //帳號必須要有@字元 //密碼必須大於六個字元 if (account.Contains(&quot;@&quot;) &amp;amp;&amp;amp; password.Length &amp;gt; 6) &#123; //我們判斷是否有註冊過的帳號,因為還沒有連結資料庫 //所以先假定steven@mymail.com被註冊過 if (account != &quot;steven@mymail.com&quot;) &#123; TempData[&quot;Message&quot;] = &quot;註冊成功!!&quot;; Result = true; &#125; else &#123; TempData[&quot;Message&quot;] = &quot;帳號已經存在&quot;; &#125; &#125; else &#123; TempData[&quot;Message&quot;] = &quot;帳號密碼不符合格式&quot;; &#125; &#125; else &#123; TempData[&quot;Message&quot;] = &quot;帳號密碼不能為空值&quot;; &#125; if (Result) &#123; //註冊成功,導到首頁 return RedirectToAction(&quot;index&quot;, &quot;home&quot;); &#125; else &#123; return RedirectToAction(&quot;signup&quot;, &quot;user&quot;); &#125;&#125; 這邊注意到我們的Attribute就下了HttpPost，表示只有Post可以呼叫到這個Action，而我們在Form那邊也設定了方法用Post 接著你可能會注意到裡面有用到TempData，通常TempData是用來跨Action傳遞資料用的，底層其實是將資料存在Session之中，而且你只要取用過一次裡面的值就會被清掉。 而因為我們這個Action只是在處理註冊的相關邏輯，執行完後可以看到最後回傳的都是RedirectToAction，也就是導到我們指定的Action去回傳頁面，所以會跨兩個Action以上，存在TempData是個簡單的處理方式。 接著執行看看你會發現，好像一切有照著我們的邏輯在執行，但唯獨訊息不會顯示出來，因為我們雖然將TempData之中，卻沒有寫顯示訊息的那一段，通常這一段邏輯我們會放在共用的_Layout裡面。 因為還沒解說View的關係，這邊就先照著寫，之後會解說到。再次執行就會發現訊息會正確S顯示出來了。 上述的Controller撰寫方式，就是通常我們在Controller做的工作，驗證參數 、 依據使用者輸入的值執行對應的邏輯 、最後回傳結果。但你應該也會發現，整個Action邏輯裡面光是驗證參數就佔了大半的篇幅，這往往會讓程式碼複雜度提高，閱讀變得困難，這部分我們會在下一篇講解該如何把這類的邏輯分隔出去，讓程式碼更好維護美觀一些。另外Action其實還可以回傳很多種結果，前面範例用到了 View ： 回傳頁面RedirectToAction ：回傳導頁結果 底層還支援了一些回傳方式，靈活應用就可以達成大部分的功能了。詳細參考：&nbsp;ＭＳＤＮ","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"雜湊表(Hash Table)","slug":"雜湊表-Hash-Table","date":"2018-04-25T06:42:00.000Z","updated":"2022-08-09T13:36:17.098Z","comments":true,"path":"2018/04/25/雜湊表-Hash-Table/","link":"","permalink":"https://toyo0103.github.io/2018/04/25/%E9%9B%9C%E6%B9%8A%E8%A1%A8-Hash-Table/","excerpt":"","text":"學生時期學資料結構跟演算法時，每次看到厚厚的課本加上一堆用C語言寫的範例，雖然都有修過，但說真的不知道它可以拿來做什麼? 直到出了社會開始寫一些專案要調教效能時，才發現原來以前學的是這麼厲害的東西阿。 開始前想先推薦一下這本書【**演算法圖鑑：26種演算法 + 7種資料結構，人工智慧、數據分析、邏輯思考的原理和應用全圖解**】，作者用簡單的圖解方式帶領讀者瞭解艱澀的資料結構與演算法的歷程，雖然要實際應用在專案中還需要一些內化，但已經比我以前的課本好多了(拭淚)，對這方面有興趣的非常推薦買這本書來看看 圖片出處:&nbsp;http://www.books.com.tw/products/0010771263 案例公司有派送Coupon券的需求，而條件是該券不能與過往中的任何一張重複，所以在產生Coupon券代碼後，最好跟以前的做一下比對來確保沒有發生重複的情形，而Coupon券為英數字12個字元格式，區分大小寫，比對方法想過以下幾種方式 1. 寫入時，用SQL語法的方式要求DB先搜尋確定沒有再寫 優點 : 寫法簡單 缺點 : 耗掉DB效能，當要寫入的筆數一多時，DB會出現效能瓶頸 2. 將全部的Coupon券撈出來後，進行比對，確定沒有再進行寫入 優點 : 因為是將資料撈出DB再從Application端做比對，所以對DB負擔較小 缺點 : 進行字串比對時該如何有效率執行是個問題，尤其是字串比對，如果處理方式不佳，也一樣會在Application端產生效能瓶頸 這邊我採取方式2並搭配雜湊表來解決，而為何要用雜湊表以下慢慢說明產生Coupon券的程式如下 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 隨機產生Couopn/// &lt;/summary&gt;/// &lt;param name=&quot;number&quot;&gt;幾位數&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string CreateNewCode(int number)&#123; string allChar = &quot;0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&quot;; string[] allCharArray = allChar.Split(&#x27;,&#x27;); string randomCode = string.Empty; Random rand = new Random(); int temp = -1; for (int i = 0; i &lt; number; i++) &#123; if (temp != -1) rand = new Random(i * temp * Guid.NewGuid().GetHashCode()); int t = rand.Next(62); if (temp != -1 &amp;&amp; temp == t) return CreateNewCode(number); temp = t; randomCode += allCharArray[t]; &#125; return randomCode;&#125; 執行方式 List如果你是寫C#的，那要比對是否有一樣的東西存在List中最快的方式就是用Any()這個方法，而我們知道List儲存方式實際是這樣 記憶體位置放置資料內容，而每個節點會記錄下一筆資料的記憶體位置在哪，所以List裡面的資料未必是一個相連的記憶體區段，但它只要知道開頭那筆資料，就可以依序將資料逐筆讀取出來。 換言之，如果要搜尋一個列表中是否有相同的資料存在，必須用線性的方式搜尋，也就是逐筆檢查，從第一筆開始每筆拿出來看看，直到比對到為止，最佳的狀況是第一筆就是你要比對的資料，最差，就是最後一筆才是你要的資料，而且搜尋的成本會隨著資料的增長而遞增。 1萬筆資料搜尋效能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182int 產生的資料筆數 = 10000;void Main()&#123; //準備要用來搜尋的資料 var Pools = CreateSearchPool(); //透過Stopwatch來看看實際搜尋要花費的時間 Stopwatch sw = new System.Diagnostics.Stopwatch(); Random rnd = new Random(); //總共花費的時間 double TotalTime = 0; //搜尋一百次 for (int i = 0; i &lt; 100; i++) &#123; //動態從產生的資料母體中抽一筆作為我們要搜尋的目標 var RandomIndex = rnd.Next(0, 產生的資料筆數 -1); //取出要搜尋的字 var Target = Pools[RandomIndex]; //碼表歸零 sw.Reset(); //碼表開始計時 sw.Start(); //透過Any方式對List做搜尋 var Result = Pools.Any(x=&gt; x == Target); //搜尋結束，碼錶停止 sw.Stop(); //將時間加上這次搜尋花費的時間，為毫秒 TotalTime += sw.Elapsed.TotalMilliseconds; &#125; //算出平均每次搜尋，耗費的秒數 (TotalTime /100).Dump();&#125;//建立要搜尋的母體private List&lt;string&gt; CreateSearchPool() &#123; List&lt;string&gt; Pool = new List&lt;string&gt;(); for (int i = 0; i &lt; 產生的資料筆數; i++) &#123; //動態新增Coupon資料 var Code = CreateNewCode(12); //丟進我們要用來搜尋Pool Pool.Add(Code); &#125; return Pool;&#125;// 隨機產生Couopn券代碼public string CreateNewCode(int number)&#123; string allChar = &quot;0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&quot;; string[] allCharArray = allChar.Split(&#x27;,&#x27;); string randomCode = string.Empty; Random rand = new Random(); int temp = -1; for (int i = 0; i &lt; number; i++) &#123; if (temp != -1) rand = new Random(i * temp * Guid.NewGuid().GetHashCode()); int t = rand.Next(62); if (temp != -1 &amp;&amp; temp == t) return CreateNewCode(number); temp = t; randomCode += allCharArray[t]; &#125; return randomCode;&#125; 實際算出來的平均搜尋時間為 0.083978(毫秒) 100萬筆資料搜尋效能將搜尋母體放大100倍，也就是從100萬筆資料中隨機抽樣搜尋100次，結果為8.540132(毫秒) 可以觀察到搜尋效率隨著資料量的增長快速遞減，而一百萬筆對於Coupon券來說其實不多，如果你的會員數有一萬人，每個人發到第100張時，總共發出去的數量就達到這個等級了 ，相信很多店商平台所產出的Coupon數遠遠大於這個量。 雜湊表雜湊表與List的最大差異是它非線性搜尋，它將所有要放入的資料先進行雜湊的方式算出一個值後，依據算出來的值放到對應的記憶體位置去，搜尋時也是先將要搜尋的值進行雜湊運算，算出對應位置，直接取出該記憶體的資料進行比對 特點是它非線性搜尋，也就是說它不需要抓到第一筆資料後，依序依據指標，往下找下一筆資料，即便不是還是要每筆遍尋才能知道結果，雜湊表的好處就在於，你要搜尋時，就已經知道該去哪找了。 而可能會有一個問題，那如果經過運算後，兩筆資料要儲存的地方一樣呢?這時候就是發生所謂的碰撞，一張好的雜湊表理論上要盡量避免碰撞發生，但現實中難以避免，所以進階的用法就是將相同位置內再放入List來存入更多筆資料。 這邊可能會有一個疑問是，那跟我一開始用List有什麼差別 ? 如果我們相信資料是平均分佈，那雜湊結果理論上也會平均分佈，但就如前面提的，現實中實在難以避免碰撞的發生，所以即便真的發生碰撞，我們也能確定List中的資料絕對不會有很多筆，多到導致效能瓶頸的發生。所以雜湊表的陣列該開出幾格來就是需要經過考量的，如果你有數百萬筆的資料，只開出100格，那最平均的結果就是每一格裡面會有1萬筆的資料，這顯然不理想。 1萬筆資料搜尋效能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115int 產生的資料筆數 = 10000;int 雜湊表格數 = 1000;void Main()&#123; //準備要用來搜尋的資料 var Pools = CreateSearchPool(); //透過Stopwatch來看看實際搜尋要花費的時間 Stopwatch sw = new System.Diagnostics.Stopwatch();//引用stopwatch物件 Random rnd = new Random(); //總共花費的時間 double TotalTime = 0; //搜尋一百次 for (int i = 0; i &lt; 100; i++) &#123; //動態從產生的資料母體中抽一筆作為我們要搜尋的目標 var RandomIndex = rnd.Next(0, 產生的資料筆數 - 1); //取出要搜尋的字 var Target = AllCode[RandomIndex]; //碼表歸零 sw.Reset(); //碼表開始計時 sw.Start(); //取得Hash後應該存放的位置 var HashPosition = GetHashPosition(Target); //從陣列中取出該筆資料 var PositionData = Pools[HashPosition]; //如果有資料 if (PositionData != null) &#123; //檢查這個List是否存在相同的Coupon代碼 var Result = PositionData.Any(x =&gt; x == Target); &#125; //碼錶停止 sw.Stop(); //將時間加上這次搜尋花費的時間，為毫秒 TotalTime += sw.Elapsed.TotalMilliseconds; &#125; //算出平均每次搜尋，耗費的秒數 (TotalTime / 100).Dump();&#125;List&lt;string&gt; AllCode =new List&lt;string&gt;();private List&lt;string&gt;[] CreateSearchPool() &#123; List&lt;string&gt;[] SearchPool = new List&lt;string&gt;[雜湊表格數]; for (int i = 0; i &lt; 產生的資料筆數; i++) &#123; var Code = CreateNewCode(12); AllCode.Add(Code); var p = GetHashPosition(Code); var PositionData = SearchPool[p]; if (PositionData == null) &#123; PositionData = new List&lt;string&gt;(); SearchPool[p] = PositionData; &#125; PositionData.Add(Code); &#125; return SearchPool;&#125;/// &lt;summary&gt;/// 隨機產生Couopn/// &lt;/summary&gt;/// &lt;param name=&quot;number&quot;&gt;幾位數&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string CreateNewCode(int number)&#123; string allChar = &quot;0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&quot;; string[] allCharArray = allChar.Split(&#x27;,&#x27;); string randomCode = string.Empty; Random rand = new Random(); int temp = -1; for (int i = 0; i &lt; number; i++) &#123; if (temp != -1) rand = new Random(i * temp * Guid.NewGuid().GetHashCode()); int t = rand.Next(62); if (temp != -1 &amp;&amp; temp == t) return CreateNewCode(number); temp = t; randomCode += allCharArray[t]; &#125; return randomCode;&#125;SHA256 sha256 = new SHA256CryptoServiceProvider();//取得Hash後應該存放的位置private int GetHashPosition(string code) &#123; var ByteArray = sha256.ComputeHash(Encoding.Default.GetBytes(code)); var IntResult = BitConverter.ToInt32(ByteArray, 0); //轉正 IntResult = Math.Abs(IntResult); //除格子數，餘數就是這筆資料該放的位置 return IntResult % 雜湊表格數;&#125; 實際算出來的平均搜尋時間為 0.004124(毫秒) 100萬筆資料搜尋效能一樣將數字放大到100萬筆，實際算出來的平均搜尋時間為 0.033612(毫秒)，可以發現即便搜尋筆數擴張了100倍，效率並沒有完全等比遞減 當然各種資料型態跟搜尋狀況不同，可能適用的資料結構與演算法也會略有不同要取捨，雜湊法也並非沒有缺點，例如在製作表時比較耗時，所以適合用在資料變動不大的情境，先將表做起來後放到快取去更新維護都是一些優化的方法，以上提供給大家參考。","categories":[],"tags":[{"name":"資料結構","slug":"資料結構","permalink":"https://toyo0103.github.io/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"}]},{"title":"【MVC教學】4. 為你的Route加一點限制","slug":"【MVC教學】4-為你的Route加一點限制","date":"2018-04-04T16:14:00.000Z","updated":"2022-08-09T13:36:17.090Z","comments":true,"path":"2018/04/05/【MVC教學】4-為你的Route加一點限制/","link":"","permalink":"https://toyo0103.github.io/2018/04/05/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%914-%E7%82%BA%E4%BD%A0%E7%9A%84Route%E5%8A%A0%E4%B8%80%E9%BB%9E%E9%99%90%E5%88%B6/","excerpt":"","text":"上一篇寫了Route比對的邏輯，這次來點更進階的應用，讓我們幫Route比對加上一些些限制。 假設今天About的頁面，他是依據網址帶入的 ID取得對應的會員資料，回傳結果，而ID必定為數字，如果不是數字就不要進到程式碼，直接擋掉該如何做？ 123//我們希望的網址，最後的ID一定要為數字/home/about/1 加上Constraints限制，而限制的方法用正規表示法來表達，以上述的只能為數字為例 [![](https://1.bp.blogspot.com/-DDzFIwOxsvQ/WsTtsAb1bgI/AAAAAAAAInA/pJdFwqPGRdIZ6LKQ-EgiXc2xem8FcQ4QACLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.22.03.png)](https://1.bp.blogspot.com/-DDzFIwOxsvQ/WsTtsAb1bgI/AAAAAAAAInA/pJdFwqPGRdIZ6LKQ-EgiXc2xem8FcQ4QACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.22.03.png) constraints的部分，我們把ID限制在只能出現數字，（如果對於正規表示法不熟悉的話，推薦可以翻翻這本書，就算記不起來拿來當工具書也很實用&nbsp;[處理大數據的必備美工刀 - 全支援中文的正規表示法精解](https://www.tenlong.com.tw/products/9789863759539)） 接著執行網站試試看 /home/about/123 [![](https://2.bp.blogspot.com/-5v8kKEHK7oQ/WsTve5DgK7I/AAAAAAAAInM/qCpoatJcmjED_wL1aP5zPUEnHuiVDzA1QCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.29.45.png)](https://2.bp.blogspot.com/-5v8kKEHK7oQ/WsTve5DgK7I/AAAAAAAAInM/qCpoatJcmjED_wL1aP5zPUEnHuiVDzA1QCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.29.45.png) 看起來沒問題，接著我們執行/home/about/Steven，這邊請記得把Default那組Route註解起來，如果還記得上篇Route比對方法的話，這組雖然會因為Steven不是數字而被About那組Route擋掉，但依然符合Default的萬用Route比對規則，而正確執行，為了測試請先註解掉Default那組。 [![](https://3.bp.blogspot.com/-97qSMhzIPOE/WsTwIiBOlMI/AAAAAAAAInU/Xb90Cy9gzJYsGtOuzXkPSL6bWfQszpr1ACLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.32.39.png)](https://3.bp.blogspot.com/-97qSMhzIPOE/WsTwIiBOlMI/AAAAAAAAInU/Xb90Cy9gzJYsGtOuzXkPSL6bWfQszpr1ACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.32.39.png) 如我們預期的，因為Steven不是數字的原因而被擋掉了，Constraints算是一個可以把Route用得更靈活的技巧，雖然需要懂的正規表示法，但我覺得這兩項學習投資很划算，正規表示法到很多地方都很萬用。 自訂更複雜的Constraints我們再來出個更刁的要求，假設你老闆就叫Steven，而且他不希望跟別人一樣，每個人都是打ID查資料顯示太一般，他偏偏要只有輸入Steven也要能進到About頁時該怎麼辦？ 當然也可以用正規表示法硬做，但可能會讓Constraint寫得很醜難維護，所以這次改用實作IRouteConstraint的方式來完成這個需求 建立一個StevenBossConstraint的Class[![](https://1.bp.blogspot.com/-lzkbxUNTjPs/WsTyHmO8DrI/AAAAAAAAInk/Z69_UKTgzw4Yiduel0QPOKVnIq9uNLP1ACLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.39.46.png)](https://1.bp.blogspot.com/-lzkbxUNTjPs/WsTyHmO8DrI/AAAAAAAAInk/Z69_UKTgzw4Yiduel0QPOKVnIq9uNLP1ACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.39.46.png) 實作以下內容 [![](https://3.bp.blogspot.com/-mCMOFMxoiQs/WsT0UDLnh5I/AAAAAAAAIn0/w7PzqK5RsyEabGIx9azbwzT2CZj6VlN6gCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.48.47.png)](https://3.bp.blogspot.com/-mCMOFMxoiQs/WsT0UDLnh5I/AAAAAAAAIn0/w7PzqK5RsyEabGIx9azbwzT2CZj6VlN6gCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.48.47.png) 將原本設定ID的Constrainte改成我們寫的StevenBossConstraint [![](https://3.bp.blogspot.com/-SXNFt3bhpRE/WsT1HLb4yzI/AAAAAAAAIn8/x04sB1B-ymwBSfdvYbCOrn4EcNjTaoFAwCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.51.38.png)](https://3.bp.blogspot.com/-SXNFt3bhpRE/WsT1HLb4yzI/AAAAAAAAIn8/x04sB1B-ymwBSfdvYbCOrn4EcNjTaoFAwCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.51.38.png) 執行後就會發現，數字跟Steven都可以通過Route的檢查，但你打Tom或是Tim之類的其他非數字參數，都會被擋掉 [![](https://2.bp.blogspot.com/-QOP-fMjmh1M/WsT1zhvaGSI/AAAAAAAAIoM/8GxzEl2aKKY0V2sSKZEo9zXqNg2qI7KJQCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.56.40.png)](https://2.bp.blogspot.com/-QOP-fMjmh1M/WsT1zhvaGSI/AAAAAAAAIoM/8GxzEl2aKKY0V2sSKZEo9zXqNg2qI7KJQCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.56.40.png) [![](https://2.bp.blogspot.com/-dV8vMrVM9rQ/WsT1z2-D7uI/AAAAAAAAIoQ/TJAfdgiSc_cu36opnnSktdBx9eULS0tXwCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.56.29.png)](https://2.bp.blogspot.com/-dV8vMrVM9rQ/WsT1z2-D7uI/AAAAAAAAIoQ/TJAfdgiSc_cu36opnnSktdBx9eULS0tXwCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.56.29.png) [![](https://3.bp.blogspot.com/-rAGzQD3L_c8/WsT1zmOtcFI/AAAAAAAAIoI/O7utdb1IfIUkMAK013X5TQwoo-QOvQ-pACLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.56.47.png)](https://3.bp.blogspot.com/-rAGzQD3L_c8/WsT1zmOtcFI/AAAAAAAAIoI/O7utdb1IfIUkMAK013X5TQwoo-QOvQ-pACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-04%2B%25E4%25B8%258B%25E5%258D%258811.56.47.png) 透過小工具來幫助偵錯Route設定可以透過Nuget來安裝Route Debugger工具，他們告訴我們目前網頁之所以能夠顯示，是因為走了哪一條Route規則，這在初期我對這些設定還不熟悉時幫助非常的大 [![](https://1.bp.blogspot.com/-OF3Lz23taZc/WsT2n5WMicI/AAAAAAAAIoc/yvgdxPJ_Dj84sOOWiZaf5KDe4m47nuFOQCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-05%2B%25E4%25B8%258A%25E5%258D%258812.00.15.png)](https://1.bp.blogspot.com/-OF3Lz23taZc/WsT2n5WMicI/AAAAAAAAIoc/yvgdxPJ_Dj84sOOWiZaf5KDe4m47nuFOQCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-05%2B%25E4%25B8%258A%25E5%258D%258812.00.15.png) 安裝這組套件[![](https://2.bp.blogspot.com/-MY03_784a74/WsT5eh-6T7I/AAAAAAAAIoo/fgvoj60WvfARLWeyjMfRHi_9onyYPdCmACLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-05%2B%25E4%25B8%258A%25E5%258D%258812.10.10.png)](https://2.bp.blogspot.com/-MY03_784a74/WsT5eh-6T7I/AAAAAAAAIoo/fgvoj60WvfARLWeyjMfRHi_9onyYPdCmACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-05%2B%25E4%25B8%258A%25E5%258D%258812.10.10.png) 接著重新執行網站就可在看到詳細解說 [![](https://1.bp.blogspot.com/-_GBLWNdFSoA/WsT51ZoPPkI/AAAAAAAAIos/A4wI4Ml7U9U1QjmMwGcIPe0LQCpVbra2QCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-05%2B%25E4%25B8%258A%25E5%258D%258812.13.24.png)](https://1.bp.blogspot.com/-_GBLWNdFSoA/WsT51ZoPPkI/AAAAAAAAIos/A4wI4Ml7U9U1QjmMwGcIPe0LQCpVbra2QCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-04-05%2B%25E4%25B8%258A%25E5%258D%258812.13.24.png) 相信剛開始要改Route的使用者來說，會是相當有幫助的工具喔！！","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"【MVC教學】3. Route(一)","slug":"【MVC教學】3-Route-一","date":"2018-03-17T12:54:00.000Z","updated":"2022-08-09T13:36:17.090Z","comments":true,"path":"2018/03/17/【MVC教學】3-Route-一/","link":"","permalink":"https://toyo0103.github.io/2018/03/17/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%913-Route-%E4%B8%80/","excerpt":"","text":"什麼是Route？ 在現實生活中比較接近於郵差與地圖的關係，你將想要送的東西交給郵差,郵差依據包裹上的地址，透過地圖找到目的地然後投遞。 而對應到程式中[網址]就是你包裹要送達的目的地址，Route就是[地圖]，而網址的[參數]就是你要投遞的包裹 [![](https://4.bp.blogspot.com/-v_OpLGzjdtw/Wq0MHMSi2mI/AAAAAAAAIko/7mcxcoPLkpUWExDOSn657rGCjMfUtiJSgCLcBGAs/s400/1.jpg)](https://4.bp.blogspot.com/-v_OpLGzjdtw/Wq0MHMSi2mI/AAAAAAAAIko/7mcxcoPLkpUWExDOSn657rGCjMfUtiJSgCLcBGAs/s1600/1.jpg) 接著我們來看看專案內的Route在哪邊設定，又它是如何透過網址知道該把[包裹]送去哪支程式的，這邊先把我們之前的專案執行起來，並且點擊[關於] [![](https://1.bp.blogspot.com/-ryN1Z3Mp3SI/Wq0MU9PT8mI/AAAAAAAAIks/ONCnMFBGRhYG0YWmLnZUV__5jGS5gpBBgCLcBGAs/s400/2.png)](https://1.bp.blogspot.com/-ryN1Z3Mp3SI/Wq0MU9PT8mI/AAAAAAAAIks/ONCnMFBGRhYG0YWmLnZUV__5jGS5gpBBgCLcBGAs/s1600/2.png) 可以看到關於頁的網址為 /Home/About [![](https://4.bp.blogspot.com/-F1fHYAInGic/Wq0MkAgp4uI/AAAAAAAAIkw/PN3nKltrc5wH8Lkb9Lk5_6flzLCy80GOACLcBGAs/s400/3.png)](https://4.bp.blogspot.com/-F1fHYAInGic/Wq0MkAgp4uI/AAAAAAAAIkw/PN3nKltrc5wH8Lkb9Lk5_6flzLCy80GOACLcBGAs/s1600/3.png) 接著我們在HomeController的About下中斷點後再點擊一次網頁的[關於]按鈕，會發現程式停在我們下中斷點的地方了？ 為什麼知道程式會跑到這邊呢 ? 這一切都是因為有Route指路的關係 [![](https://1.bp.blogspot.com/-LFueIPKzOYI/Wq0MwArDFLI/AAAAAAAAIk4/gJdWivFruxcZoCKaGNAfYamVnM8JEO3igCLcBGAs/s400/4.png)](https://1.bp.blogspot.com/-LFueIPKzOYI/Wq0MwArDFLI/AAAAAAAAIk4/gJdWivFruxcZoCKaGNAfYamVnM8JEO3igCLcBGAs/s1600/4.png) RouteConfigRoute的規則是可以自己制訂的，而制定的地方就在App_Start資料夾底下的RouteConfig裡面 [![](https://2.bp.blogspot.com/-empHw_-1tig/Wq0M_p2kL-I/AAAAAAAAIlA/XQjsx0UahlsjJyqijDxTtSa7hmnkJVm5ACLcBGAs/s400/5.png)](https://2.bp.blogspot.com/-empHw_-1tig/Wq0M_p2kL-I/AAAAAAAAIlA/XQjsx0UahlsjJyqijDxTtSa7hmnkJVm5ACLcBGAs/s1600/5.png) [![](https://3.bp.blogspot.com/-r4pEpAts3NA/Wq0NBNPYBKI/AAAAAAAAIlE/rUslCqFTfUEvvPRAG5cWKdDvL8S_CgGGQCLcBGAs/s400/6.png)](https://3.bp.blogspot.com/-r4pEpAts3NA/Wq0NBNPYBKI/AAAAAAAAIlE/rUslCqFTfUEvvPRAG5cWKdDvL8S_CgGGQCLcBGAs/s1600/6.png) 讓我們來解讀這段程式碼，首先routes.MapRoute就是註冊地址的方法，裡面有幾個參數分別為 Name : 你對於這個Route的命名 Url : 網址條件，當網址符合這個條件特徵時，就會依據這個Route的指示去找對應執行的程式碼 defaults : 參數的預設值 相信光是講解參數的意義對於要理解Route還有相當的距離，讓我們直接來實戰理解 /Home/About這串網址如何對應到Route的吧，剛剛有說，routes.MapRoute的Url參數是用來判斷網址特徵是否相符，如果相符就會被這串Route捕捉到，但是這兩個怎麼看都不像啊 真實網址 ： /Home/AboutRoute Url :&nbsp; {controller}/{action}/{id} 首先必須先知道一件事情，當Route Url的網址用{ }包起來的時候，代表他是個變數，什麼是變數？變數是一個表示值，它可以是任意的值，而{}裡面的字就是變數的名稱，以上述例子為例 我們有一個變數叫做controller，它可以是任意的值我們有一個變數叫做action，它可以是任意得值我們有一個變數叫做id，它也可以是任意的值 那套入/Home/About會變成什麼結果？ 我們有一個變數叫做controller，它現在的值是Home我們有一個變數叫做action，它現在的值是About我們有一個變數叫做id，它現在沒有值 而Route的制定中，**controller跟action****為保留字**，意思是告訴他要執行哪個controller跟Action，依據這邊的規定，所以它知道要去執行Home這個Controller，裡面一個叫做About的Action [![](https://3.bp.blogspot.com/-lPmkR6MJKWs/Wq0NMR-XeJI/AAAAAAAAIlM/NuECRMJtFww8ve031wVUqj-dnCa6K4FQgCLcBGAs/s400/7.png)](https://3.bp.blogspot.com/-lPmkR6MJKWs/Wq0NMR-XeJI/AAAAAAAAIlM/NuECRMJtFww8ve031wVUqj-dnCa6K4FQgCLcBGAs/s1600/7.png) 在Controller裡面寫的方法我們稱之為Action，而他通常都會回傳ActionResult 再讓我們看一個例子 ： [首頁] 首頁的網址為 : http://localhost:54004/ [![](https://1.bp.blogspot.com/-l2A_55syPtg/Wq0NzWKrZFI/AAAAAAAAIlg/NYnq1QMfQBUv9_fsyYczIqUSy4BW4ZHEQCLcBGAs/s400/8.png)](https://1.bp.blogspot.com/-l2A_55syPtg/Wq0NzWKrZFI/AAAAAAAAIlg/NYnq1QMfQBUv9_fsyYczIqUSy4BW4ZHEQCLcBGAs/s1600/8.png) 網址最前面這段寫著 Localhost :54004 ，Localhost為網址的Domain，54004為Port，Domain是網站的位置，例如我們在google搜尋Facebook時，會看到網址變成https://www.google.com.tw/search?q=facebook，而www.google.com.tw就是Domain，當讀到這串Domain時，就會透DNS找到Google的伺服器，然後呼叫它，並且請求他執行/search?q=facebook，這也是為什麼我們討論Route時沒有把Domain納進來，Domain只是讓網路能找到你服務的伺服器位置，後面才是你撰寫程式要處理的Route網址 所以首頁網址等於 &nbsp; 首頁網址 ： /Route Url :&nbsp; {controller}/{action}/{id} 我們有一個變數叫做controller，它現在沒有值我們有一個變數叫做action，它現在沒有值我們有一個變數叫做id，它現在沒有值 什麼都沒有，那程式到底要執行哪邊？ 這時候Default終於派上用場了，Default的意思就是，當沒有值時，請用我設定的值代替吧 [![](https://1.bp.blogspot.com/-TDgD-ND409Y/Wq0OX06AV7I/AAAAAAAAImc/CSNnXFgp6jkv3ajpzFLwlQuWyC8t7rBUgCEwYBhgL/s400/9.png)](https://1.bp.blogspot.com/-TDgD-ND409Y/Wq0OX06AV7I/AAAAAAAAImc/CSNnXFgp6jkv3ajpzFLwlQuWyC8t7rBUgCEwYBhgL/s1600/9.png) 所以 controller為空值，所以用Default的值代替，所以它的值為Homeaction為空值，所以用Default的值代替，所以它的值為Indexid為空直，但Default設定它為UrlParameter.Optional，意思是它是選擇性的，如果沒有沒關係 所以這個Route設定又完美符合了，所以依據條件，我們去HomeController的Index下中斷點，試試看進入首頁時是不是會停在這邊 [![](https://2.bp.blogspot.com/-3I8rJaSlSzI/Wq0OT3PebrI/AAAAAAAAIlo/gtyIS1YVuD83WLbI_Fh1huvHCyqCFcwUgCEwYBhgL/s400/10.png)](https://2.bp.blogspot.com/-3I8rJaSlSzI/Wq0OT3PebrI/AAAAAAAAIlo/gtyIS1YVuD83WLbI_Fh1huvHCyqCFcwUgCEwYBhgL/s1600/10.png) [![](https://3.bp.blogspot.com/-koCX4c7IthY/Wq0OT1iZPOI/AAAAAAAAIls/8Crncjqy5b0piO1OdxXPkaPVzgxpD2pzwCEwYBhgL/s400/11.png)](https://3.bp.blogspot.com/-koCX4c7IthY/Wq0OT1iZPOI/AAAAAAAAIls/8Crncjqy5b0piO1OdxXPkaPVzgxpD2pzwCEwYBhgL/s1600/11.png) 的確，他依據規則跑到了HomeController的Index Action了。 那舉一反三一下，換句話說首頁網址也可以是 /Home/Index 摟，試試看，你會發現它的確走到一樣的中斷點 [![](https://2.bp.blogspot.com/-PGK33fEJg-Q/Wq0OT4Pa-7I/AAAAAAAAImo/_9AR8OUt1Iga3IytGl1LuqwTxbsmNeWkwCEwYBhgL/s400/12.png)](https://2.bp.blogspot.com/-PGK33fEJg-Q/Wq0OT4Pa-7I/AAAAAAAAImo/_9AR8OUt1Iga3IytGl1LuqwTxbsmNeWkwCEwYBhgL/s1600/12.png) 你可能會說，那這樣Route還有什麼好學的，這個寫法幾乎萬用了啊？ 的確在ＭＶＣ預設專案中的這個Route設定我們通常稱它為萬用Route，但也因為它幾乎萬用，所以不好管理，所以正常來說都還是會制定自己的Route規則，好方便管理，這個之後慢慢寫專案碰到多了會更有感觸。 接著我們來試著修改一下程式，讓我們的{id}能派上用場吧！！在剛剛的案例中，因為id設定是Optional所以都沒派上用場，來試試看他怎麼用吧，首先我們先在HomeController的About Action中加入參數id，並且把回傳的訊息改成Your id is (你帶進來的值) [![](https://3.bp.blogspot.com/-FLI7MLnnMfw/Wq0OUuGGE3I/AAAAAAAAImk/nXWFNqHfTN8NUtq0rDJzxIB1jou_4DAdwCEwYBhgL/s400/13.png)](https://3.bp.blogspot.com/-FLI7MLnnMfw/Wq0OUuGGE3I/AAAAAAAAImk/nXWFNqHfTN8NUtq0rDJzxIB1jou_4DAdwCEwYBhgL/s1600/13.png) 接著我們重新執行一次程式，並且把網址改成/Home/About/Steven [![](https://2.bp.blogspot.com/-Zks5ZE30New/Wq0OUxoT8HI/AAAAAAAAIms/WxfowIPPItUnVcXErJ1H2FQPfHTWr58RgCEwYBhgL/s400/14.png)](https://2.bp.blogspot.com/-Zks5ZE30New/Wq0OUxoT8HI/AAAAAAAAIms/WxfowIPPItUnVcXErJ1H2FQPfHTWr58RgCEwYBhgL/s1600/14.png) 再練習一次Route比對 我們有一個變數叫做controller，它現在的值是Home我們有一個變數叫做action，它現在的值是About我們有一個變數叫做id，它現在的值是Steven 讓接著看中斷點，把滑鼠移到id那的參數會看到，Id依據我們下的網址，以Steven帶進來了 [![](https://3.bp.blogspot.com/-h6ZLvBxZDRE/Wq0OVDhncjI/AAAAAAAAImo/IL83Kj55bx4EQb6yZg5uz7jkxi9Poyq1QCEwYBhgL/s400/15.png)](https://3.bp.blogspot.com/-h6ZLvBxZDRE/Wq0OVDhncjI/AAAAAAAAImo/IL83Kj55bx4EQb6yZg5uz7jkxi9Poyq1QCEwYBhgL/s1600/15.png) 接著看網頁呈現的成果 [![](https://3.bp.blogspot.com/-4scpot89dZU/Wq0OVopL--I/AAAAAAAAImg/sdGZ1pxWLIMBO-ftiDpWhDA3l2f1tz7XwCEwYBhgL/s400/16.png)](https://3.bp.blogspot.com/-4scpot89dZU/Wq0OVopL--I/AAAAAAAAImg/sdGZ1pxWLIMBO-ftiDpWhDA3l2f1tz7XwCEwYBhgL/s1600/16.png) 練習制定一個屬於我們的Route 看了兩個範例，我們也來制定一個Route規則給自己用吧，而且我們不要用變數的方式。 [![](https://3.bp.blogspot.com/-cOBHu8_QRGw/Wq0OV84UZ2I/AAAAAAAAImo/GhiHQFpeFGkvHHlIju0NPcUDtmSpF9OmQCEwYBhgL/s400/17.png)](https://3.bp.blogspot.com/-cOBHu8_QRGw/Wq0OV84UZ2I/AAAAAAAAImo/GhiHQFpeFGkvHHlIju0NPcUDtmSpF9OmQCEwYBhgL/s1600/17.png) 我們希望有個網址為/tellMe/whoAreYou/{name}，且name跟之前的id一樣是個變數，可以由你自己打喜歡的文字來決定，寫完後來試試看這個route可不可行 [![](https://1.bp.blogspot.com/-DviuNDcFiHg/Wq0OWIgZMfI/AAAAAAAAImk/uDokBOMNij0mSGMLcLZsxjp63J7qOdKDwCEwYBhgL/s400/18.png)](https://1.bp.blogspot.com/-DviuNDcFiHg/Wq0OWIgZMfI/AAAAAAAAImk/uDokBOMNij0mSGMLcLZsxjp63J7qOdKDwCEwYBhgL/s1600/18.png) 結果竟然錯了，來看看少了什麼 網址 ： /tellMe/whoAreYou/stevenRoute Url :&nbsp; /tellMe/whoAreYou/{name} 比對tellMe，符合比對whoAreYou，符合比對Name這個變數，現在的值為Steven 然後呢？ 有沒有發現即便這邊都比對正確，符合route規則，但我們沒告訴他Controller是誰，Action是誰，程式當然不知道該去執行誰，所以再來改一下，因為我們還沒學到如何建立Controller跟Action，所以先用現成的， 導到homeController的Contact吧 [![](https://1.bp.blogspot.com/-qH5gM8_e5zA/Wq0OWghkjZI/AAAAAAAAImo/3gENq49UAPUaqw-ybuBoWEy2tlBNdeM6wCEwYBhgL/s400/19.png)](https://1.bp.blogspot.com/-qH5gM8_e5zA/Wq0OWghkjZI/AAAAAAAAImo/3gENq49UAPUaqw-ybuBoWEy2tlBNdeM6wCEwYBhgL/s1600/19.png) [![](https://2.bp.blogspot.com/-dSlvDEn3NLw/Wq0OW9IOoBI/AAAAAAAAIms/uPwgRJ_nwzkB6qAltJkNWfcSZGUu6h44wCEwYBhgL/s400/20.png)](https://2.bp.blogspot.com/-dSlvDEn3NLw/Wq0OW9IOoBI/AAAAAAAAIms/uPwgRJ_nwzkB6qAltJkNWfcSZGUu6h44wCEwYBhgL/s1600/20.png) 讓我們再試試看剛剛的網址 [![](https://1.bp.blogspot.com/-Pm-1-hAQ2Xc/Wq0OXEQrCpI/AAAAAAAAImo/7jBfE4xT3w8Y4QRu_iDmqrxtYcEk-8AgACEwYBhgL/s400/21.png)](https://1.bp.blogspot.com/-Pm-1-hAQ2Xc/Wq0OXEQrCpI/AAAAAAAAImo/7jBfE4xT3w8Y4QRu_iDmqrxtYcEk-8AgACEwYBhgL/s1600/21.png) 這次不會壞掉了，且正確的導到HomeController的Contact Action去，接著試試不帶{Name}會怎麼樣 [![](https://2.bp.blogspot.com/-qulCDWyyTIs/Wq0OXeD8fFI/AAAAAAAAIms/3CVn_ntnPms8AvxipLFd34dYGInhrSN_wCEwYBhgL/s400/22.png)](https://2.bp.blogspot.com/-qulCDWyyTIs/Wq0OXeD8fFI/AAAAAAAAIms/3CVn_ntnPms8AvxipLFd34dYGInhrSN_wCEwYBhgL/s1600/22.png) 變成找不到資源，為什麼？因為我們的Name沒有設定為UrlParameter.Optional，所以是必帶的參數，這邊要特別注意！！！ 之前教很多新人Route時很多人都卡在這邊 **Route**比對時必須完全符合才會被捕捉到 所以回頭審視我們的Route註冊目前有兩個規則 1.&nbsp;tellMe/whoAreYou/{name}2\\. {controller}/{action}/{id} 而我們帶的網址為 /tellMe/whoAreYou ，比對的規則將會是 由上到下，所以先比對了 1\\. **tellMe/whoAreYou/{name}** 的規則&nbsp;tellMe，符合whoAreYou，符合Route要求要有Name，且不是Optional，所以必帶，”不符合” 這段Route會被跳過，執行比對2\\. **{controller}/{action}/{id}&nbsp;**的規則Controller為tellMe，符合Action為WhoAreYou，符合Id為空值，因為為Optional，符合 所以實際程式去找的是TellMeController裡面的WhoAreYou這個Action，因為找不到這支程式所以顯示錯誤，而不是去執行規則1.的 HomeController的Contact這個Action。 這是新手常常會犯的觀念錯誤，所以特別舉這個例子希望能夠較清楚的比較跟釐清，而Route因為還有很多種設定，避免一次太多造成混亂，所以先到這邊。試著將上述的觀念釐清，對於之後撰寫MVC Route時會很有幫助","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"【MVC教學】2. 什麼是MVC","slug":"【MVC教學】2-什麼是MVC","date":"2018-02-22T14:31:00.000Z","updated":"2022-08-09T13:36:17.090Z","comments":true,"path":"2018/02/22/【MVC教學】2-什麼是MVC/","link":"","permalink":"https://toyo0103.github.io/2018/02/22/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%912-%E4%BB%80%E9%BA%BC%E6%98%AFMVC/","excerpt":"","text":"如果你本來跟我一樣是寫Dot Net Web的工程師,那你應該是從Web Form開始的,第一次接觸MVC時,應該心中都會浮現「什麼是MVC ?」 其實Wiki已經解釋得很清楚了,就不重複贅述這些定義,有興趣可以自己看看,而我比較想提的是這跟原本開發Web Form,或是說你是寫別語言但沒使用MVC這個架構時的差別。 還記得以前在接手前輩專案時,因為每個人開發習慣不盡相同,對於各種用途的類別可能都有一套自己的歸類方式,所以剛開始總是需要花大把時間在熟悉前輩定義的架構, 如果專案一多,常常切換專案時都會有一種混亂感。 如果遇到是初心工程師,可能會有那種一個Function幾百行的,基本上要改個東西都要找很久之外,還很怕改錯,而這些不僅僅造成維護的成本增加之外,還讓接手別人專案時總是滿滿恨意！！ 而MVC這個架構就是在解決這個問題,他將系統分成三大部分 Model 、View、 Controller, 而這三大部分分別管理著 Model : 資料的管理(例如與資料庫的溝通) , 演算法邏輯(商業邏輯) , 物件結構定義 View : 呈現給使用者看、操作的介面 Controller : 依據傳入的資料該怎麼運作、程式流程的控制、該回傳給使用者什麼資料等 [![](https://3.bp.blogspot.com/-ByxeEs_OPjo/Wo7SEU86Q2I/AAAAAAAAIkM/ILz4hUYI59gdspAfW_MxUekeTfa2ZaWCQCEwYBhgL/s640/2.jpg)](https://3.bp.blogspot.com/-ByxeEs_OPjo/Wo7SEU86Q2I/AAAAAAAAIkM/ILz4hUYI59gdspAfW_MxUekeTfa2ZaWCQCEwYBhgL/s1600/2.jpg)出處 https://helloacm.com/model-view-controller-explained-in-c/ 優點ㄧ ： 讓習慣代替配置因為大家對於MVC有相同的認識,且Dot Net MVC更把這些定義落實到專案上,在不改動底層運作的情況下,屬於Controller的Class就該放到Controllers的資料夾、屬於頁面呈現的就放到Views資料夾,且預設也有一個Models的資料夾給你放Model,有了這些規範後,讓習慣來代替配置,你接手別人的MVC專案後, 所有人的開發方式基本上都會依照這個規範去落實,降低維護的成本。 [![](https://4.bp.blogspot.com/-4aTMTqC7vZE/Wo7SSOsXq7I/AAAAAAAAIkY/aQAQWR1nxkATcDPTD2xx4nwxLUOqQYI-gCEwYBhgL/s400/1.png)](https://4.bp.blogspot.com/-4aTMTqC7vZE/Wo7SSOsXq7I/AAAAAAAAIkY/aQAQWR1nxkATcDPTD2xx4nwxLUOqQYI-gCEwYBhgL/s1600/1.png)Dot Net MVC預設新建專案就會有這些資料夾 優點二 ： 關注點分離如果今天是在處理使用者操作介面,那就專心的套版,將Controller傳回來的資料看要怎麼擺放,又如果在處理資料流傳入的參數驗證,那就在Controller處理完,不用去管會不會影響到View的呈現, 如果是跟資料庫的溝通,就在Model裡將它實作好,不需擔心是否參數有空值或Null, 因為那些該是在Controller處理掉的。 相較於以前的Web Form開發方式,因為UserControl介於頁面跟Code Behind的事件之間,常常耦合度太強,一改兩邊都會動到，需要較嚴謹的開發規範才能避免耦合問題,而且我記憶最深的就是UserControl間的生命週期,那個互相攪在一起要改還真要命… Web Form有其快速且便利性,以上並非說Dot Net MVC能完全取代Web Form,更想表達的是,這是當我從開發Web Form兩年然後跳到MVC目前5年多，它所帶給我的感受與改變,希望透過這些講述能更清楚MVC是否是你該投入資源學習的架構 優點三 ： 前端更自由在Dot Net MVC中,不再有User Control這類的元件存在,所以前端會更加的自由,無論是在JS或是CSS的運用上，再也不會有元件Render時幫你加上一堆多餘的Tag或是Class。 目前經手過的一些專案,有些都已經徹底前後端分離,後端只有負責處理好API或是ViewModel(傳給View的資料通常定義出來的Class都會叫ViewModel,這之後會再提到)，吐一個空的頁面載入指定JS,剩下就讓前端去處理介面,彼此分工更精細,互相耦合的程度也降低許多。 這篇花比較多篇幅在解說ＭVC是什麼,又Dot Net MVC在開發上能帶來什麼改變跟好處, 下一篇預計就要開始講Router 與 Controller之間的關係。","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"【MVC教學】1. 工欲善其事、必先利其器 Visual Studio","slug":"【MVC教學】1-工欲善其事、必先利其器-Visual-Studio","date":"2018-02-21T08:06:00.000Z","updated":"2022-08-09T13:36:17.090Z","comments":true,"path":"2018/02/21/【MVC教學】1-工欲善其事、必先利其器-Visual-Studio/","link":"","permalink":"https://toyo0103.github.io/2018/02/21/%E3%80%90MVC%E6%95%99%E5%AD%B8%E3%80%911-%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%E3%80%81%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8-Visual-Studio/","excerpt":"","text":"年前朋友討論是否寫Dot Net Mvc的簡單教學文章,害我過年都在思考該怎麼寫這東西…可惡(果然是個心裡容不下待辦事項的人啊)。 認真的想了後覺得這真是個非常難的主題,一來是網路上已經有很多資源,我也不是什麼大神,很怕誤人子弟。二來雖然以前曾經幫忙教育訓練過新進同事,但面對面的溝通且依照每個人程度不同給予討論,跟用文章教會一個不知道對象是誰,且博大精深的框架與語言,這個差距實在太大,所以最後只好一直將目標縮小再縮小,希望這系列文如果看完時能達到以下目標我就滿足了 **目標對象 ** 1.你有一點程式語言的底子,但沒接觸過Dot Net MVC2.寫過Dot Net MVC,但還不是很熟悉它怎麼應用 希望達成目標 1.能夠比較清楚的理解Dot Net MVC怎麼運作2.知道了一些小東西,或許能改善目前你開發上困擾 那就先從工具開始吧 Visual Studio Community : 微軟官網載點 開發Dot Net的工程師,應該9成9的人都是使用Visual Studio,它不僅號稱地表最強編輯器,微軟更佛心的提供了免費版本給大家使用,否則最基礎的一套Visual Studio的價格應該也會讓初學者非常卻步。 當然既然是免費版本,功能上一定會有些陽春,但對於只是入門學習Dot Net而言已經是相當強大的工具了。 [![](https://4.bp.blogspot.com/-AThY6IIeOMU/Wozqfrbkj8I/AAAAAAAAIhM/unPhEYOMwi4GocjIIbH3sQLsG6zFLwLXgCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258A%25E5%258D%258811.41.26.png)](https://4.bp.blogspot.com/-AThY6IIeOMU/Wozqfrbkj8I/AAAAAAAAIhM/unPhEYOMwi4GocjIIbH3sQLsG6zFLwLXgCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258A%25E5%258D%258811.41.26.png)功能比較(來源: [https://www.visualstudio.com/zh-hant/vs/compare/](https://www.visualstudio.com/zh-hant/vs/compare/)) [![](https://2.bp.blogspot.com/-IAZ842DU7bE/WozrAMFvS5I/AAAAAAAAIhU/hXxvWOr48VIim3dJ2gxOVdllEfdLsvspgCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258A%25E5%258D%258811.43.35.png)](https://2.bp.blogspot.com/-IAZ842DU7bE/WozrAMFvS5I/AAAAAAAAIhU/hXxvWOr48VIim3dJ2gxOVdllEfdLsvspgCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258A%25E5%258D%258811.43.35.png)價格表(來源:[https://www.visualstudio.com/zh-hant/vs/pricing/](https://www.visualstudio.com/zh-hant/vs/pricing/)) 下載完之後將它安裝起來 [![](https://4.bp.blogspot.com/-l_GogekWtuo/Wo0NeymgUGI/AAAAAAAAIhk/a9KRtEucnA8ZAofXpTfM1WKc0Cn1-VSeACLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25882.10.47.png)](https://4.bp.blogspot.com/-l_GogekWtuo/Wo0NeymgUGI/AAAAAAAAIhk/a9KRtEucnA8ZAofXpTfM1WKc0Cn1-VSeACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25882.10.47.png)選擇Community安裝[![](https://4.bp.blogspot.com/-VxH0BFcP1N4/Wo0OAeM_n8I/AAAAAAAAIhs/XbpBzTLtFQsEQwdPNDVF0V1-yghRDhHMgCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25882.13.01.png)](https://4.bp.blogspot.com/-VxH0BFcP1N4/Wo0OAeM_n8I/AAAAAAAAIhs/XbpBzTLtFQsEQwdPNDVF0V1-yghRDhHMgCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25882.13.01.png)勾選ASP.NET與網頁程式開發[![](https://1.bp.blogspot.com/-YT3wMLUPuxQ/Wo0OS6i817I/AAAAAAAAIhw/cJGnL6jonT0Kf9XxbKzB9k_5qT6vdB16wCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25882.14.13.png)](https://1.bp.blogspot.com/-YT3wMLUPuxQ/Wo0OS6i817I/AAAAAAAAIhw/cJGnL6jonT0Kf9XxbKzB9k_5qT6vdB16wCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25882.14.13.png)等它安裝完 [![](https://2.bp.blogspot.com/-mb-CXRobkYs/Wo0ZC8U4VJI/AAAAAAAAIiE/hVP-yUd9UtMsSVpt3iVTjyRgksp825iLwCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.00.10.png)](https://2.bp.blogspot.com/-mb-CXRobkYs/Wo0ZC8U4VJI/AAAAAAAAIiE/hVP-yUd9UtMsSVpt3iVTjyRgksp825iLwCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.00.10.png)安裝完之後打開應該會看到這個畫面 因為寫程式大部分時間都需要一直長盯著螢幕,所以螢幕底色如果是淺色系通常到下午我眼睛都會很酸,所以Visual Studio也很貼心了提供修改視窗色系的功能,例如我截圖就是深色系。調整方式如下工具 &gt; 選項 &gt; 色彩佈景主題 ** **** ****建立第一個Web專案** [![](https://3.bp.blogspot.com/-8NkEiv-Pdy0/Wo0atMIeTBI/AAAAAAAAIiY/Xqtt1Nt4vdYMutyRHnF6SK0ywGJw6IBVwCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.07.17.png)](https://3.bp.blogspot.com/-8NkEiv-Pdy0/Wo0atMIeTBI/AAAAAAAAIiY/Xqtt1Nt4vdYMutyRHnF6SK0ywGJw6IBVwCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.07.17.png)檔案 &gt; 新增 &gt; 專案[![](https://3.bp.blogspot.com/-52w4Z2LQrMo/Wo0bFfQ42ZI/AAAAAAAAIic/W7IdEeXSIqIh3rG2CmSN4slAT6Qu1qkzgCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.08.51.png)](https://3.bp.blogspot.com/-52w4Z2LQrMo/Wo0bFfQ42ZI/AAAAAAAAIic/W7IdEeXSIqIh3rG2CmSN4slAT6Qu1qkzgCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.08.51.png)選擇Web &gt; Web應用程式(.NET Framework) 。 專案名稱與放的位置依照自己喜好即可[![](https://3.bp.blogspot.com/-sG9_1osHZzM/Wo0bo1ny1kI/AAAAAAAAIio/mRKCMTpCjp461LAbSFCK6EzS02y1Z02KQCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.11.14.png)](https://3.bp.blogspot.com/-sG9_1osHZzM/Wo0bo1ny1kI/AAAAAAAAIio/mRKCMTpCjp461LAbSFCK6EzS02y1Z02KQCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.11.14.png)選擇MVC 建立完成之後應該可以看到這個畫面 [![](https://3.bp.blogspot.com/-bgNV43jpPbY/Wo0cBzZrZPI/AAAAAAAAIis/U152KITJzwkkk3aMigyzBB7fAyCPS0pIACLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.12.56.png)](https://3.bp.blogspot.com/-bgNV43jpPbY/Wo0cBzZrZPI/AAAAAAAAIis/U152KITJzwkkk3aMigyzBB7fAyCPS0pIACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.12.56.png) 如果看不到方案總管,可以透過檢視&gt; 方案總管來打開 右邊就是我們寫程式要放的地方,之後介紹Dot Net MVC時會慢慢帶到,但今天還不需要寫到程式,先直接將程式執行起來,看看預設建立好的網站是長什麼樣 [![](https://2.bp.blogspot.com/-rsiatvazfV0/Wo0dW96VDgI/AAAAAAAAIi0/62hUceI6RWI5zmuuQrkAE9MP5q0ZXAjaQCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.17.44.png)](https://2.bp.blogspot.com/-rsiatvazfV0/Wo0dW96VDgI/AAAAAAAAIi0/62hUceI6RWI5zmuuQrkAE9MP5q0ZXAjaQCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.17.44.png) 因為這是網站程式, 點選執行旁邊的向下箭頭後,可以依照個人喜好選擇習慣用的瀏覽器來瀏覽,我個人是習慣用Google Chrome,所以以下用Chrome做示範,選好後按下綠色的箭頭執行。 執行起來之後應該可以看到一個很專業的診斷工具面板,分別顯示目前佔了CPU幾%,用了多少記憶體…等等 [![](https://2.bp.blogspot.com/-02yTU2prJZY/Wo0ekE8DgvI/AAAAAAAAIi8/8BiY3LezXhUhV7QMK8XeKO9oy3RG4jKOQCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.22.30.png)](https://2.bp.blogspot.com/-02yTU2prJZY/Wo0ekE8DgvI/AAAAAAAAIi8/8BiY3LezXhUhV7QMK8XeKO9oy3RG4jKOQCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.22.30.png) 而這時候你選擇的瀏覽器應該也會開啟，然後看到目前網站的成果 [![](https://2.bp.blogspot.com/-Xw28Lnnj1vI/Wo0euDl5nmI/AAAAAAAAIjA/hj1eQKYS0jcS8goj3FDv0yngDCHDYPmVACLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.24.20.png)](https://2.bp.blogspot.com/-Xw28Lnnj1vI/Wo0euDl5nmI/AAAAAAAAIjA/hj1eQKYS0jcS8goj3FDv0yngDCHDYPmVACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.24.20.png) 可以隨意的點擊網站按鈕逛逛玩玩後,現在來簡單講一下該如何追蹤偵錯 偵錯是門大學問,常常我們寫的程式編譯時都沒有錯誤,但執行結果卻不如我們預期那般時,一步一步偵錯就會是我們發現問題的好朋友 我們以關於這個按鈕為例,究竟點擊關於這個按鈕時,程式是如何執行,讓我們可以看到畫面的 [![](https://3.bp.blogspot.com/--aluBIC6nMg/Wo0gH9fbBYI/AAAAAAAAIjQ/BaKOSBTJacIOl9_W7YAz8lqi-9Fx5C0FQCLcBGAs/s640/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.29.58.png)](https://3.bp.blogspot.com/--aluBIC6nMg/Wo0gH9fbBYI/AAAAAAAAIjQ/BaKOSBTJacIOl9_W7YAz8lqi-9Fx5C0FQCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.29.58.png) 因為我們還不知道目前整個程式的運作原理,所以依照下面的指示這樣做 找到HomeController,並且打開它 [![](https://4.bp.blogspot.com/-kCJKeJELsx0/Wo0gxIiQthI/AAAAAAAAIjY/FPc1xN8m0oQzv5tfWhG8hf649M2gp4jUACLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.31.50.png)](https://4.bp.blogspot.com/-kCJKeJELsx0/Wo0gxIiQthI/AAAAAAAAIjY/FPc1xN8m0oQzv5tfWhG8hf649M2gp4jUACLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.31.50.png) 找到第18行的地方,點擊那行的最左邊邊框,會產生一個紅色的原點,我們稱之為中斷點 [![](https://2.bp.blogspot.com/-LIvuofL8J2g/Wo0ha-LzXzI/AAAAAAAAIjg/GrPyIZE-hss6nVqf2b6CgYKIhaXTjpfNgCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.34.22.png)](https://2.bp.blogspot.com/-LIvuofL8J2g/Wo0ha-LzXzI/AAAAAAAAIjg/GrPyIZE-hss6nVqf2b6CgYKIhaXTjpfNgCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.34.22.png) 中斷點的意思就是,當程式執行到這行時會停下來讓你知道,並且等待你的指示 接著再回去剛剛的網頁點擊關於,你會發現,視窗會跳到你剛剛下得中斷點位置,而網頁會卡住,並沒有顯示關於的頁面那是因為程式還沒執行完,所以還沒辦法顯示頁面資訊4. 按下F11,每按一次F11,你會看到程式往下走一行,藉此來觀察程式如何運行,並且是否符合我們預期的結果 [![](https://4.bp.blogspot.com/-2hTcGcR7bAg/Wo0mas9EleI/AAAAAAAAIj0/H7T3H2WKSO0yF_lGqHIcrR-CxhuraR1egCLcBGAs/s400/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.56.54.png)](https://4.bp.blogspot.com/-2hTcGcR7bAg/Wo0mas9EleI/AAAAAAAAIj0/H7T3H2WKSO0yF_lGqHIcrR-CxhuraR1egCLcBGAs/s1600/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%2B2018-02-21%2B%25E4%25B8%258B%25E5%258D%25883.56.54.png) 當然,我們不必每次進入中斷點後都一步一步將它執行完,如果已經找到哪邊有問題,只要再按下繼續,程式就會自動往下跑,直到碰到下一個中斷點為止 當然以上所提的,都是非常非常基礎的Visual Studio（之後文章都簡稱為VS）操作,跟日常比較會運用到的情境,VS之所以被人稱為地表最強編輯器,想當然耳不可能只有這樣而已,但這都是要慢慢開發中去體會跟累積的。相信如果真的用久了,開始使用擴充輔助套件之類的,就會知道它的強大之處。 下一篇來提何謂MVC，知道後應就能理解為何會知道關於這個按鈕點擊後,會停在我們今天下的中斷點了。","categories":[{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"}],"tags":[{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"}]},{"title":"【CI/CD】4. 在佈署階段置換參數值，以Web.Config為例","slug":"【CI-CD】4-在佈署階段置換參數值，以Web-Config為例","date":"2018-01-26T09:25:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2018/01/26/【CI-CD】4-在佈署階段置換參數值，以Web-Config為例/","link":"","permalink":"https://toyo0103.github.io/2018/01/26/%E3%80%90CI-CD%E3%80%914-%E5%9C%A8%E4%BD%88%E7%BD%B2%E9%9A%8E%E6%AE%B5%E7%BD%AE%E6%8F%9B%E5%8F%83%E6%95%B8%E5%80%BC%EF%BC%8C%E4%BB%A5Web-Config%E7%82%BA%E4%BE%8B/","excerpt":"","text":"接續前篇 : 【CI/CD】3. 透過VSTS 切換Azure AppService Slot 如果你的佈署狀況如下 [![](https://3.bp.blogspot.com/-uiFFGMOOPlQ/WmraN8BbjEI/AAAAAAAAIdo/xzVVbXd5NLkz4xpa1wI-gTNN048M5R7ngCLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-uiFFGMOOPlQ/WmraN8BbjEI/AAAAAAAAIdo/xzVVbXd5NLkz4xpa1wI-gTNN048M5R7ngCLcBGAs/s1600/1.png)原諒我只繪畫醜圖.... 有一次更版進到到Master Branch，而CI設定Trigger是Master更動時自動建置，CD接收到CI建置完成後執行佈署機器，而每台機器的Web.Config值都有差異，這時候該怎麼做? #XML variable substitutionAzure App Service Deploy有提供XML variable substitutuin可以選擇 [![](https://4.bp.blogspot.com/-LN_4j9iX9As/WmrfdZWF3oI/AAAAAAAAId4/Tc9U1W24Lq45Ms0p9qhtBLNX2EJ8sKJ_QCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-LN_4j9iX9As/WmrfdZWF3oI/AAAAAAAAId4/Tc9U1W24Lq45Ms0p9qhtBLNX2EJ8sKJ_QCLcBGAs/s1600/1.png) 依據註解中說明就是，當這個選項勾選時，他會自動去找專案中的所有.Config檔案，檔案中的appSettings，application Settings , connectionString區塊，如果有Key或Name與設定的變數相同時自動置換，且是發生在Config transforms之後 什麼意思呢? 直接看範例，如果我們的Web.Config裡面長這樣 [![](https://1.bp.blogspot.com/-iEfgD967KZc/WmriR-qREbI/AAAAAAAAIeE/P_zG3I8Ah3EPMA4uADVKwh8LqCImdKpjACLcBGAs/s400/1.png)](https://1.bp.blogspot.com/-iEfgD967KZc/WmriR-qREbI/AAAAAAAAIeE/P_zG3I8Ah3EPMA4uADVKwh8LqCImdKpjACLcBGAs/s1600/1.png) 那他就會在去比對appSettings、connectionString區塊，裡面的Name或是Key有對應到變數設定的話，Value值會自動被替換，而變數設定又在哪邊呢? [![](https://2.bp.blogspot.com/-bJ9GV3qzx1A/WmrjTH_HnSI/AAAAAAAAIeM/XMf0yAL-XBsfedMAXLy7jbkiS5RcfRViwCLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-bJ9GV3qzx1A/WmrjTH_HnSI/AAAAAAAAIeM/XMf0yAL-XBsfedMAXLy7jbkiS5RcfRViwCLcBGAs/s1600/1.png) 以上面兩張圖來說，那他在WebDeploy到Azure App Service之前就會將我的StaticDomains、Domain的Value換掉，因為我們在變數檔案裡面有設定。 這樣我們就能透過建置多個環境的方式，在每個環境中設定好對應的變數值，只要執行一次CI流程，觸發多個CD流程，達到多台同時佈署的目的 [![](https://2.bp.blogspot.com/-Vn7jrg9S6zM/WmrkbLQL9JI/AAAAAAAAIeY/DSoCnAGpUUA_-3oKJhbPD6sj9bdNQ0DPQCLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-Vn7jrg9S6zM/WmrkbLQL9JI/AAAAAAAAIeY/DSoCnAGpUUA_-3oKJhbPD6sj9bdNQ0DPQCLcBGAs/s1600/1.png) #參數不在appSettings，application Settings , connectionString區塊之中這邊特別注意，剛剛那種置換的值方法僅適用於上述區塊之中，換句話說，如果我們有環境設定變數，但他又不在這幾個區塊之中，該如何做? Parameter.xml還好微軟有提供另一種方式能處理這個問題，就是透過Parameters.xml 建立parameters.xml[![](https://4.bp.blogspot.com/-DIAJpQ2tUYk/WmrlsIo55sI/AAAAAAAAIeg/PCaPpM04JucMUYC8QFByvv4X3pPcRwjJgCLcBGAs/s320/1.png)](https://4.bp.blogspot.com/-DIAJpQ2tUYk/WmrlsIo55sI/AAAAAAAAIeg/PCaPpM04JucMUYC8QFByvv4X3pPcRwjJgCLcBGAs/s1600/1.png) 123456789101112131415&lt;parameters&gt; &lt;parameter name=&quot;ExceptionlessAPIKey&quot; defaultValue=&quot;#&#123;ExceptionlessAPIKey&#125;#&quot; &gt; &lt;parameterEntry kind=&quot;XmlFile&quot; scope=&quot;Web\\.config&quot; match=&quot;//exceptionless/@apiKey&quot; /&gt; &lt;/parameter&gt; &lt;parameter name=&quot;SessionConnectionString&quot; defaultValue=&quot;#&#123;SessionConnectionString&#125;#&quot; &gt; &lt;parameterEntry kind=&quot;XmlFile&quot; scope=&quot;Web\\.config&quot; match=&quot;//configuration/system.web/sessionState/@sqlConnectionString&quot; /&gt; &lt;/parameter&gt;&lt;/parameters&gt; Name : 變數名稱Scope : 受影響的檔案為和，你可以設定整個專案底下全部的.Config也行Match : 在這些檔案底下如何尋找要被替換的值 Example 1 : Web.Config底下從根結點開始找起，找到一個叫做exceptionLess的Tag，然後把apiKey這個屬性換成我設定的值Example 2 : Web.Config底下從根結點開始找起，找到configuration底下的system.web底下的sessionState Tag，然後把sqlConnectionString這個屬性換成我設定的值 DefaultValue : 如果在佈署時沒有設定參數值時，預設給的Value 接著在VisualStudio按發行後應該會看到檔案長出SetParameters.xml [![](https://3.bp.blogspot.com/-s_s3aU7dr74/WmrsRb8ETdI/AAAAAAAAIew/WYlqsjbIk0oj7ow-GOqheH4FJY6QZAUHgCLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-s_s3aU7dr74/WmrsRb8ETdI/AAAAAAAAIew/WYlqsjbIk0oj7ow-GOqheH4FJY6QZAUHgCLcBGAs/s1600/1.png) 打開來會看到 [![](https://1.bp.blogspot.com/-viIUyylwlDg/Wmr6qYwZv-I/AAAAAAAAIgE/C0ISadjZIigW7FQ6sMezcjZwYudaEaLrwCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-viIUyylwlDg/Wmr6qYwZv-I/AAAAAAAAIgE/C0ISadjZIigW7FQ6sMezcjZwYudaEaLrwCLcBGAs/s1600/1.png) 到這邊我們已經成功將Web.Config的指定位置挖成變數值，等等在CD階段，我們就是要想辦法把SetParameters.xml的Value值換掉 回到CD設定介面告訴Azure App Service Deploy Task，你有SetParameters.xml [![](https://4.bp.blogspot.com/-NUpiKPxhPRY/Wmrtx-vh_HI/AAAAAAAAIfE/RRml5NRckGQ6S4uDWJJsfSHhX2H7CWEBgCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-NUpiKPxhPRY/Wmrtx-vh_HI/AAAAAAAAIfE/RRml5NRckGQ6S4uDWJJsfSHhX2H7CWEBgCLcBGAs/s1600/1.png) 安裝Replace Token Task為了置換掉SetParameters.xml裡面的值，必須幫我們VSTS安裝套件[![](https://1.bp.blogspot.com/-Kq1PpE97VYE/WmruR4NMthI/AAAAAAAAIfM/Vu2lwFOUsx4Npju7imY-kYBuW3Frt1exACLcBGAs/s400/1.png)](https://1.bp.blogspot.com/-Kq1PpE97VYE/WmruR4NMthI/AAAAAAAAIfM/Vu2lwFOUsx4Npju7imY-kYBuW3Frt1exACLcBGAs/s1600/1.png) 安裝連結 :&nbsp; [Replace Token MarketPlace&nbsp;](https://marketplace.visualstudio.com/items?itemName=qetza.replacetokens) 在Azure App Service Deploy之前加上Replace Token Task [![](https://2.bp.blogspot.com/-jDdk2Q7Mj7I/Wmru-f9N1fI/AAAAAAAAIfU/y2x-uJAWD8wQSwaij7_B6TyOS7T2RmMzQCLcBGAs/s640/1.png)](https://2.bp.blogspot.com/-jDdk2Q7Mj7I/Wmru-f9N1fI/AAAAAAAAIfU/y2x-uJAWD8wQSwaij7_B6TyOS7T2RmMzQCLcBGAs/s1600/1.png) [![](https://3.bp.blogspot.com/-mTQYjeZIYho/WmrvSLWq_lI/AAAAAAAAIfY/hWpXjtyZkzMf40oTRqx4cfaWoSxvNQ5XgCLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-mTQYjeZIYho/WmrvSLWq_lI/AAAAAAAAIfY/hWpXjtyZkzMf40oTRqx4cfaWoSxvNQ5XgCLcBGAs/s1600/1.png) 設定[![](https://4.bp.blogspot.com/-j-77BDvLK7A/WmrxsFTAD8I/AAAAAAAAIfo/4PIBYR3ck7Uc0DSDfUcTbjs4bAA2CzM-ACLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-j-77BDvLK7A/WmrxsFTAD8I/AAAAAAAAIfo/4PIBYR3ck7Uc0DSDfUcTbjs4bAA2CzM-ACLcBGAs/s1600/1.png) **Root Directory : **要替換的目標檔案Root資料夾位置 **Target files : **告訴它我們要找的檔案是誰，以這邊來說就是SetParameters.xml **Token prefix、Token suffix : **比對什麼是它要幫我們置換的，而這邊就是#{xxxx}#包起來的就是參數 這樣設定完之後，它就會在WebDeploy之前執行Replace Token Task，而這個Task會去找到SetParameters.xml，然後找到#{xxx}#符號的，然後用我們之前設定在Variables的參數置換掉 [![](https://2.bp.blogspot.com/-rvxpn3Nkvrw/WmrzQb7-SUI/AAAAAAAAIf0/fMBjj3gSnYwGvbR50p7UZcQQwvGUf5MNgCLcBGAs/s640/1.png)](https://2.bp.blogspot.com/-rvxpn3Nkvrw/WmrzQb7-SUI/AAAAAAAAIf0/fMBjj3gSnYwGvbR50p7UZcQQwvGUf5MNgCLcBGAs/s1600/1.png) **參考文章 **Using environment variables for configuration with VSTS build and releaseParameterizing Web.configWeb Deploy XML File ParameterizationUse VSTS to Build and Publish to an Azure Web App with Continuous DeploymentUsing Web Deploy in Visual Studio Team Services Release ManagementFile transforms and variable substitution reference","categories":[{"name":"VSTS建置CI-CD","slug":"VSTS建置CI-CD","permalink":"https://toyo0103.github.io/categories/VSTS%E5%BB%BA%E7%BD%AECI-CD/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://toyo0103.github.io/tags/CI-CD/"},{"name":"Azure","slug":"Azure","permalink":"https://toyo0103.github.io/tags/Azure/"},{"name":"VSTS","slug":"VSTS","permalink":"https://toyo0103.github.io/tags/VSTS/"}]},{"title":"【CI/CD】3. 透過VSTS 切換Azure AppService Slot","slug":"【CI-CD】3-透過VSTS-切換Azure-AppService-Slot","date":"2018-01-26T05:51:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2018/01/26/【CI-CD】3-透過VSTS-切換Azure-AppService-Slot/","link":"","permalink":"https://toyo0103.github.io/2018/01/26/%E3%80%90CI-CD%E3%80%913-%E9%80%8F%E9%81%8EVSTS-%E5%88%87%E6%8F%9BAzure-AppService-Slot/","excerpt":"","text":"接續前篇 : 【CI/CD】2. 透過VSTS自動佈署程式到Azure AppService 一般為了服務的順暢，一般都會在正式機的Azure App Service開啟Slot服務 參考 : 在 Azure App Service 中設定預備環境 好讓服務更新時，能無痛更新且不會中斷Session。 而上一篇有提到如何更新Azure App Service，但如果在有開啟Slot的情形下，設定要做一些變更。 首先先將設定從佈署正式機改成佈署到Slot[![](https://3.bp.blogspot.com/-8u_M2pW8r6I/Wmq7HICh6mI/AAAAAAAAIcE/XVVdqTZH-houw6m7iXuRw1R1B-QYMuPHgCLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-8u_M2pW8r6I/Wmq7HICh6mI/AAAAAAAAIcE/XVVdqTZH-houw6m7iXuRw1R1B-QYMuPHgCLcBGAs/s1600/1.png) 勾選Deploy to Slot後，會需要選擇**Resource group**與**Slot**，分別選擇好後存檔。 新增一組切換Slot 的Enviroment[![](https://4.bp.blogspot.com/-sDn38p_Mnbw/Wmq8ETA_jDI/AAAAAAAAIcM/H_eI0hPhGIwW-a6rxAwMdWy7O7s5vlCAACLcBGAs/s1600/1.png)](https://4.bp.blogspot.com/-sDn38p_Mnbw/Wmq8ETA_jDI/AAAAAAAAIcM/H_eI0hPhGIwW-a6rxAwMdWy7O7s5vlCAACLcBGAs/s1600/1.png) 因為我們是希望佈署到Slot後，再決定要不要跟正式機進行交換，所以是按第一組環境的Add而不是Enviroments Add，兩個差異如下 **Enviroments Add : **同時觸發[![](https://3.bp.blogspot.com/-MeAkdLz3Cr0/Wmq8tNg9y9I/AAAAAAAAIcY/OscSApLOq4U9Fg19E1Ck7ai5RQO6Yi5agCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-MeAkdLz3Cr0/Wmq8tNg9y9I/AAAAAAAAIcY/OscSApLOq4U9Fg19E1Ck7ai5RQO6Yi5agCLcBGAs/s1600/1.png)** ****DeployToStage Add : **依序[![](https://3.bp.blogspot.com/-rgl9IIrg7PM/Wmq9FwxUOPI/AAAAAAAAIcc/X4QXZY09ZqwBjKuO14TeLbQdhBY5ZkfCQCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-rgl9IIrg7PM/Wmq9FwxUOPI/AAAAAAAAIcc/X4QXZY09ZqwBjKuO14TeLbQdhBY5ZkfCQCLcBGAs/s1600/1.png) 設定Swap Slot 新增Azure App Service Manage[![](https://4.bp.blogspot.com/-cu8E1X0iFtc/Wmq9gXARCNI/AAAAAAAAIck/BhcwVvceOyUPJ_1rBx_57fn5zLIbbynDQCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-cu8E1X0iFtc/Wmq9gXARCNI/AAAAAAAAIck/BhcwVvceOyUPJ_1rBx_57fn5zLIbbynDQCLcBGAs/s1600/1.png) [![](https://2.bp.blogspot.com/-rERunRQExFg/Wmq-YRBwp7I/AAAAAAAAIc0/MxgvqqNAZrIPKSGwPgHfBIEB3DHe7-qswCLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-rERunRQExFg/Wmq-YRBwp7I/AAAAAAAAIc0/MxgvqqNAZrIPKSGwPgHfBIEB3DHe7-qswCLcBGAs/s1600/1.png) 跟前面的設定基本上都一樣，只要是Action的地方要選擇**Swap Slots**** **** ** 加上啟動切換Slot的條件正式機加上上述設定後帶來了一些好處 1.上線時推程式會先進到Slot，先連到Slot測試確定沒問題2.讓正式機跟Slot交換，線上服務感受不到中斷，但程式已經更新了 而我們為了安全起見，在切換Slot前會再加一到人工審核，當核准時才會進行切換 [![](https://3.bp.blogspot.com/-NPW1J_euv1g/Wmq_d5ZIgbI/AAAAAAAAIc8/fel0tpckNpY3G9U-Ce-l_7cux4hh69UrgCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-NPW1J_euv1g/Wmq_d5ZIgbI/AAAAAAAAIc8/fel0tpckNpY3G9U-Ce-l_7cux4hh69UrgCLcBGAs/s1600/1.png)[![](https://2.bp.blogspot.com/-MUxdoYfNdvI/WmrAesUzntI/AAAAAAAAIdI/rprzi_YpU2I3gU8Nf6WvND6lnqbP5f-TwCLcBGAs/s640/1.png)](https://2.bp.blogspot.com/-MUxdoYfNdvI/WmrAesUzntI/AAAAAAAAIdI/rprzi_YpU2I3gU8Nf6WvND6lnqbP5f-TwCLcBGAs/s1600/1.png) 這樣設定後，切換Slot就會需要審核 第一關審核是佈署到Slot[![](https://2.bp.blogspot.com/-xPtLxwhLiEM/WmrA85Q54II/AAAAAAAAIdM/w5moJRIMBecavQfl60mVPKB6fhLedXgRgCLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-xPtLxwhLiEM/WmrA85Q54II/AAAAAAAAIdM/w5moJRIMBecavQfl60mVPKB6fhLedXgRgCLcBGAs/s1600/1.png) 第二關審核是將正式機跟Slot切換[![](https://1.bp.blogspot.com/-rZTHXtthOOk/WmrBvam9k3I/AAAAAAAAIdY/yuP69VL0ZlkFPnQ5CWUd8nTImmr4mWBdACLcBGAs/s400/1.png)](https://1.bp.blogspot.com/-rZTHXtthOOk/WmrBvam9k3I/AAAAAAAAIdY/yuP69VL0ZlkFPnQ5CWUd8nTImmr4mWBdACLcBGAs/s1600/1.png) 下一篇來寫如何在CD階段置換參數值","categories":[{"name":"VSTS建置CI-CD","slug":"VSTS建置CI-CD","permalink":"https://toyo0103.github.io/categories/VSTS%E5%BB%BA%E7%BD%AECI-CD/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://toyo0103.github.io/tags/CI-CD/"},{"name":"Azure","slug":"Azure","permalink":"https://toyo0103.github.io/tags/Azure/"},{"name":"VSTS","slug":"VSTS","permalink":"https://toyo0103.github.io/tags/VSTS/"}]},{"title":"【CI/CD】2. 透過VSTS自動佈署程式到Azure AppService","slug":"【CI-CD】2-透過VSTS自動佈署程式到Azure-AppService","date":"2018-01-26T03:12:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2018/01/26/【CI-CD】2-透過VSTS自動佈署程式到Azure-AppService/","link":"","permalink":"https://toyo0103.github.io/2018/01/26/%E3%80%90CI-CD%E3%80%912-%E9%80%8F%E9%81%8EVSTS%E8%87%AA%E5%8B%95%E4%BD%88%E7%BD%B2%E7%A8%8B%E5%BC%8F%E5%88%B0Azure-AppService/","excerpt":"","text":"接續前篇 : 【CI/CD】1. 如何透過VSTS來達成CI的目標 這邊的目標是當CI完成時，自動將程式佈署到Azure AppService，也就是所謂的CD部分 持續部署(Continuous Deployment)大部分的持續整合系統允許在建置完成後自動執行程式碼。因此能夠寫一段程式碼來布署應用程式至任何人都可以觀察的測試伺服器。在持續性整合未來的思考發展成像持續性布署邁進。持續性布署將要求直接將軟體布署至測試環境中，這通常需要額外的自動化機制來防止程式缺陷。 希望1.CI部分執行完畢後，將程式自動佈署到機器2.依據不同的CI Task，決定佈署到哪些機器 (測試機 or 多台正式機…等)3.**人員核准 **(正式機通常需要一定權限核准才能執行佈署) 1.先進到VSTS的Release &gt; Create release Definitions[![](https://4.bp.blogspot.com/-j4SKGxGUXWc/WmqJEJctL1I/AAAAAAAAIZY/-CHGLoBOXJY8d9VtIaz-35vVkgPS9FuCgCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-j4SKGxGUXWc/WmqJEJctL1I/AAAAAAAAIZY/-CHGLoBOXJY8d9VtIaz-35vVkgPS9FuCgCLcBGAs/s1600/1.png) 2.選擇Empty Process[![](https://3.bp.blogspot.com/-yx2eYYmHSqg/WmqJXg1LlmI/AAAAAAAAIZc/8SxeXNTgDkEk7xDragehBih3J8u9hOfkwCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-yx2eYYmHSqg/WmqJXg1LlmI/AAAAAAAAIZc/8SxeXNTgDkEk7xDragehBih3J8u9hOfkwCLcBGAs/s1600/1.png) 3.在Artifacts選擇佈署要用哪一組CI建置的成品[![](https://4.bp.blogspot.com/-lpW6Y2RApv4/WmqJ2ScPvCI/AAAAAAAAIZo/Hdz-H64BtY0GiD8xdEHt7ZezAOQQUKDCgCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-lpW6Y2RApv4/WmqJ2ScPvCI/AAAAAAAAIZo/Hdz-H64BtY0GiD8xdEHt7ZezAOQQUKDCgCLcBGAs/s1600/1.png)[![](https://4.bp.blogspot.com/-1yfWjZ26ZWk/WmqKTGiIrFI/AAAAAAAAIZw/Oq49HUpyphwVZ7FcV-xFVEpUfNB2UpT9gCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-1yfWjZ26ZWk/WmqKTGiIrFI/AAAAAAAAIZw/Oq49HUpyphwVZ7FcV-xFVEpUfNB2UpT9gCLcBGAs/s1600/1.png) 4.設定Trigger條件我們希望上一步驟選擇的CI Task建置完成後，自動觸發這個的CD流程，所以要加上Trigger條件 [![](https://3.bp.blogspot.com/-LFkrO0ACJ5w/WmqMbAIfg5I/AAAAAAAAIaM/jGU4bXy_CZo17kKHN4h_1IdZAeNkN37KgCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-LFkrO0ACJ5w/WmqMbAIfg5I/AAAAAAAAIaM/jGU4bXy_CZo17kKHN4h_1IdZAeNkN37KgCLcBGAs/s1600/1.png)[![](https://4.bp.blogspot.com/-xUgj-OM9P4Y/WmqMr611LmI/AAAAAAAAIaQ/nfdvmcsj_88OOwqq6OK32BNanBRvghZ6gCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-xUgj-OM9P4Y/WmqMr611LmI/AAAAAAAAIaQ/nfdvmcsj_88OOwqq6OK32BNanBRvghZ6gCLcBGAs/s1600/1.png) 5.新增Enviroment Task &gt; Azure App Service Deploy[![](https://2.bp.blogspot.com/-iBKwQJIYa6Q/WmqM79F_lYI/AAAAAAAAIaY/gsTQ7EtWRywGnpyXXO42WAjG--EmzdfNACLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-iBKwQJIYa6Q/WmqM79F_lYI/AAAAAAAAIaY/gsTQ7EtWRywGnpyXXO42WAjG--EmzdfNACLcBGAs/s1600/1.png)[![](https://1.bp.blogspot.com/-DwVyGiM89Us/WmqNTD0Dv3I/AAAAAAAAIag/QcKJhKXT1RQPC1rYn-E50OCxSaDBwFYegCLcBGAs/s400/1.png)](https://1.bp.blogspot.com/-DwVyGiM89Us/WmqNTD0Dv3I/AAAAAAAAIag/QcKJhKXT1RQPC1rYn-E50OCxSaDBwFYegCLcBGAs/s1600/1.png) 6.設定相關參數[![](https://3.bp.blogspot.com/-SdtrEkvtTsU/WmqW3HlYaJI/AAAAAAAAIa0/LewJi_YI2qsNJH7MMi5KQNJiVdOwSvF-gCLcBGAs/s1600/1.png)](https://3.bp.blogspot.com/-SdtrEkvtTsU/WmqW3HlYaJI/AAAAAAAAIa0/LewJi_YI2qsNJH7MMi5KQNJiVdOwSvF-gCLcBGAs/s1600/1.png)**Azure subscription **: 選擇你訂閱的Azure服務，基本如果是同一個帳號，下拉選單就可以看到 Package or folder&nbsp;: 因為我們是採用WebDeploy的方式佈署，所以要輸入Pakage的路徑，紅色區塊請填你CI Task所設定的名稱，CI建置會放置在同名的資料夾底下，之後就是Drop底下建置出來的.zip檔 人員核准依照上述步驟做完，基本上佈署流程大致上已經完成，但通常會有一些狀況是希望做佈署動作前能夠先透過人來審核，例如正式機佈署。 我們一定不希望隨便人簽入程式後，正式機的CD流程就自動觸發佈署去了。 設定審核人員[![](https://3.bp.blogspot.com/-9Fe6kin7wkU/WmqYnG25onI/AAAAAAAAIbA/54Z9iUfEdmM2_U9JBtD2SoevurGaoIsbACLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-9Fe6kin7wkU/WmqYnG25onI/AAAAAAAAIbA/54Z9iUfEdmM2_U9JBtD2SoevurGaoIsbACLcBGAs/s1600/1.png)[![](https://2.bp.blogspot.com/-ztGHArbq6VQ/WmqZCBvHSJI/AAAAAAAAIbE/sHDYhhNkmMI8LIkdzRjrGt__lGLvjb-ggCLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-ztGHArbq6VQ/WmqZCBvHSJI/AAAAAAAAIbE/sHDYhhNkmMI8LIkdzRjrGt__lGLvjb-ggCLcBGAs/s1600/1.png)**Any Order : **上面所選的人員每一個都要核准才會觸發 **In sequence :&nbsp;**上面所選的人員每一個都要**依序**核准才會觸發 **Any One Order&nbsp;****&nbsp;:&nbsp;**上面所選的人員**任何一人核准即可** 如果有卡核准的話，Release不會自動執行，而是看到這個畫面[![](https://2.bp.blogspot.com/-tp3q8i0NZaM/WmqbBeT2hOI/AAAAAAAAIbc/B20xUeyN9YwlKHd7EYOqskqYywkF6SbCACLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-tp3q8i0NZaM/WmqbBeT2hOI/AAAAAAAAIbc/B20xUeyN9YwlKHd7EYOqskqYywkF6SbCACLcBGAs/s1600/1.png)點兩下進去後可以核准[![](https://3.bp.blogspot.com/-KP6jYJbXaB4/WmqbqoYwdjI/AAAAAAAAIbo/ASJM3yKXy_8twOKj380r6aoKhzZI3em_QCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-KP6jYJbXaB4/WmqbqoYwdjI/AAAAAAAAIbo/ASJM3yKXy_8twOKj380r6aoKhzZI3em_QCLcBGAs/s1600/1.png) 選擇特定版本佈署[![](https://3.bp.blogspot.com/-Yj3LrhbV4OI/WmqcDGeKk8I/AAAAAAAAIbs/5zJArJ9S2JoeganmsxpN0oOLlnHb9mlpgCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-Yj3LrhbV4OI/WmqcDGeKk8I/AAAAAAAAIbs/5zJArJ9S2JoeganmsxpN0oOLlnHb9mlpgCLcBGAs/s1600/1.png) [![](https://2.bp.blogspot.com/-SCDaX0YHudE/WmqcPmnMTZI/AAAAAAAAIb0/squNlawHwwgeW54wH2D4ku-wSVQLFrhdgCLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-SCDaX0YHudE/WmqcPmnMTZI/AAAAAAAAIb0/squNlawHwwgeW54wH2D4ku-wSVQLFrhdgCLcBGAs/s1600/1.png) 小結以上這邊，之後只要有人簽入程式，CI流程有設定Trigger的話就會自動觸發，CI流程沒問題，CD流程就會接著做，再依據有無卡審核做後續行為。 每次的執行狀況也都可以清楚看到狀況[![](https://1.bp.blogspot.com/-2UvlMPIFHiA/WmqaGN8VLpI/AAAAAAAAIbQ/C1GftxgAeBIqRCPMuJCNQU39Bu32ILIvQCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-2UvlMPIFHiA/WmqaGN8VLpI/AAAAAAAAIbQ/C1GftxgAeBIqRCPMuJCNQU39Bu32ILIvQCLcBGAs/s1600/1.png) [![](https://2.bp.blogspot.com/-QXjIEo2-s1M/WmqaX4umkhI/AAAAAAAAIbU/Sg2soTofoawjOVzoZtEC98DLqtFGATFnQCLcBGAs/s640/1.png)](https://2.bp.blogspot.com/-QXjIEo2-s1M/WmqaX4umkhI/AAAAAAAAIbU/Sg2soTofoawjOVzoZtEC98DLqtFGATFnQCLcBGAs/s1600/1.png) 下一篇來說如何透過VSTS來執行切換Slot，感覺還有好幾篇可以寫...","categories":[{"name":"VSTS建置CI-CD","slug":"VSTS建置CI-CD","permalink":"https://toyo0103.github.io/categories/VSTS%E5%BB%BA%E7%BD%AECI-CD/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://toyo0103.github.io/tags/CI-CD/"},{"name":"Azure","slug":"Azure","permalink":"https://toyo0103.github.io/tags/Azure/"},{"name":"VSTS","slug":"VSTS","permalink":"https://toyo0103.github.io/tags/VSTS/"}]},{"title":"【CI/CD】1. 如何透過VSTS來達成CI的目標","slug":"【CI-CD】1-如何透過VSTS來達成CI的目標","date":"2018-01-25T09:28:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2018/01/25/【CI-CD】1-如何透過VSTS來達成CI的目標/","link":"","permalink":"https://toyo0103.github.io/2018/01/25/%E3%80%90CI-CD%E3%80%911-%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8EVSTS%E4%BE%86%E9%81%94%E6%88%90CI%E7%9A%84%E7%9B%AE%E6%A8%99/","excerpt":"","text":"以下是Wiki對於CI的解釋 持續整合（英語：Continuous integration，縮寫CI）是一種軟體工程流程，是將所有軟體工程師對於軟體的工作副本持續整合到共用主線（mainline）的一種舉措。該名稱最早由[1]葛來迪·布區（Grady Booch）在他的布區方法[2]中提出，不過他並沒有提到要每天整合數次。之後該舉措成為極限編程（extreme programming）的一部份時，其中建議每天應整合超過一次，甚至達到數十次。[3]在測試驅動開發（TDD）的作法中，通常還會搭配自動單元測試。持續整合的提出主要是為解決軟體進行系統整合時面臨的各項問題，極限編程稱這些問題為整合地獄（integration hell）。 而自己對CI的見解是，透過軟體版本控管機制，持續將每個分支每次修改進行整合，並且透過自動化的測試、佈署、執行報告來控管軟體品質。 參考 : [軟體工程]持續整合 (Continuous integration, CI) 簡介 - 91 而這篇是要寫如何透過VSTS來達成此目標，跟整個設定的過程，先來整理要達成的目標項目。 希望1.版控更新時，自動建置2.自動執行單元測試3.將建置好的檔案放到佈署資料夾(之後讓CD接手，做自動化佈署到正式機、測試機..等)4.回報上述執行結果 版控更新時，自動建置 1.到VSTS網站頁面，選擇Build and Release&nbsp; &gt;&nbsp; +New [![](https://3.bp.blogspot.com/-XS-Ogl-wsag/WmmPVNrH_bI/AAAAAAAAIV8/cjl3VdVp6gsL11fiftfSCIcec9EsE_gGgCLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-XS-Ogl-wsag/WmmPVNrH_bI/AAAAAAAAIV8/cjl3VdVp6gsL11fiftfSCIcec9EsE_gGgCLcBGAs/s1600/1.png)** ** 2.選擇Empty process [![](https://4.bp.blogspot.com/-qw_0GPoI3i4/WmmPmH3ClGI/AAAAAAAAIWA/pMV4k7v1uZQlucvGW5U0dy_Mu2MjwCVdQCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-qw_0GPoI3i4/WmmPmH3ClGI/AAAAAAAAIWA/pMV4k7v1uZQlucvGW5U0dy_Mu2MjwCVdQCLcBGAs/s1600/1.png) Process Agent queue設定 [![](https://4.bp.blogspot.com/-nv9FB-OKBu8/WmmiC6TnyPI/AAAAAAAAIYs/unfIYRSe9wgUs1490wBHMKwp9_bOsAC_QCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-nv9FB-OKBu8/WmmiC6TnyPI/AAAAAAAAIYs/unfIYRSe9wgUs1490wBHMKwp9_bOsAC_QCLcBGAs/s1600/1.png) 3.加入Nuget restore Task，因為我們專案都有用Nuget，所以需要在建置之前先還原Nuget，設定如下[![](https://1.bp.blogspot.com/-hFBqYKbzhfI/WmmUkjd318I/AAAAAAAAIWc/VnQOMKDfOWUFlsdbTwtgOzDsuEo1HyDWwCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-hFBqYKbzhfI/WmmUkjd318I/AAAAAAAAIWc/VnQOMKDfOWUFlsdbTwtgOzDsuEo1HyDWwCLcBGAs/s1600/1.png) [![](https://1.bp.blogspot.com/-8bU6NhV_axk/WmmSF6nLdzI/AAAAAAAAIWQ/xR8dyhcgSP8e9s4c5pukjKhgmiqKKmyYwCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-8bU6NhV_axk/WmmSF6nLdzI/AAAAAAAAIWQ/xR8dyhcgSP8e9s4c5pukjKhgmiqKKmyYwCLcBGAs/s1600/1.png) 這邊Feed to use 我選擇Feeds in my Nuget.config，原因是公司專案有用自己開發的Nuget套件，而那些Nuget放的位置就需要自訂的Config讓建置機器知道，否則抓不到那些套件，待會建置就會錯誤，如果專案沒有用內部Nuget Server的套件，就選第一個即可。 通常如果我們有用私人的Nuget套件，一定會在VS設定套件來源，而這個設定檔就會放在底下這個位置%appdata%\\NuGet\\NuGet.Config把檔案放進版控中，就可以讓VSTS選的到了 4.加入Build Solution Task[![](https://4.bp.blogspot.com/-P83wkuHiW_Q/WmmU9NttxhI/AAAAAAAAIWg/eKcneONO0H0amRUTTrN0KmMSpKnIHFaCgCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-P83wkuHiW_Q/WmmU9NttxhI/AAAAAAAAIWg/eKcneONO0H0amRUTTrN0KmMSpKnIHFaCgCLcBGAs/s1600/1.png)[![](https://1.bp.blogspot.com/-VpXPU2_Rkb8/WmmVvzSQSBI/AAAAAAAAIWs/Mpu-mZu4gqEzXQBfEqurgLBwRxTc2fp_ACLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-VpXPU2_Rkb8/WmmVvzSQSBI/AAAAAAAAIWs/Mpu-mZu4gqEzXQBfEqurgLBwRxTc2fp_ACLcBGAs/s1600/1.png)** ***這邊MSBuild Arguments裡面的PublishProfile=CICD，意思是說我們要用的發行檔名稱，而名稱就做CICD，所以等等我們會回VisualStudio建立一個名叫CICD的發行檔 *Configuration，是說我要用Debug的組態檔來建置，如果你不知道組態檔是什麼，請看 參考 : 發佈網站時依據組態設定的不同而轉換 Web.Config - MRKT 5.建立CICD發行檔[![](https://4.bp.blogspot.com/-fXHi2n6VZFM/WmmYCGCjFAI/AAAAAAAAIW4/5zbkFrA19Fon58CJBVLTEUJR3Chqz50iQCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-fXHi2n6VZFM/WmmYCGCjFAI/AAAAAAAAIW4/5zbkFrA19Fon58CJBVLTEUJR3Chqz50iQCLcBGAs/s1600/1.png) [![](https://1.bp.blogspot.com/-l1gb4UnmpmM/WmmYYZTNDxI/AAAAAAAAIW8/0HjBNGwjRNMIErNyx8lrVf4Hy7TZ88x9ACLcBGAs/s400/1.png)](https://1.bp.blogspot.com/-l1gb4UnmpmM/WmmYYZTNDxI/AAAAAAAAIW8/0HjBNGwjRNMIErNyx8lrVf4Hy7TZ88x9ACLcBGAs/s1600/1.png) [![](https://1.bp.blogspot.com/-32aEvFZCe6g/WmmZW11jZ0I/AAAAAAAAIXI/2Ei-9zh3KhQx06veBMtbWEa7H4tc3idvgCLcBGAs/s400/1.png)](https://1.bp.blogspot.com/-32aEvFZCe6g/WmmZW11jZ0I/AAAAAAAAIXI/2Ei-9zh3KhQx06veBMtbWEa7H4tc3idvgCLcBGAs/s1600/1.png) [![](https://2.bp.blogspot.com/-1RqfQqrD0C8/WmmZoZZViaI/AAAAAAAAIXM/34faHBlj3c4KF4xz7FwZnZmWayUpSodlwCLcBGAs/s320/1.png)](https://2.bp.blogspot.com/-1RqfQqrD0C8/WmmZoZZViaI/AAAAAAAAIXM/34faHBlj3c4KF4xz7FwZnZmWayUpSodlwCLcBGAs/s1600/1.png) 你可以先用VS發行看看，應該會在專案的Root資料夾底下長出一個Publish的資料夾，底下內容如下 [![](https://1.bp.blogspot.com/-PzHy8-PeILA/WmmaFi-990I/AAAAAAAAIXU/lms69Y9-8BcER7sAvGlMt2x38tEUFQcagCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-PzHy8-PeILA/WmmaFi-990I/AAAAAAAAIXU/lms69Y9-8BcER7sAvGlMt2x38tEUFQcagCLcBGAs/s1600/1.png)之後WebDeply就靠這些檔案了。 回到VSTS繼續設定 6.加入Visual Studio Test Task[![](https://4.bp.blogspot.com/-QBXq7Esdoro/WmmarbzFXlI/AAAAAAAAIXc/yTYh8E4y8Uwq1NX4NTjHjxUJFoxvAJKvACLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-QBXq7Esdoro/WmmarbzFXlI/AAAAAAAAIXc/yTYh8E4y8Uwq1NX4NTjHjxUJFoxvAJKvACLcBGAs/s1600/1.png)[![](https://4.bp.blogspot.com/-Ik2JJshPoNw/WmmbErAetqI/AAAAAAAAIXg/iBT1z4W5SfUMPIwsR6Cgk8O5FC2Ox-KjwCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-Ik2JJshPoNw/WmmbErAetqI/AAAAAAAAIXg/iBT1z4W5SfUMPIwsR6Cgk8O5FC2Ox-KjwCLcBGAs/s1600/1.png) 紅框處是告訴這個Task，如何找到你的單元測試Dll來執行，如果你建立單元測試專案都是用預設的方式，那單元測試的專案名稱應該都會是 xxxTest，所以建置出來的Dll也會是xxxTest.dll，符合紅框預設尋找的條件，所以不用調整 7.加入Copy Files Task目的是如果前面幾個Task都通過執行到這邊，表示建置沒有問題，且單元測試全部通過，所發行出來的檔案，加下來要把這些檔案複製出來，準備移到成品資料夾[![](https://3.bp.blogspot.com/-Tr8vDR0SmDU/WmmciCbYKwI/AAAAAAAAIXw/5i0cUOgtWDQLXiCveVshcpqSZa1ZQscNACLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-Tr8vDR0SmDU/WmmciCbYKwI/AAAAAAAAIXw/5i0cUOgtWDQLXiCveVshcpqSZa1ZQscNACLcBGAs/s1600/1.png)[![](https://3.bp.blogspot.com/-kmgOU-k_3jY/Wmmc_n-HXlI/AAAAAAAAIX0/0P0WAy6oXRUmGStC-upMnLfFPWck3ydFACLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-kmgOU-k_3jY/Wmmc_n-HXlI/AAAAAAAAIX0/0P0WAy6oXRUmGStC-upMnLfFPWck3ydFACLcBGAs/s1600/1.png) 黑框遮掉的部分就跟之前一樣是專案名稱，我的專案名稱是XXX.Application，所以那個區段請自行置換。 另外還記得Publish這個資料夾嗎?這就是我們剛剛在Visual Studio設定在CICD發行檔的建置發行檔存放的位置，套上預設VSTS建置專案的資料夾變數位置，就變成這行的值了 參考 : VSTS Build variables 8.將成品資料夾內容丟到Drop資料夾[![](https://3.bp.blogspot.com/-88XzfFqDwog/WmmeuQ9zKzI/AAAAAAAAIYE/oIV5xH2wEgADVD-jNi-boqu6ZySliBYnwCLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-88XzfFqDwog/WmmeuQ9zKzI/AAAAAAAAIYE/oIV5xH2wEgADVD-jNi-boqu6ZySliBYnwCLcBGAs/s1600/1.png) [![](https://2.bp.blogspot.com/-RJHr9xJXX60/Wmme3l784sI/AAAAAAAAIYI/Az3zsxDNF38IududQuL3s8zkk7WEDpGmQCLcBGAs/s640/1.png)](https://2.bp.blogspot.com/-RJHr9xJXX60/Wmme3l784sI/AAAAAAAAIYI/Az3zsxDNF38IududQuL3s8zkk7WEDpGmQCLcBGAs/s1600/1.png) 到這邊CI的任務大致完成，已經能將專案自動建置、單元測試、將成品打包準備佈署到Server，接下來如何將這成品佈署到Server就是CD的議題了，留待之後在說。 這邊還有最重要的一點，既然是持續整合，那這些任務如何自動化的持續整合，如果每次版控有異動都還要人來操作這些任務，那就失去了持續整合的意義。 將CI任務加上Trigger條件[![](https://4.bp.blogspot.com/-mpvJaiE8Apc/WmmgTg2yIJI/AAAAAAAAIYY/7FH7zn14ovMWFtsIKCMYhFcW4k4Hm3SSACLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-mpvJaiE8Apc/WmmgTg2yIJI/AAAAAAAAIYY/7FH7zn14ovMWFtsIKCMYhFcW4k4Hm3SSACLcBGAs/s1600/1.png)這邊設定意思是說，當這個專案的Develop分支有新的Commit進來時，剛剛設定的那些任務就會被自動化的執行。 而每次執行的結果如下[![](https://4.bp.blogspot.com/-22JmmaFCkjs/Wmmg5b-NLhI/AAAAAAAAIYg/H9clp3fIeF0NQsHTs96xEr3uSkvnExEfwCLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-22JmmaFCkjs/Wmmg5b-NLhI/AAAAAAAAIYg/H9clp3fIeF0NQsHTs96xEr3uSkvnExEfwCLcBGAs/s1600/1.png) 點擊每一次進去可以看到執行的狀況，或是以及錯誤的Log[![](https://3.bp.blogspot.com/-GNDMtKmEkwg/WmmhlqGuDTI/AAAAAAAAIYo/7tgSawThmfQw6sYKRu9B9k2TkyHwXBG2ACLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-GNDMtKmEkwg/WmmhlqGuDTI/AAAAAAAAIYo/7tgSawThmfQw6sYKRu9B9k2TkyHwXBG2ACLcBGAs/s1600/1.png) 也可以手動排Queue，讓他立即依據現在最新版本或是特定版本去執行 [![](https://1.bp.blogspot.com/-EJjqIGXvgro/Wmmik_1pz3I/AAAAAAAAIY4/8QLNaTEmJrMhAK871kW4yf_YLSyUlMQ5QCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-EJjqIGXvgro/Wmmik_1pz3I/AAAAAAAAIY4/8QLNaTEmJrMhAK871kW4yf_YLSyUlMQ5QCLcBGAs/s1600/1.png) [![](https://3.bp.blogspot.com/-X-V_2Mj63Cs/Wmmi0um07kI/AAAAAAAAIY8/hEtz4yx2s94wJppHAoL2eT6jR0a9DIzgACLcBGAs/s400/1.png)](https://3.bp.blogspot.com/-X-V_2Mj63Cs/Wmmi0um07kI/AAAAAAAAIY8/hEtz4yx2s94wJppHAoL2eT6jR0a9DIzgACLcBGAs/s1600/1.png) Commit可以填入Git的Commit ID，如果不填就會用最新版執行建置。 下一篇預計接著寫CD的部分，如何接著將以上建置完的檔案分別佈署到Azure AppService以及VM機器上。 參考文章 Create your first build and release | Microsoft Docs 發佈網站時依據組態設定的不同而轉換 Web.Config&nbsp; &nbsp;-&nbsp; MRKT [軟體工程]持續整合 (Continuous integration, CI) 簡介 - 91","categories":[{"name":"VSTS建置CI-CD","slug":"VSTS建置CI-CD","permalink":"https://toyo0103.github.io/categories/VSTS%E5%BB%BA%E7%BD%AECI-CD/"}],"tags":[{"name":"CI/CD","slug":"CI-CD","permalink":"https://toyo0103.github.io/tags/CI-CD/"},{"name":"VSTS","slug":"VSTS","permalink":"https://toyo0103.github.io/tags/VSTS/"}]},{"title":"【爬蟲】透過Selenium WebDriver 爬網頁，以Instagram為例","slug":"【爬蟲】透過Selenium-WebDriver-爬網頁，以Instagram為例","date":"2018-01-24T05:49:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2018/01/24/【爬蟲】透過Selenium-WebDriver-爬網頁，以Instagram為例/","link":"","permalink":"https://toyo0103.github.io/2018/01/24/%E3%80%90%E7%88%AC%E8%9F%B2%E3%80%91%E9%80%8F%E9%81%8ESelenium-WebDriver-%E7%88%AC%E7%B6%B2%E9%A0%81%EF%BC%8C%E4%BB%A5Instagram%E7%82%BA%E4%BE%8B/","excerpt":"","text":"常常因為資料分析的需求，會有需要爬網頁資料的時候，而以往爬網頁不外乎將Html拉回來後，依據Tag去拆解資訊。 但現今的網站很大部分都是前端透過API拉版面，以Instagram來說，如果直接透過網址將Html拉回來，會只得到空空的外殼而已，什麼都找不到。 這時候就需要模擬瀏覽器行為來讓Javascript運作，甚至操作瀏覽器去點擊特定按鈕。 [![](https://2.bp.blogspot.com/-6yR04AI5phg/Wmf7S3BE3TI/AAAAAAAAITs/gELt5or7tQkL60jmDRYwb1-YGuNU8cKggCLcBGAs/s400/1.png)](https://2.bp.blogspot.com/-6yR04AI5phg/Wmf7S3BE3TI/AAAAAAAAITs/gELt5or7tQkL60jmDRYwb1-YGuNU8cKggCLcBGAs/s1600/1.png)Instagram拉回來的網頁就只有一個空殼而已.... 透過Selenium.WebDriver，以及Seleium.WebDriver.ChromeDriver套件，可以寫程式操作Chrome的操作行為 [![](https://1.bp.blogspot.com/-DkheSsyDReI/Wmf8FTKy0VI/AAAAAAAAIT0/raZdEEh40xgGJQbTFwhZ2A3aQbOOh4VWACLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-DkheSsyDReI/Wmf8FTKy0VI/AAAAAAAAIT0/raZdEEh40xgGJQbTFwhZ2A3aQbOOh4VWACLcBGAs/s1600/1.png) [![](https://3.bp.blogspot.com/-vnkv6jsDImY/Wmf8OnewkhI/AAAAAAAAIT4/FnlCPUMVsH05noZ1RVbhxFbWqMIYKZJ5gCLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-vnkv6jsDImY/Wmf8OnewkhI/AAAAAAAAIT4/FnlCPUMVsH05noZ1RVbhxFbWqMIYKZJ5gCLcBGAs/s1600/1.png) 接著來一步一步分析如何透過它來爬網頁 開啟Chrome瀏覽器，並且連到想爬的網頁 : https://www.instagram.com/mercci22/ 123456using (IWebDriver driver = new ChromeDriver()) &#123; driver.Navigate().GoToUrl(&quot;https://www.instagram.com/mercci22/&quot;); &#125; 接著分析目標網頁，會發現所有PO文資料都放在一個Div且Class為_cmdpi裡面 [![](https://1.bp.blogspot.com/-sbreT5cUils/Wmf99JegYUI/AAAAAAAAIUI/oIXZxzMGX7c9LU4uVQ9H0BSJUI67UgdGwCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-sbreT5cUils/Wmf99JegYUI/AAAAAAAAIUI/oIXZxzMGX7c9LU4uVQ9H0BSJUI67UgdGwCLcBGAs/s1600/1.png) 往下找出每一行、每一格，在div[class=’_cmdpi’]底下會有div[class=’_70iju’]每一行 [![](https://4.bp.blogspot.com/-yluY12_h7T0/Wmf_JJsdiBI/AAAAAAAAIUQ/zLIRDslBbZQEYGRvu0qXp4JoSdObu-lPwCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-yluY12_h7T0/Wmf_JJsdiBI/AAAAAAAAIUQ/zLIRDslBbZQEYGRvu0qXp4JoSdObu-lPwCLcBGAs/s1600/1.png) 而每一行裡面又有三個Div代表每一格 [![](https://4.bp.blogspot.com/-jnEHEexjkeM/Wmf_roHtA4I/AAAAAAAAIUY/4t6RR_UwEP8-1I7EipD7guWU4Ddyk3d5QCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-jnEHEexjkeM/Wmf_roHtA4I/AAAAAAAAIUY/4t6RR_UwEP8-1I7EipD7guWU4Ddyk3d5QCLcBGAs/s1600/1.png) 所以就來透過套件的API找出每一行，並點擊每一格吧 12345678910111213141516171819using (IWebDriver driver = new ChromeDriver()) &#123; driver.Navigate().GoToUrl(&quot;https://www.instagram.com/mercci22/&quot;); //找到Post的Container var PostContainerElement = driver.FindElement(By.ClassName(&quot;_cmdpi&quot;)); //每一行 var Rows = PostContainerElement.FindElements(By.ClassName(&quot;_70iju&quot;)); foreach (var row in Rows) &#123; var Boxs = row.FindElements(By.XPath(&quot;div&quot;)); foreach (var box in Boxs) &#123; //點擊每一格讓它展開Dialog box.Click(); &#125; &#125; &#125; 這時候如果你執行程式，應該會看到它開啟Chrome並且連到網址然後點擊每一格打開視窗 [![](https://3.bp.blogspot.com/-UIjpEynpLcA/WmgBKT9R10I/AAAAAAAAIUk/WA64zbd-g-YoQdf33ZVlrfVbXDLsYJkhACLcBGAs/s640/1.png)](https://3.bp.blogspot.com/-UIjpEynpLcA/WmgBKT9R10I/AAAAAAAAIUk/WA64zbd-g-YoQdf33ZVlrfVbXDLsYJkhACLcBGAs/s1600/1.png) 接著來分析彈跳出來的視窗，會發現當視窗開啟時，網頁會出現以下Div[role=’dialog’]這個元素，關閉後就會移除 [![](https://4.bp.blogspot.com/-clgYAUdg4y0/WmgBoMCshoI/AAAAAAAAIUo/E3NwCF5n5i8Cpilg7m-OChlEQEgGHOGAwCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-clgYAUdg4y0/WmgBoMCshoI/AAAAAAAAIUo/E3NwCF5n5i8Cpilg7m-OChlEQEgGHOGAwCLcBGAs/s1600/1.png) 所以我們要想辦法拿到這個Div Dialog，才有辦法擷取Po文的文案、日期、圖片，找到Dialog後，後面就重複上述步驟分析Tag，會發現 圖片 : 放在Div[class=’_4rbun’]底下的Img Tag文案&nbsp;: 放在Img Tag的Alt裡面時間 : 放在Article &gt; div &gt; div &gt; a &gt; time這個Tag裡面 所以目前程式如下 12345678910111213141516171819202122232425262728293031323334using (IWebDriver driver = new ChromeDriver()) &#123; driver.Navigate().GoToUrl(&quot;https://www.instagram.com/mercci22/&quot;); //找到Post的Container var PostContainerElement = driver.FindElement(By.ClassName(&quot;_cmdpi&quot;)); //每一行 var Rows = PostContainerElement.FindElements(By.ClassName(&quot;_70iju&quot;)); foreach (var row in Rows) &#123; var Boxs = row.FindElements(By.XPath(&quot;div&quot;)); foreach (var box in Boxs) &#123; //點擊每一格讓它展開Dialog box.Click(); //取得Dialog底下的Article元素 var article = driver.FindElement(By.XPath(&quot;//div[@role=&#x27;dialog&#x27;]/div/div/article&quot;)); //如果Dialog裡面放的是影片，則_4rbun會不存在 if (article.FindElements(By.ClassName(&quot;_4rbun&quot;)).Count == 0) &#123; //跳過這則，這次目標只抓出圖片 continue; &#125; //第一張圖 var ImgContainer = article.FindElement(By.ClassName(&quot;_4rbun&quot;)); var Img = ImgContainer.FindElement(By.TagName(&quot;img&quot;)); var Date = article.FindElement(By.XPath(&quot;div/div/a/time&quot;)); &#125; &#125; &#125; 這時候執行的時候可能會發生Exception，原因嘗試取得Dialog底下的Artilce，但Dialog點擊後產生會有時間差導致 [![](https://4.bp.blogspot.com/-TUSU5eY99xU/WmgWjs_9uBI/AAAAAAAAIVE/QnOtvHvoW38zNLWZQ7m6NpICJluVxyc2QCLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-TUSU5eY99xU/WmgWjs_9uBI/AAAAAAAAIVE/QnOtvHvoW38zNLWZQ7m6NpICJluVxyc2QCLcBGAs/s1600/1.png) 優化這段程式，加上Wait的限制，而Selenium提供兩種Wait的方式 implicitly Wait: 預設等待，當元件暫時找不到時，會嘗試等待，直到timeout時間到。Explicit Wait: 針對特別元件等待。參考文件:Selenium 5. Waits 官方文件 我們這邊加上第一種預設等待 12driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(2); 讀取每個Element時，如果暫時不存在兩秒後TimeOut，之後再執行看看，會發現跑到第二次box.Click()的時候跳Exception。 [![](https://4.bp.blogspot.com/-y0clUXejLl4/WmgZwH5ZmeI/AAAAAAAAIVQ/bDTSCWKn9jkNDem1AxJ-TAQPwPQpW-7hACLcBGAs/s640/1.png)](https://4.bp.blogspot.com/-y0clUXejLl4/WmgZwH5ZmeI/AAAAAAAAIVQ/bDTSCWKn9jkNDem1AxJ-TAQPwPQpW-7hACLcBGAs/s1600/1.png) 原因是當我們打開Dialog時，如果爬完不點擊關閉視窗，會點不到第二隔的元素 [![](https://1.bp.blogspot.com/-gPgFjISg5XI/WmgaJ1qWtUI/AAAAAAAAIVU/ii1yaeglfDgqvpH05tnhPa8Soxe3OszjACLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-gPgFjISg5XI/WmgaJ1qWtUI/AAAAAAAAIVU/ii1yaeglfDgqvpH05tnhPa8Soxe3OszjACLcBGAs/s1600/1.png)蓋住了第二格元素，所以要執行關閉視窗按鈕 123456789101112131415161718192021222324252627282930313233343536373839using (IWebDriver driver = new ChromeDriver()) &#123; driver.Navigate().GoToUrl(&quot;https://www.instagram.com/mercci22/&quot;); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(2); //找到Post的Container var PostContainerElement = driver.FindElement(By.ClassName(&quot;_cmdpi&quot;)); //每一行 var Rows = PostContainerElement.FindElements(By.ClassName(&quot;_70iju&quot;)); foreach (var row in Rows) &#123; var Boxs = row.FindElements(By.XPath(&quot;div&quot;)); foreach (var box in Boxs) &#123; //點擊每一格讓它展開Dialog box.Click(); //取得Dialog底下的Article元素 var article = driver.FindElement(By.XPath(&quot;//div[@role=&#x27;dialog&#x27;]/div/div/article&quot;)); //如果Dialog裡面放的是影片，則_4rbun會不存在 if (article.FindElements(By.ClassName(&quot;_4rbun&quot;)).Count == 0) &#123; //關閉Dialog driver.FindElement(By.ClassName(&quot;_dcj9f&quot;)).Click(); //跳過這則，這次目標只抓出圖片 continue; &#125; //第一張圖 var ImgContainer = article.FindElement(By.ClassName(&quot;_4rbun&quot;)); var Img = ImgContainer.FindElement(By.TagName(&quot;img&quot;)); var Date = article.FindElement(By.XPath(&quot;div/div/a/time&quot;)); //關閉Dialog driver.FindElement(By.ClassName(&quot;_dcj9f&quot;)).Click(); &#125; &#125; &#125; 這樣就可以順利地走完每一格，並且把圖片、文案、時間資料都讀出來了 **** 多圖片的情境加下來是應用的第二部分，Instagram是可以分享多圖片的，而多張圖片是在點擊向右按鈕後，才會動態透過JS撈出來 [![](https://4.bp.blogspot.com/-S8AFeQpjcHk/WmgbnCX9SgI/AAAAAAAAIVk/2jcAH-RsJ4cg7IN6X2_UwCWVmbNX1BJeACLcBGAs/s400/1.png)](https://4.bp.blogspot.com/-S8AFeQpjcHk/WmgbnCX9SgI/AAAAAAAAIVk/2jcAH-RsJ4cg7IN6X2_UwCWVmbNX1BJeACLcBGAs/s1600/1.png) 所以必須寫程式判斷是否有這個按鈕，如果有，表示有多張圖片，要求Driver去點擊那個按鈕，並且撈取Img的Src路徑 1234567891011121314151617181920212223//第一張圖 var ImgContainer = article.FindElement(By.ClassName(&quot;_4rbun&quot;)); var Img = ImgContainer.FindElement(By.TagName(&quot;img&quot;)); //存放Image的Src List List&lt;string&gt; ImgUrls = new List&lt;string&gt; &#123; Img.GetAttribute(&quot;src&quot;) &#125;; //如果有第二張圖以上,則會出現a[class=&#x27;&#x27;_8kphn _by8kl coreSpriteRightChevron&#x27;] //直到不再出現表示最後一張圖到了 while (article.FindElements(By.CssSelector(&quot;a[class=&#x27;_8kphn _by8kl coreSpriteRightChevron&#x27;]&quot;)).Count &gt; 0) &#123; //點擊按鈕 var nextBtn = article.FindElement(By.CssSelector(&quot;a[class=&#x27;_8kphn _by8kl coreSpriteRightChevron&#x27;]&quot;)); nextBtn.Click(); //因為Instagram是透過同一個Img Tag動態去換Src，因為程式點擊下一張按鈕太快 //會導致有Img Tag存在，但Src還來不及換，導致抓到空白的Src //所以不是元素沒出現的問題，只好要求Thread換下一張圖時先暫停0.5秒再抓 Thread.Sleep(500); Img = ImgContainer.FindElement(By.TagName(&quot;img&quot;)); ImgUrls.Add(Img.GetAttribute(&quot;src&quot;)); &#125; 這樣就能順利拿到多張圖的路徑了 讀取第二頁的情境Instagram是滑鼠移到最下方才會動態載入第二頁，所以需要能控制視窗移到最下方來觸發它```csharp IJavaScriptExecutor js = (IJavaScriptExecutor)driver; //如果爬完第一頁還沒爬完，則執行JS讓視窗滾到最下方，觸發讀取第二頁 js.ExecuteScript(\"window.scrollTo(0,1000000)\"); ``` 目前綜合以上所提的應用，應該已經能完全將Instagram的網站資料爬回來，只能說Selenium真的是一個強大的東西阿!! 參考文章:XML XPath的選擇節點語法Selenium Documentation","categories":[],"tags":[{"name":"Selenium","slug":"Selenium","permalink":"https://toyo0103.github.io/tags/Selenium/"}]},{"title":"【RazorEngine】套寄信、罐頭訊息內容的好幫手","slug":"【RazorEngine】套寄信、罐頭訊息內容的好幫手","date":"2018-01-17T03:33:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2018/01/17/【RazorEngine】套寄信、罐頭訊息內容的好幫手/","link":"","permalink":"https://toyo0103.github.io/2018/01/17/%E3%80%90RazorEngine%E3%80%91%E5%A5%97%E5%AF%84%E4%BF%A1%E3%80%81%E7%BD%90%E9%A0%AD%E8%A8%8A%E6%81%AF%E5%85%A7%E5%AE%B9%E7%9A%84%E5%A5%BD%E5%B9%AB%E6%89%8B/","excerpt":"","text":"本篇使用套件 : RazorEngine&nbsp; &nbsp;【官方文件&nbsp;】 遙想當年巷口寶之林還開著時，我這鄉野村夫每每需要套Email寄信格式以及一些罐頭訊息時，總是串一堆字串，既醜又難維護 123456789public ActionResult Test(string name) &#123; var sb = new StringBuilder(); sb.AppendLine(string.Format(@&quot;Hello &#123;0&#125;, welcome to RazorEngine!&quot;,name)); return Content(sb.ToString()); &#125; 如果碰到麻煩一點的，像是什麼狀況要套表頭，某某狀況又要移除Footer，那整個字串的邏輯東拼西湊，最後不執行根本難以看出結果會變成如何，往往就變成維護的黑洞跟死角誰接手誰倒楣。 自從我認識了RazorEngine這套件後，世界就變美好了，只要你會套.Net MVC的View，那基本上這個套件絕對是適合你的神兵利器，廢話不多說，我們先來將剛剛版本改成用RazorEngine處理 先去Nuget安裝套件 [![](https://3.bp.blogspot.com/-C5_gHPnJWEc/Wl64J_9mh5I/AAAAAAAAISA/GiHxPzZP9Qs9OyY_eVI4FrxHeD7MELXxQCLcBGAs/s400/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-C5_gHPnJWEc/Wl64J_9mh5I/AAAAAAAAISA/GiHxPzZP9Qs9OyY_eVI4FrxHeD7MELXxQCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 套上RazorEngine後，可以改成這樣 12345678910111213public ActionResult TestRazorEngine(string name) &#123; string template = &quot;Hello @Model.Name, welcome to RazorEngine!&quot;; var Result = Engine.Razor.RunCompile( templateSource: template, name: &quot;HelloWorldTemplateKey&quot;, modelType: null, model: new &#123; Name = name &#125;); return Content(Result); &#125; 這邊解說一下程式碼，RazorEnginr提供了幾種方法來產生編譯過的Template，分別是 **Run **: 依據帶入的Name去尋找Cache中是否有編譯過的Template，如果Cache沒有這個Name的模板，則會跳Exception **Compile **: 將帶入的模板內容編譯，並存進Cache **RunCompile **: 等於上面兩者個結合，先去Cache中找看看有無這個Name的模板，有則直接回傳，沒有則先編譯後存入Cache，並回傳 依據官方文件所提到的，Compile Template是很耗效能的，所以建議都要存入Cache，避免每次去Compile(預設行為就是如此，當然之後也會提到如何改寫) 有了初步的認識後，應該會發現目前的做法跟拼湊字串一樣，如果只是這樣也就失去了使用RazorEngine的意義了，所以下一步是將這個Template內容變成.cshtml，可以大大的增加可讀性跟維護姓 [![](https://3.bp.blogspot.com/-pfz4iweMebY/Wl68R2ISmxI/AAAAAAAAISM/aEjP8lgBlY0krsOinpRLB1Q88251KecqQCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-pfz4iweMebY/Wl68R2ISmxI/AAAAAAAAISM/aEjP8lgBlY0krsOinpRLB1Q88251KecqQCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)新增_HelloWorld.cshtml Template將剛剛的字串貼進去，並且就像我們一般套版一樣，建立對應的ViewModel [![](https://2.bp.blogspot.com/-cEGoNuCIBPc/Wl68rMWc_6I/AAAAAAAAISQ/wECO1yhBn2My81LPW3lK9aKo9QfXMHnOACLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://2.bp.blogspot.com/-cEGoNuCIBPc/Wl68rMWc_6I/AAAAAAAAISQ/wECO1yhBn2My81LPW3lK9aKo9QfXMHnOACLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 12345public class HellowWorldRazorModel &#123; public string Name &#123; get; set; &#125; &#125; 原本的程式碼改寫成如下 12345678910public ActionResult TestRazorEngine(string name) &#123; var Result = Engine.Razor.RunCompile( &quot;_HelloWorld&quot;, typeof(HellowWorldRazorModel), new HellowWorldRazorModel &#123; Name = name &#125;); return Content(Result); &#125; 但執行之後就會出Exception，原因是”_HelloWorld”這個Template Name它不知道怎麼對應到哪個cshtml模板 [![](https://4.bp.blogspot.com/-8LQ2IYJBnmI/Wl6-F94TFFI/AAAAAAAAISg/FuId2F7jKVYBpu3wOMLY1UPSkOY2P5E2QCLcBGAs/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://4.bp.blogspot.com/-8LQ2IYJBnmI/Wl6-F94TFFI/AAAAAAAAISg/FuId2F7jKVYBpu3wOMLY1UPSkOY2P5E2QCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 所以我們要自己寫RazorEngine的ITemplateManager :&nbsp; 官方文件參考 12345678910111213141516171819202122232425262728293031323334353637public class MyTemplateManager : ITemplateManager &#123; public ITemplateSource Resolve(ITemplateKey key) &#123; // Resolve your template here (ie read from disk) // if the same templates are often read from disk you propably want to do some caching here. var template = Tools.ChkCache(key.Name) as string; if (string.IsNullOrWhiteSpace(template)) &#123; var FilePath = string.Format(&quot;~/Views/RazorTemplate/&#123;0&#125;.cshtml&quot;, key.Name); template = File.ReadAllText(HttpContext.Current.Server.MapPath(FilePath)); Tools.SaveToCache(key.Name, template, 3600, CacheType.Absolute, null); &#125; // Provide a non-null file to improve debugging return new LoadedTemplateSource(template, null); &#125; public ITemplateKey GetKey(string name, ResolveType resolveType, ITemplateKey context) &#123; // If you can have different templates with the same name depending on the // context or the resolveType you need your own implementation here! // Otherwise you can just use NameOnlyTemplateKey. return new NameOnlyTemplateKey(name, resolveType, context); // template is specified by full path //return new FullPathTemplateKey(name, fullPath, resolveType, context); &#125; public void AddDynamic(ITemplateKey key, ITemplateSource source) &#123; // You can disable dynamic templates completely. // This just means all convenience methods (Compile and RunCompile) with // a TemplateSource will no longer work (they are not really needed anyway). throw new NotImplementedException(&quot;dynamic templates are not supported!&quot;); &#125; &#125; 這邊我只改寫Resolve這個方法，其他都沿用官方文件的範本，內容只要是依據帶入的Name去確認Cache是否已經有Template(因為用公司的底層套件，所以確認Cache跟Save Cache可能跟一般認知的方法不同，請忽略或用.Net提供的Cache方法即可)，如果沒有快取，則依據帶入的Name去對應的Folder位置讀取.cshtml並且Cache，然後透過RazorEngine提供的方法LoadedTemplateSource回傳TemplateSource。 這一段可以讓RazorEngine知道如何將Name對應到我們的cshtml，寫完客製的MyTemplateManager後接著是設定 Global.asax加上這段 123456789101112131415protected void Application_Start() &#123; AreaRegistration.RegisterAllAreas(); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); //RazorEngine Setting var config = new TemplateServiceConfiguration(); config.TemplateManager = new MyTemplateManager(); var service = RazorEngineService.Create(config); Engine.Razor = service; &#125; 接著剛剛的程式就能執行了!! [![](https://3.bp.blogspot.com/-NWxWGypeAdo/Wl7AVFb9jRI/AAAAAAAAISs/24bA9qjOkTwoY1ca8SDc8_OXhuB3vI_2QCLcBGAs/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-NWxWGypeAdo/Wl7AVFb9jRI/AAAAAAAAISs/24bA9qjOkTwoY1ca8SDc8_OXhuB3vI_2QCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) RazorEngine也提供Layout的套版方法，可以在cshmtl上面設定對應的Layout，不用像先前提到的，拼字串拼得亂七八糟了 [![](https://3.bp.blogspot.com/-lOts6puSj9Q/Wl7BYAAbwJI/AAAAAAAAIS0/E05MfohLLpgG0Cp2x63uJ8i6ZL-ifJdagCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-lOts6puSj9Q/Wl7BYAAbwJI/AAAAAAAAIS0/E05MfohLLpgG0Cp2x63uJ8i6ZL-ifJdagCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)新增_OurLayout.cshmtl [![](https://3.bp.blogspot.com/-e3Q9NSlCVuk/Wl7Bsff9odI/AAAAAAAAIS4/J0XN1F7PPW0rqsRmvA9yw5cGcTeAjJiawCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-e3Q9NSlCVuk/Wl7Bsff9odI/AAAAAAAAIS4/J0XN1F7PPW0rqsRmvA9yw5cGcTeAjJiawCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)Layout的內容 [![](https://3.bp.blogspot.com/-ugzdMhXnb3w/Wl7CFh0QMAI/AAAAAAAAITA/yxDlQmxK1f4X_4zjamWyCEJnoTUWgwfkgCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-ugzdMhXnb3w/Wl7CFh0QMAI/AAAAAAAAITA/yxDlQmxK1f4X_4zjamWyCEJnoTUWgwfkgCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 執行結果 [![](https://1.bp.blogspot.com/-t8lTrthvFXQ/Wl7CXvDYDMI/AAAAAAAAITE/k4aTtPG7zsIUmvUG4U5hvI7nyOpV6JzmACLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://1.bp.blogspot.com/-t8lTrthvFXQ/Wl7CXvDYDMI/AAAAAAAAITE/k4aTtPG7zsIUmvUG4U5hvI7nyOpV6JzmACLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) RazorEngine PartialView的用法 在一般套版，我們可能會把共用的區塊挖成PartialView重複使用，但這邊的用法比較特別，須改用Include這個方法取代 [![](https://4.bp.blogspot.com/-m5NwrfUZcMs/Wl7C11d-lnI/AAAAAAAAITM/AA-QS-UbaEgFXr8MUjx3olooVMgAEkLbwCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://4.bp.blogspot.com/-m5NwrfUZcMs/Wl7C11d-lnI/AAAAAAAAITM/AA-QS-UbaEgFXr8MUjx3olooVMgAEkLbwCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)新增PartialView [![](https://1.bp.blogspot.com/-NvEYUWh1nkw/Wl7DBfTkNOI/AAAAAAAAITQ/SBSCU6uWL2ck3U7nncXsEo4q5mdRFboiQCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://1.bp.blogspot.com/-NvEYUWh1nkw/Wl7DBfTkNOI/AAAAAAAAITQ/SBSCU6uWL2ck3U7nncXsEo4q5mdRFboiQCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)PartialView的內容，而且也可以使用ViewBag傳遞參數 [![](https://1.bp.blogspot.com/-Ll9MHoSaYtM/Wl7Dk_WcOGI/AAAAAAAAITY/8CF1z0SXs2M21_tS3YCH5KrEY6WP6zAAgCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://1.bp.blogspot.com/-Ll9MHoSaYtM/Wl7Dk_WcOGI/AAAAAAAAITY/8CF1z0SXs2M21_tS3YCH5KrEY6WP6zAAgCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)改寫原本的_HelloWorld.cshtml，套入PartialView 執行結果!! [![](https://3.bp.blogspot.com/-osb6w9vTl8o/Wl7D2hzXn2I/AAAAAAAAITc/KpzyaZf08Fseqa10QxbEEaIdKAJDELv6gCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-osb6w9vTl8o/Wl7D2hzXn2I/AAAAAAAAITc/KpzyaZf08Fseqa10QxbEEaIdKAJDELv6gCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 希望對大家有幫助~","categories":[],"tags":[{"name":"RazorEngine","slug":"RazorEngine","permalink":"https://toyo0103.github.io/tags/RazorEngine/"}]},{"title":"AutoMapper Generic 對應","slug":"AutoMapper-Generic-對應","date":"2018-01-15T03:01:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2018/01/15/AutoMapper-Generic-對應/","link":"","permalink":"https://toyo0103.github.io/2018/01/15/AutoMapper-Generic-%E5%B0%8D%E6%87%89/","excerpt":"","text":"此篇文章用的AutoMapper版本 : 6.2.2 &lt;套件連結&gt; 被同事問到AutoMapper有沒有辦法做泛型的對應，問了一下才發現其他人原來也沒嘗試過這樣的作法，所以來筆記一下供之後參考。 首先對應的Class如下 123456789101112public class Source&lt;T&gt;&#123; public int Page1 &#123;get;set;&#125; public T Value &#123; get; set; &#125;&#125;public class Destination&lt;T&gt;&#123; public int Page &#123;get;set;&#125; public T Value &#123; get; set; &#125;&#125; 希望能將Source&lt;T&gt;對應到Destination&lt;T&gt;，而這邊的泛型T有兩組分別如下 12345678910public class Test&#123; public string Name &#123;get;set;&#125;&#125;public class Test1&#123; public string NickName &#123; get; set; &#125;&#125; 同事原本寫的Mapper Configuration對應如下 123456789101112131415161718192021var config = new MapperConfiguration(cfg =&gt; &#123; cfg.CreateMap&lt;Source&lt;Test&gt;, Destination&lt;Test1&gt;&gt;() .ForMember(d =&gt; d.Page, o =&gt; o.MapFrom(s =&gt; s.Page1)) .ForMember(d =&gt; d.Value, o =&gt; o.MapFrom(s =&gt; s.Value)); cfg.CreateMap&lt;Test, Test1&gt;() .ForMember(d =&gt; d.NickName, o =&gt; o.MapFrom(s =&gt; s.name)); &#125;); var mapper = config.CreateMapper(); Source&lt;Test&gt; Source = new Source&lt;Test&gt; &#123; Page = 1, Value = new Test &#123; name = &quot;hi&quot; &#125; &#125;; Destination&lt;Test1&gt; Result = mapper.Map&lt;Source&lt;Test&gt;, Destination&lt;Test1&gt;&gt;(Source); 這樣寫對應會過，但是變成泛型的T有多種可能時，要寫多組的Source與Destination對應，喪失了AutoMapper的重用性 12345678910cfg.CreateMap&lt;Source&lt;NewClass2&gt;, Destination&lt;NewClass2&gt;&gt;() .ForMember(d =&gt; d.Page, o =&gt; o.MapFrom(s =&gt; s.Page)) .ForMember(d =&gt; d.Value, o =&gt; o.MapFrom(s =&gt; s.Value)); cfg.CreateMap&lt;Source&lt;NewClass3&gt;, Destination&lt;NewClass4&gt;&gt;() .ForMember(d =&gt; d.Page, o =&gt; o.MapFrom(s =&gt; s.Page)) .ForMember(d =&gt; d.Value, o =&gt; o.MapFrom(s =&gt; s.Value)); //............一直往下增加 能不能讓Source與Destination設定一次就好，之後只要多寫Generic的Type對應即可，其實AutoMapper是有提供的，方式如下 1234cfg.CreateMap(typeof(Source&lt;&gt;), typeof(Destination&lt;&gt;)) .ForMember(&quot;Page&quot;,o =&gt; o.MapFrom(&quot;Page1&quot;)) .ForMember(&quot;Value&quot;,o =&gt; o.MapFrom(&quot;Value&quot;)); 之後只要針對泛型的Class補充即可，Source對應到Destination就已經設定完了，以上供參考","categories":[],"tags":[{"name":"AutoMapper","slug":"AutoMapper","permalink":"https://toyo0103.github.io/tags/AutoMapper/"}]},{"title":"【MVC】多語系","slug":"【MVC】多語系","date":"2017-11-17T03:31:00.000Z","updated":"2022-08-09T13:36:17.090Z","comments":true,"path":"2017/11/17/【MVC】多語系/","link":"","permalink":"https://toyo0103.github.io/2017/11/17/%E3%80%90MVC%E3%80%91%E5%A4%9A%E8%AA%9E%E7%B3%BB/","excerpt":"","text":"網站如果希望能提供多語系版本，且網址規則如下該如何實作? http://abcdefg.com/index&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【預設繁體中文】http://abcdefg.com/zh-TW/index 【繁體中文】http://abcdefg.com/zh-CN/index&nbsp; 【簡體中文】http://abcdefg.com/en-US/index&nbsp; 【英文】 先從Action開始，挖個Route參數來抓目前使用者希望的語系為何，並且設定Culture(因為重點是多語系範例，所以就不考慮大小寫判斷那些，還請暫時忽略) 12345678910111213141516171819202122[Route(&quot;~/index&quot;)][Route(&quot;~/&#123;culture&#125;/index&quot;)]public ActionResult Index(string culture)&#123; switch (culture) &#123; case &quot;zh-CN&quot;: break; case &quot;en-US&quot;: break; default: culture = &quot;zh-TW&quot;; break; &#125; //設定多語系 CultureInfo ci = new CultureInfo(culture); Thread.CurrentThread.CurrentCulture = ci; Thread.CurrentThread.CurrentUICulture = CultureInfo.CreateSpecificCulture(ci.Name); return View();&#125; 接著新增語系檔資料夾App_GlobalResource專案右鍵&nbsp; &gt;&nbsp; 加入&nbsp; &gt; 加入ASP.NET資料夾 &gt; App_GlobalResource [![](https://1.bp.blogspot.com/-X0T0qbHbM4g/Wg5DB8tdjCI/AAAAAAAAIQc/OFuD0klzB4sOBimU6auOHx-nduJNgxSagCLcBGAs/s640/1.png)](https://1.bp.blogspot.com/-X0T0qbHbM4g/Wg5DB8tdjCI/AAAAAAAAIQc/OFuD0klzB4sOBimU6auOHx-nduJNgxSagCLcBGAs/s1600/1.png) 新增對應語系的設定檔App_GlobalResources右鍵&nbsp; &gt;&nbsp; 加入&nbsp; &gt; 資源檔 [![](https://2.bp.blogspot.com/-yDb53fw_k78/Wg5Dp4kiDQI/AAAAAAAAIQk/7nBQ-vbv1PcOVvNkoS1H6QpdHvBZIIV-ACLcBGAs/s640/2.png)](https://2.bp.blogspot.com/-yDb53fw_k78/Wg5Dp4kiDQI/AAAAAAAAIQk/7nBQ-vbv1PcOVvNkoS1H6QpdHvBZIIV-ACLcBGAs/s1600/2.png)** **** ** [![](https://2.bp.blogspot.com/-7b1G9a0T0Ec/Wg5EFbj8FoI/AAAAAAAAIQo/xi6QYst8RssqaLd6fxDr9avHWL9XwtCdACLcBGAs/s1600/3.png)](https://2.bp.blogspot.com/-7b1G9a0T0Ec/Wg5EFbj8FoI/AAAAAAAAIQo/xi6QYst8RssqaLd6fxDr9avHWL9XwtCdACLcBGAs/s1600/3.png)這邊的資源檔名稱是固定的，不能任意更改** ** 在各個設定檔設定簡單文字，用來判別是否有正確切換語系 [![](https://2.bp.blogspot.com/-_tlyjSac5Mw/Wg5FEUE-MPI/AAAAAAAAIQ4/EqScZ5b_GUMrvQiG6EU5Pg2qyAKmzs8cgCLcBGAs/s640/1.png)](https://2.bp.blogspot.com/-_tlyjSac5Mw/Wg5FEUE-MPI/AAAAAAAAIQ4/EqScZ5b_GUMrvQiG6EU5Pg2qyAKmzs8cgCLcBGAs/s1600/1.png) [![](https://4.bp.blogspot.com/-SbOTT0V8vy0/Wg5FETAHr3I/AAAAAAAAIQ8/UIejGSO6TDYAihR8r5KtuUMIgV6ERa1ZQCLcBGAs/s640/2.png)](https://4.bp.blogspot.com/-SbOTT0V8vy0/Wg5FETAHr3I/AAAAAAAAIQ8/UIejGSO6TDYAihR8r5KtuUMIgV6ERa1ZQCLcBGAs/s1600/2.png) [![](https://2.bp.blogspot.com/-7JPMV22L3uc/Wg5FEd-t4dI/AAAAAAAAIQ0/0DFlVpoEqPk2LdRgl-dCU_htY2lLaasPQCLcBGAs/s640/3.png)](https://2.bp.blogspot.com/-7JPMV22L3uc/Wg5FEd-t4dI/AAAAAAAAIQ0/0DFlVpoEqPk2LdRgl-dCU_htY2lLaasPQCLcBGAs/s1600/3.png) View上面就簡單做，只顯示出對應語系的CultureNow [![](https://1.bp.blogspot.com/-rkJslBeNSY4/Wg5FaG31wvI/AAAAAAAAIRA/hi6OuzPU7Mw9fmD-tGoDFJ_Z-shVMCpTgCLcBGAs/s400/1.png)](https://1.bp.blogspot.com/-rkJslBeNSY4/Wg5FaG31wvI/AAAAAAAAIRA/hi6OuzPU7Mw9fmD-tGoDFJ_Z-shVMCpTgCLcBGAs/s1600/1.png) 測試 [![](https://2.bp.blogspot.com/-jdlM9kSYyjM/Wg5G94F9tWI/AAAAAAAAIRg/E66m5xlgo64zLs9IcyAenpJUZcdiwm_YQCLcBGAs/s640/Webp.net-gifmaker.gif)](https://2.bp.blogspot.com/-jdlM9kSYyjM/Wg5G94F9tWI/AAAAAAAAIRg/E66m5xlgo64zLs9IcyAenpJUZcdiwm_YQCLcBGAs/s1600/Webp.net-gifmaker.gif) &nbsp;好的做到這邊看起來沒什麼問題，但接下來的問題是，是否後續開發都要在每個Action加上這個RouteAttribute 12345[Route(&quot;~/&#123;culture&#125;/index&quot;)][Route(&quot;~/&#123;culture&#125;/home&quot;)][Route(&quot;~/&#123;culture&#125;/user&quot;)]...... 且設定語系的段落勢必也要寫成ActionFilterAttribute，這樣其實增加了開發的困難之外，只要有人忘記加上，那新的頁面就會少了多語系功能。 工程師的美德就是懶，是否有辦法只做一次就讓全站Route都自動設定好呢? 這時候就要用到DefaultDirectRouteProvider&nbsp;來解決這這個問題了 DefaultDirectProvider能幫我們做什麼?它能幫我們在註冊全站Route Template的時候做一些邏輯的加工，在這邊的案例應用上，我們希望在註冊全站的Route的時候都自動幫我們在Template最前面加上{culture}來達到做一次多語系設定即可 讓我來實作看看，先新增一個CultureRouteProvider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// &lt;summary&gt; /// 多語系Route Provider /// &lt;/summary&gt; /// &lt;seealso cref=&quot;System.Web.Mvc.Routing.DefaultDirectRouteProvider&quot; /&gt; public class CultureRouteProvider: DefaultDirectRouteProvider &#123; /// &lt;summary&gt; /// 取得所指定之動作描述元的一組路由 Factory。 /// &lt;/summary&gt; /// &lt;param name=&quot;actionDescriptor&quot;&gt;動作描述元。&lt;/param&gt; /// &lt;returns&gt; /// 一組路由 Factory。 /// &lt;/returns&gt; protected override IReadOnlyList&lt;IDirectRouteFactory&gt; GetActionRouteFactories(ActionDescriptor actionDescriptor) &#123; IReadOnlyList&lt;IDirectRouteFactory&gt; actionRouteFactories = base.GetActionRouteFactories(actionDescriptor); List&lt;IDirectRouteFactory&gt; actionDirectRouteFactories = new List&lt;IDirectRouteFactory&gt;(); foreach (IDirectRouteFactory routeFactory in actionRouteFactories) &#123; RouteAttribute routeAttr = routeFactory as RouteAttribute; if (routeAttr != null &amp;&amp; !string.IsNullOrEmpty(routeAttr.Template)) &#123; //每個Route Template原本的樣子 //已剛剛的Action為例，就是 &quot;~/index&quot; var template = $&quot;&#123;routeAttr.Template&#125;&quot;; var routeAttribute = new RouteAttribute(template) &#123; Order = routeAttr.Order, Name = routeAttr.Name &#125;; actionDirectRouteFactories.Add(routeAttribute); //替每組Action都多加上一組&#123;culture&#125;/RouterTemplateLanguage的多語系RouteMap //EX: &quot;~/index&quot; 多一組 &quot;~/&#123;culture&#125;/index&quot; var includeLangTemplate = routeAttr.Template.Replace(&quot;~/&quot;, string.Format(@&quot;~/&#123;&#123;culture:regex(^(zh\\-tw|en\\-us|zh\\-cn)$)&#125;&#125;/&quot;)); //註冊這組多語系的Route Template var includeLangRouteAttribute = new RouteAttribute(includeLangTemplate); includeLangRouteAttribute.Order = routeAttr.Order + 1; includeLangRouteAttribute.Name = routeAttr.Name; actionDirectRouteFactories.Add(includeLangRouteAttribute); &#125; &#125; return actionDirectRouteFactories; &#125; &#125; 這邊需要特別注意一下，我在culture後面加上了RouteConstraint的正規表示法限制，目的是讓只有zh-tw ,&nbsp; en-us , zh-cn才會落入這個模板的範圍，如果沒有這段限制，就會變成萬用Route，有點像是{Controller}/{action}/{id}那般，所有網址都會跑到這邊，造成網址大亂!!! 接著將這組CultureRouteProvider在RouteConfig註冊使用 123456789101112public class RouteConfig&#123; public static void RegisterRoutes(RouteCollection routes) &#123; routes.IgnoreRoute(&quot;&#123;resource&#125;.axd/&#123;*pathInfo&#125;&quot;); //註冊CultureRouteProvider var constraintsResolver = new DefaultInlineConstraintResolver(); RouteTable.Routes.MapMvcAttributeRoutes(new CultureRouteProvider()); &#125;&#125; 然後將原本Action那組多語系RouteAttribute拿掉試試看 12345678910111213141516171819202122//拿掉多語系RouteAttribute[Route(&quot;~/index&quot;)]public ActionResult Index(string culture)&#123; switch (culture) &#123; case &quot;zh-CN&quot;: break; case &quot;en-US&quot;: break; default: culture = &quot;zh-TW&quot;; break; &#125; //設定多語系 CultureInfo ci = new CultureInfo(culture); Thread.CurrentThread.CurrentCulture = ci; Thread.CurrentThread.CurrentUICulture = CultureInfo.CreateSpecificCulture(ci.Name); return View();&#125; 會發現多語系的功能依然存在，所以CultureRouteProvider有正確運作，自動的幫我們加上了多語系的Route Template。 接著是處理設定語系的段落，不應該讓設定語系的判斷落在每個Action裡面，所以將它獨立拉出來到自定義的CultureFilter中 12345678910111213141516171819202122232425262728public class CultureFilter : IAuthorizationFilter&#123; public List&lt;string&gt; AllowCultures = new List&lt;string&gt; &#123; &quot;zh-cn&quot;,&quot;zh-tw&quot;,&quot;en-us&quot; &#125;; public void OnAuthorization(AuthorizationContext filterContext) &#123; string culture = string.Empty; if (filterContext.RequestContext.HttpContext.Request.Url.Segments.Count() &amp; gt; 1) &#123; culture = filterContext.RequestContext.HttpContext.Request.Url.Segments[1].Replace(&quot;/&quot;, string.Empty); &#125; if (string.IsNullOrWhiteSpace(culture) || !AllowCultures.Any(x = &gt; x.ToLower() == culture.ToLower())) &#123; culture = &quot;zh-tw&quot;; &#125; //設定多語系 CultureInfo ci = new CultureInfo(culture); Thread.CurrentThread.CurrentCulture = ci; Thread.CurrentThread.CurrentUICulture = CultureInfo.CreateSpecificCulture(ci.Name); &#125;&#125; 在FilterConfig註冊CultureFilter 12345678910public class FilterConfig&#123; public static void RegisterGlobalFilters(GlobalFilterCollection filters) &#123; filters.Add(new HandleErrorAttribute()); //多國語系 filters.Add(new CultureFilter()); &#125;&#125; 將原本的Action所有判斷拿掉會發現多語系的功能還是一切正常 123456[Route(&quot;~/index&quot;)]public ActionResult Index()&#123; return View();&#125; 這樣就差不多大功告成，其實要優化的地方還很多，例如大小寫判斷，多語系應該拉成Enum方便擴充，Route Constraint應該跟隨著多語系的Enum去自動產生….等，因為這是獨立拉出來Demo的程式，就不搞得像Production Code一樣複雜了，知道自己注意一下就好XD","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【MVC】Router Constraint","slug":"【MVC】Router-Constraint","date":"2017-11-16T03:17:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2017/11/16/【MVC】Router-Constraint/","link":"","permalink":"https://toyo0103.github.io/2017/11/16/%E3%80%90MVC%E3%80%91Router-Constraint/","excerpt":"","text":"當今天有個網址的需求是 http://abcdefg.com/【使用者暱稱】，使用者暱稱帶到誰的就會到個人頁網址，EX : http://abcdefg.com/toyo 就連到Toyo個人頁面，http://abcdefg.com/steven就連到Steven個人頁，那我們Router可以寫成 1234567[Route(&quot;~/toyo&quot;)][Route(&quot;~/steven&quot;)]public ActionResult Content()&#123; return View();&#125; 這樣寫的確兩個網址都能連到了，但卻抓不到UserName所以不知道怎麼顯示個人頁，調整一下 1234567[Route(&quot;~/&#123;UserName&#125;&quot;)]public ActionResult Content(string userName)&#123; ViewBag.Name = userName; return View();&#125; 下個問題來了，Tom明明不是這邊的用戶，卻也會導到這個Action，導致後端抓不到對應資料顯示錯誤，能不能只有abcdefg.com/Toyo 跟 abcdefg.com/Steven 的時候才導來這，其他什麼阿貓阿狗，甚至是常用的Index、Home、Menu之類的不會跑錯。 這時候RouteConstraint就派上用場了 12345678910111213141516public class UserNameConstraint : IRouteConstraint&#123; public bool Match(HttpContextBase httpContext, Route route, string parameterName, RouteValueDictionary values, RouteDirection routeDirection) &#123; if (values.ContainsKey(parameterName)) &#123; var UserName = values[parameterName] as string; return UserName.ToLower() == &quot;toyo&quot; || UserName.ToLower() == &quot;steven&quot;; &#125; return false; &#125;&#125; 接著在RouteConfig註冊這組Constraint，讓RouteAttribute可以使用 12345678910111213public class RouteConfig&#123; public static void RegisterRoutes(RouteCollection routes) &#123; routes.IgnoreRoute(&quot;&#123;resource&#125;.axd/&#123;*pathInfo&#125;&quot;); //註冊Router ConStraint var constraintsResolver = new DefaultInlineConstraintResolver(); constraintsResolver.ConstraintMap.Add(&quot;MustUserName&quot;, typeof(UserNameConstraint)); routes.MapMvcAttributeRoutes(constraintsResolver); &#125;&#125; 將RouteAttribute的UserName加上這個限制 1234567[Route(&quot;~/&#123;UserName:MustUserName&#125;&quot;)]public ActionResult MyContent(string userName)&#123; ViewBag.Name = userName; return View();&#125; 這樣只要UserName不是帶Toyo或是Steven的就都不會導到這個Action了。 其實RouteConstraint官方已經提供一下基礎的限制可以使用，例如一定要是Int，字串長度之類的方便用法，而且更重要的是在這案例之中，使用者名稱我們是寫死的，只要把那段改成抓外部來源，例如資料庫之類的，這樣就能後台使用者有新增時，Route的限制就自動更新了 延伸閱讀:Attribute Routing in ASP.NET MVC 5 DemoShop :&nbsp;ASP.NET MVC Route 自訂限制條件（constraints）的技巧","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【Tools】修復Html缺少Close Tag問題 - HtmlAgilityPack","slug":"【Tools】修復Html缺少Close-Tag問題-HtmlAgilityPack","date":"2017-11-15T01:36:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2017/11/15/【Tools】修復Html缺少Close-Tag問題-HtmlAgilityPack/","link":"","permalink":"https://toyo0103.github.io/2017/11/15/%E3%80%90Tools%E3%80%91%E4%BF%AE%E5%BE%A9Html%E7%BC%BA%E5%B0%91Close-Tag%E5%95%8F%E9%A1%8C-HtmlAgilityPack/","excerpt":"","text":"開放後台給非工程人員編輯Html，往往都要擔負一些Html Tag錯誤整導致破版的風險。這次就碰到上線前發現部分資料區塊缺少了Close Tag，導致只要讀到那些資料的頁面都破版，但上千筆資料請人一筆一筆去檢查又太不切實際。所以就研究了一下是否有套件可以處理這類的問題，結果就發現了一個強大的套件 :&nbsp;HtmlAgilityPack 該套件主要功能是拿來解析網頁，似乎更多人是拿來製作爬蟲工具，但他同時也很貼心的提供API來分析Html Tag是否正確 首先先從Nuget載入該套件 [![](https://2.bp.blogspot.com/-cMfu_9lAHPY/WguV9l_rY0I/AAAAAAAAIQM/3thXpbJDKr4ZQPGb5T7Ff-waUuo7p6tWgCLcBGAs/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://2.bp.blogspot.com/-cMfu_9lAHPY/WguV9l_rY0I/AAAAAAAAIQM/3thXpbJDKr4ZQPGb5T7Ff-waUuo7p6tWgCLcBGAs/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 然後用以下程式來進行Html修復 123456789101112131415161718192021222324252627282930//商品的尺寸報表Html有錯誤var ps = this.Products.Where(x = &gt; x.SizeReport != null);foreach (var p in ps)&#123; HtmlDocument doc = new HtmlDocument(); //fix when nesting errors are detected doc.OptionFixNestedTags = true; //將Html Editor編輯的東西丟進去 doc.LoadHtml(p.SizeReport.ToString()); //將修復後的Html結果存到MemoryStream MemoryStream stream = new MemoryStream(); doc.Save(stream); try &#123; using (StreamReader reader = new StreamReader(stream, Encoding.Default)) &#123; stream.Position = 0; p.SizeReport = reader.ReadToEnd(); //儲存回DB this.SubmitChanges(); &#125; &#125; catch (Exception ex) &#123; &#125;&#125;","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Tools","slug":"Tools","permalink":"https://toyo0103.github.io/tags/Tools/"}]},{"title":"【Azure】如何跨DB讀取資料","slug":"【Azure】如何跨DB讀取資料","date":"2017-11-09T02:05:00.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2017/11/09/【Azure】如何跨DB讀取資料/","link":"","permalink":"https://toyo0103.github.io/2017/11/09/%E3%80%90Azure%E3%80%91%E5%A6%82%E4%BD%95%E8%B7%A8DB%E8%AE%80%E5%8F%96%E8%B3%87%E6%96%99/","excerpt":"","text":"忙了一大段時間，突然發現好長時間沒更新部落格了，這段時間專案實在太忙了，慢慢的再把這些時間學到的東西慢慢筆記下來，今天就先從Azure開始吧!! 以前如果有跨DB存取或Join Table，通常都會請DBA開Link DB的方式來處理，但在Azure SQL上面就沒有這個選項了 [![](https://2.bp.blogspot.com/-LvGu3FglCEI/WgOxsaEfz7I/AAAAAAAAIP8/3xQmoM8lFCs4oIawixv-HHidz_NHEjRpQCEwYBhgL/s1600/1.png)](https://2.bp.blogspot.com/-LvGu3FglCEI/WgOxsaEfz7I/AAAAAAAAIP8/3xQmoM8lFCs4oIawixv-HHidz_NHEjRpQCEwYBhgL/s1600/1.png)跨DB讀取資料 但它推出了一個語法來達成這樣子的需求 External Data Source，假設我在**A資料庫**，想要Join **B資料庫**的**PromoEmail Table**取得行銷案的Email資料來做交叉分析，這時候我們可以這樣寫 1234567891011121314151617181920212223242526272829303132CREATE MASTER KEY ENCRYPTION BY PASSWORD = &#x27;This Account Password&#x27;; CREATE DATABASE SCOPED CREDENTIAL AzureStorageCredential WITH IDENTITY = &#x27;This DataBase Login Account&#x27;, SECRET = &#x27;This Account Password&#x27;;CREATE EXTERNAL DATA SOURCE RefPromoTableDataBaseWITH ( TYPE=RDBMS, LOCATION =&#x27;Your Azure SQL Database Location&#x27;, DATABASE_NAME = &#x27;B&#x27;, --外連B資料庫 CREDENTIAL = AzureStorageCredential); --建立一個External Table--這邊Schema就取決於你要從B Database的PromoEmail Table取得什麼欄位--欄位名稱跟資料型態要相同CREATE EXTERNAL TABLE [dbo].[PromoEmail]( [Email] [varchar] (300) Not NULL ) WITH ( DATA_SOURCE = RefPromoTableDataBase); --在A資料庫Join PromoEmail Table--看看行銷案轉換成訂單的績效SELECT emailFROM [Order] oJoin PromoEmail pe on o.UserEmail = pe.Email 當然最後做完後，要記得把這些資源都釋放掉 12345DROP EXTERNAL TABLE PromoEmailDROP EXTERNAL DATA SOURCE RefPromoTableDataBaseDROP DATABASE SCOPED CREDENTIAL AzureStorageCredential DROP MASTER KEY 參考資料Cross Database Queries In Azure SQLSETTING UP CROSS DATABASE QUERIES IN AZURE SQL DATABASE","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"},{"name":"Azure","slug":"Azure","permalink":"https://toyo0103.github.io/tags/Azure/"}]},{"title":"【Unit Test】Day 7 - Assert","slug":"【Unit-Test】Day-7-Assert","date":"2017-04-25T03:40:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2017/04/25/【Unit-Test】Day-7-Assert/","link":"","permalink":"https://toyo0103.github.io/2017/04/25/%E3%80%90Unit-Test%E3%80%91Day-7-Assert/","excerpt":"","text":"Demo檔案 : Git傳送門 今天要來談談驗證，還記得之前的PTX範例都只驗證名稱嗎？ 123//assert Assert.AreEqual(actual.Name, expected); 因為有說如果是參考型別的話，Assert.AreEqual可能會驗證失敗 12345678910111213141516171819202122[TestMethod] public void 透過Assert驗證參考型別() &#123; //arrange Guid ID = Guid.NewGuid(); var expected = new Member &#123; ID = ID, Name = &quot;Name&quot; &#125;; //act var actual = new Member &#123; ID = ID, Name = &quot;Name&quot; &#125;; //assert Assert.AreEqual(expected,actual); &#125; 結果 試試看改一下寫法 123456789101112131415161718[TestMethod] public void 透過Assert驗證參考型別2() &#123; //arrange Guid ID = Guid.NewGuid(); var expected = new Member &#123; ID = ID, Name = &quot;Name&quot; &#125;; //act var actual = expected; //assert Assert.AreEqual(expected, actual); &#125; 原來Assert.AreEqual當碰到參考型別的時候是驗證記憶體位置，但其實像我是寫商業邏輯的，常常在乎的是透過方法執行完後得到的DTO（Data Transfer Object）是否符合預期，這樣其實Assert對我來說不是那麼方便。 MSDN: Assert 類別 如果我真的只想驗證執行完的DTO內容是否符合預期，該怎麼做呢？來看看FluentAssertions吧 在單元測試專案用Nuget安裝完成後，來看看範例寫法 1234567891011121314151617181920212223[TestMethod] public void 透過FluentAssertions驗證參考型別() &#123; //arrange Guid ID = Guid.NewGuid(); var expected = new Member &#123; ID = ID, Name = &quot;Name&quot; &#125;; //act var actual = new Member &#123; ID = ID, Name = &quot;Name&quot; &#125;; //assert actual.ShouldBeEquivalentTo(expected); &#125; 就這麼簡單，它就會幫你驗證內容的值而不是記憶體位置，而且可讀性也很高，再舉幾個範例 是否為Null 12345678910111213141516171819202122232425262728[TestMethod] public void 透過FluentAssertions驗證不為Null() &#123; //arrange //act var actual = new Member &#123; ID = Guid.NewGuid(), Name = &quot;Name&quot; &#125;; //assert actual.Should().NotBeNull(); &#125; [TestMethod] public void 透過FluentAssertions驗證為Null() &#123; //arrange //act Member actual = null; //assert actual.Should().BeNull(); &#125; ** **驗證數字 123456789101112[TestMethod] public void 透過FluentAssertions驗證數字() &#123; //arrange //act int actual = 123; //assert actual.Should().Be(123); &#125; 驗證趨近於倍精準相加時會有些微誤差 12345678910111213[TestMethod] public void 透過FluentAssertions驗證趨近於() &#123; //arrange var a = 1.3; var b = 0.1; //act double actual = a + b ; //assert actual.Should().Be(1.4); &#125; 驗證地方可改成 1234//assert//趨近於1.4 且如果誤差小於0.00001時視為一樣actual.Should().BeApproximately(1.4,0.00001); 驗證排序 123456789101112131415161718192021222324[TestMethod] public void 透過FluentAssertions驗證升冪排序() &#123; //arrange var parameter = new List&lt;int&gt; &#123; 4, 7, 1, 3, 8 &#125;; //act var actual = parameter.OrderBy(x=&gt;x); //assert actual.Should().BeInAscendingOrder(); &#125; [TestMethod] public void 透過FluentAssertions驗證降冪排序() &#123; //arrange var parameter = new List&lt;int&gt; &#123; 4, 7, 1, 3, 8 &#125;; //act var actual = parameter.OrderByDescending(x =&gt; x); //assert actual.Should().BeInDescendingOrder(); &#125; 結論FluentAssertions是個閱讀性高且豐富的驗證套件，以上提供一些我常常使用到的斷言方法，還有很多可以參考官網文件，那今天就先到這了！！","categories":[{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】Day 6 - 單元測試初始化與清除","slug":"【Unit-Test】Day-6-單元測試初始化與清除","date":"2017-04-24T03:33:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2017/04/24/【Unit-Test】Day-6-單元測試初始化與清除/","link":"","permalink":"https://toyo0103.github.io/2017/04/24/%E3%80%90Unit-Test%E3%80%91Day-6-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E5%88%9D%E5%A7%8B%E5%8C%96%E8%88%87%E6%B8%85%E9%99%A4/","excerpt":"","text":"Demo檔案 : Git傳送門 今天要來看看單元測試的初始化設定與清除 圖片出處：https://www.codeproject.com/Articles/1165536/Unit-Test-Initialization-and-Cleanup 上圖是單元測試在執行時的生命週期，知道了這特性的時候我們就可以依據測試的需要來加入適當的初始化設定。 ****以下範例來說明執行順序這邊準備了一個Static Class，裡面有個Get方法很簡單的回傳Now這個屬性值 12345678910public static class Demo &#123; public static int Now &#123; get; set; &#125; public static int Get() &#123; return Now; &#125; &#125; 然後為它建立單元測試 先加上一個TestHook的檔案 123456789101112131415161718[TestClass] public class TestHook &#123; [AssemblyInitialize] public static void AssemblyInit(TestContext context) &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - AssemblyInitialize&quot;, Demo.Get())); Demo.Now += 1; &#125; [AssemblyCleanup] public static void AssemblyCleanUp() &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - AssemblyCleanup&quot;, Demo.Get())); Demo.Now += 1; &#125; &#125; 接著撰寫DemoTests.cs 123456789101112131415161718192021222324252627282930313233343536373839[TestClass] public class DemoTests &#123; [ClassInitialize] public static void ClassInit(TestContext context) &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - ClassInitialize&quot;, Demo.Get())); Demo.Now += 1; &#125; [TestInitialize] public void TestInit() &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - TestInitialize&quot;, Demo.Get())); Demo.Now += 1; &#125; [TestMethod] public void GetTest() &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - Test1&quot;, Demo.Get())); Demo.Now += 1; &#125; [TestCleanup] public void TestCleanUp() &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - TestCleanup&quot;, Demo.Get())); Demo.Now += 1; &#125; [ClassCleanup] public static void ClassCleanUp() &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - ClassCleanup&quot;, Demo.Get())); Demo.Now += 1; &#125; &#125; 這裡目標很間單，測試的內容不是重點，而是希望透過輸出來看到執行的順序 可能有人會注意到為何有些方法例如ClassCleanup是需要Static，有些又需要帶入TestContext的參數？這其實是規定，如果不按照規則撰寫的話，執行單元測試時就會得到以下錯誤訊息 接著執行單元測試看看輸出，點擊下面的輸出按鈕 這樣看就很明顯知道順序了！！讓我們加上第二個測試 1234567[TestMethod] public void GetTest2() &#123; Console.WriteLine(string.Format(&quot;&#123;0&#125; - Test2&quot;, Demo.Get())); Demo.Now += 1; &#125; 全部測試執行然後看看結果 可以發現TestInitialize與TestCleanUp是每個測試在執行前/後都會執行一次的，而且要特別強調一下，每個單元測試執行的順序是不固定的，所以如果在單元測試中有些初始化的動作，切記不要依賴每個測試之間的順序關係，否則可能會不定時的產生錯誤，請把每個測試都當成是獨立且無相依關係！！ 從這個範例也可以看得到一個結論，如果在測試中有用到Production Code中Static的參數或屬性，請記得養成良好習慣，要在CleanUp的方法中恢復它的預設值，否則Static是共用的，如果其他測試有用到同一個Static屬性，而互相改來改去不初始化，就很可能發生單元測試時好時壞的問題，這是切身之痛請勿以身試法ＸＤＤ","categories":[{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】Day 5 - 透過InternalsVisibleTo來達成單元測試的外部注入","slug":"【Unit-Test】Day-5-透過InternalsVisibleTo來達成單元測試的外部注入","date":"2017-04-21T06:34:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2017/04/21/【Unit-Test】Day-5-透過InternalsVisibleTo來達成單元測試的外部注入/","link":"","permalink":"https://toyo0103.github.io/2017/04/21/%E3%80%90Unit-Test%E3%80%91Day-5-%E9%80%8F%E9%81%8EInternalsVisibleTo%E4%BE%86%E9%81%94%E6%88%90%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E7%9A%84%E5%A4%96%E9%83%A8%E6%B3%A8%E5%85%A5/","excerpt":"","text":"Demo檔案 : Git傳送門請參照UnitTest_Day5的Branch 延續昨日的進度，我們將呼叫API的RestSharp獨立出來，並且用依賴介面及外部注入的方式將IRestSharp注入到PTX來達成隔離，並且做到可測試性。 但面臨令一個問題，如果今天開發的是共用套件類的專案，這樣變成要使用物件都必須知道該用什麼東西注入才可使用，這往往會造成使用者困擾，封裝性也不佳，因外部注入的IRestSharp是每個人都可以另外實作的。 甚至更深一層去想，究竟IRestSharp是否需要用Public讓外部使用者都知道有這個東西呢？ 是不是反而因為要達到可測試性而讓封裝這件事做得更差？ 來看看另一種方式 假設我認為使用這個套件的人只要簡單的建立PTX後即可使用，至於內部如何呼叫API的實作使用者並不需要關心，那麼我們先將IRestSharp從建構子拿掉吧，並且做一個專門產生IRestSharp實體的Factory來滿足需求。 撰寫IRestSharpFactory 123456789101112131415/// &lt;summary&gt; /// 製作IRestSharp的工廠 /// &lt;/summary&gt; internal class IRestSharpFactory &#123; //這邊特別注意存取修飾子是用Internal //原因是我並不希望專案之外的人使用且知道有這東西 //而internal剛好能滿足這需求 internal static IRestSharp Generate() &#123; //產生實體 return new MyRestSharp(); &#125; &#125; 接著修改原本的PTX.cs 12345678910111213141516171819202122public class PTX &#123; IRestSharp _MyRestSharp &#123; get &#123; //這邊改成用工廠建立MyRestSharp實體 return IRestSharpFactory.Generate(); &#125; &#125; /// &lt;summary&gt; /// Construct /// &lt;/summary&gt; public PTX() &#123; //建構子參數移除 &#125; 以下省略..... &#125; 這邊馬上面臨到一個問題，那我們怎麼Mock IRestSharp，昨天是放在建構子中並透過Nsubstitute來Mock 封裝性變好了，但也變得難以介入模擬外部行為 從IRestSharpFactory著手吧！！ 想辦法讓IRestSharpFactory可以讓我們注入Mock的假物件 1234567891011121314151617181920212223/// &lt;summary&gt; /// 製作IRestSharp的工廠 /// &lt;/summary&gt; internal class IRestSharpFactory &#123; /// &lt;summary&gt; /// 此屬性只供UnitTest注入 /// &lt;/summary&gt; internal static IRestSharp _IRestSharpForUnitTest; internal static IRestSharp Generate() &#123; //如果這個值不為Null,則表示單元測試所注入,直接回傳 if (_IRestSharpForUnitTest != null) &#123; return _IRestSharpForUnitTest; &#125; //產生實體 return new MyRestSharp(); &#125; &#125; 這邊開了一個_IRestSharpForUnitTest屬性，讓外部能夠注入它，接著在Generate的方法中判斷，如果當_IRestSharpForUnitTest不為Null時，直接回傳（通常會特別在這個屬性寫上說明僅供單元測試使用，正常Production Code禁止使用！！） 想辦法在單元測試中注入_IRestSharpForUnitTest你可能會發現在單元測試中看不到IRestSharpFactory…. 原因是我們宣告成Internal，如果要能在專案之外看到就只能開成Public了，但回到最一開始討論的，不就是為了封裝才把他宣告成Internal嗎？如果又改回Public那我們這段工不就白費了，還好還有別的方法可以達成。 告訴UnitTestDay3這個專案，除了它自己之外，還有誰能看到它宣告成Internal的類別與屬性方法**讓我們先打開UnitTestDay3**專案的AssemblyInfo 寫下這行 InternalsVisibleTo這邊是要填AssemblyName，透過這個Attribute告訴UnitTestDay3這個專案還有誰能看到它內部的Internal。而AssemblyName怎麼看呢？在專案上右鍵 &gt; 屬性 如果你有很多單元測試專案需要能看到，InternalsVisibleTo是可以很多組的。 接著在單元測試中就可以看到啦 這樣就達成我們想封裝起來的需求，卻也能讓單元測試進行注入，那今天就談到這吧！！","categories":[{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】Day 4 - Mock","slug":"【Unit-Test】Day-4-Mock","date":"2017-04-20T08:59:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2017/04/20/【Unit-Test】Day-4-Mock/","link":"","permalink":"https://toyo0103.github.io/2017/04/20/%E3%80%90Unit-Test%E3%80%91Day-4-Mock/","excerpt":"","text":"Demo檔案 : Git傳送門因為程式是昨天的延續，所以是同一個Repository切出UnitTest_Day4的Branch 讓繼續我們昨天的議題，節錄昨天最後的結論 …這個方法也不是百分之百沒有缺點，你應該也可以觀察到其中一段在這單元測試中無法被涵蓋到，那就是組API Url那段，在這種透過繼承解耦合的方式中，因為回傳結果是自己設定的，實際上組成的URL正確與否我們並不知道，換句話說，如果我們今天這樣寫測試可能會過，但上線後才會發現錯誤，檢查之下發現原來是在串Url的時候錯字之類的。 身為一位專業有責任感的工程師，你一定想著「爾等豈能如此苟且偷生便宜行事草率」，所以今天就來談談另一種方法，Mock。 何謂Mock。當測試時你關注與外部相依物件互動時其狀態的變化，並且驗證它，則此就是Mock物件。 很抽象對吧，沒關係讓我們來改改昨天的實作，重中瞭解Stub與Mock的差異。 先將呼叫API的地方徹底隔離出去開一個NetTool的資料夾，建立一個IRestSharp的介面 該介面定義出呼叫API該傳入Url，回傳得到的結果 12345678910public interface IRestSharp &#123; /// &lt;summary&gt; /// 用Get的方法呼叫API /// &lt;/summary&gt; /// &lt;param name=&quot;url&quot;&gt;Url&lt;/param&gt; /// &lt;returns&gt;回傳的內容&lt;/returns&gt; string Get(string url); &#125; 實做這個介面 123456789101112131415161718192021222324public class MyRestSharp : IRestSharp &#123; /// &lt;summary&gt; /// 用Get的方法呼叫API /// &lt;/summary&gt; /// &lt;param name=&quot;url&quot;&gt;Url&lt;/param&gt; /// &lt;returns&gt;回傳的內容&lt;/returns&gt; public string Get(string url) &#123; //Use RestSharp Call API var client = new RestClient(url); var request = new RestRequest(Method.GET); request.AddHeader(&quot;cache-control&quot;, &quot;no-cache&quot;); IRestResponse response = client.Execute(request); if (response.StatusCode == HttpStatusCode.OK) &#123; return response.Content; &#125; return string.Empty; &#125; &#125; 修改PTX的程式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class PTX &#123; IRestSharp _MyRestSharp; /// &lt;summary&gt; /// Construct /// &lt;/summary&gt; /// &lt;param name=&quot;myRestSharp&quot;&gt;外部注入呼叫API的實體&lt;/param&gt; public PTX(IRestSharp myRestSharp) &#123; //改由外部注入呼叫API的實體 this._MyRestSharp = myRestSharp; &#125; /// &lt;summary&gt; /// 取得巴士路線資料 /// &lt;/summary&gt; /// &lt;param name=&quot;city&quot;&gt;縣市名稱&lt;/param&gt; /// &lt;param name=&quot;routeName&quot;&gt;巴士路線名稱&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public BusRouteDTO Get(string city,string routeName) &#123; BusRouteDTO Result = null; //要呼叫的API Url string Url = string.Format($&quot;http://ptx.transportdata.tw/MOTC/v2/Bus/StopOfRoute/City/&#123;city&#125;/&#123;routeName&#125;?%24top=1&amp;%24format=JSON&quot;); var JsonResult = _MyRestSharp.Get(Url); if (!string.IsNullOrEmpty(JsonResult)) &#123; var APIResult = JsonConvert.DeserializeObject&lt;List&lt;PTXBusRouteResult&gt;&gt;(JsonResult); if (APIResult != null &amp;&amp; APIResult.Count &gt; 0) &#123; var Route = APIResult.First(); Result = new BusRouteDTO &#123; Name = Route.RouteName.Zh_tw, BusStops = new List&lt;BusRouteDTO.BusStop&gt;() &#125;; foreach (var stop in Route.Stops) &#123; Result.BusStops.Add(new BusRouteDTO.BusStop &#123; ID = stop.StopUID, Name = stop.StopName.Zh_tw &#125;); &#125; &#125; &#125; return Result; &#125; &#125; 修改Program.cs 123456789101112131415class Program &#123; static void Main(string[] args) &#123; //new PTX時變成要帶入呼叫API的實體 var PTXFunction = new PTX(new MyRestSharp()); var Result = PTXFunction.Get(&quot;Taipei&quot;,&quot;307&quot;); Console.Write(JsonConvert.SerializeObject(Result)); Console.ReadKey(); &#125; &#125; 執行後結果是對的！！ 單元測試到目前為止都沒有解釋太多為何要這樣改，不過這跟物件導向設計比較有關，即所謂的外部注入即依賴介面，但這比較偏設計的範疇這邊就不特別討論，不過之後應該會漸漸的發現，如果單元測試要能寫，很多地方都會必須要有物件導向的設計方式才有辦法。 讓我們回頭看單元測試，首先昨天做的PTXStub就沒用了，因為目前的PTX沒有將呼叫API封裝起來，也就沒有可以override的CallAPI方法了，把它砍掉了。 這時就會看到昨天的單元測試壞掉了，因為找不到PTXStub 開始做我們的假物件MyRestSharpMock吧 12345678910111213141516public class MyRestSharpMock : IRestSharp &#123; public string Get(string url) &#123; if (url == &quot;http://ptx.transportdata.tw/MOTC/v2/Bus/StopOfRoute/City/Taipei/307?%24top=1&amp;%24format=JSON&quot;) &#123; var sb = new System.Text.StringBuilder(12766); sb.AppendLine(@&quot;[&#123;&quot;&quot;RouteUID&quot;&quot;:&quot;&quot;TPE16111&quot;&quot;,&quot;&quot;RouteID&quot;&quot;:&quot;&quot;16111&quot;&quot;,&quot;&quot;RouteName&quot;&quot;:&#123;&quot;&quot;Zh_tw&quot;&quot;:&quot;&quot;307&quot;&quot;,&quot;&quot;En&quot;&quot;:&quot;&quot;307&quot;&quot;&#125;,.....省略&quot;); return sb.ToString(); &#125; return string.Empty; &#125; &#125; 這邊特別注意一下if那邊，依據昨天的單元測試，最後網址應該要組成這樣才是正確的，所以我們MyRestSharpMock特地加上這段判斷，已經不像昨天override一樣，不關心它組的網址為何，一律依照我們設定的結果回傳，即便你其實Url組的是錯誤的。 修改PTXTest.cs 123456789101112131415161718192021[TestClass()] public class PTXTests &#123; [TestMethod()] public void GetTest_傳入縣市和公車路線名稱_如果查的到資料_應回傳該路線的BusRouteDTO() &#123; //arrange var RestSharpMock = new MyRestSharpMock(); var Sut = new PTX(RestSharpMock); //注入我們模擬的假物件MyRestSharpMock var City = &quot;Taipei&quot;; var RouteName = &quot;307&quot;; var expected = &quot;307&quot;; //act var actual = Sut.Get(City, RouteName); //assert Assert.AreEqual(actual.Name, expected); &#125; &#125; 我們注入的是自己Mock的物件，他不會實際去呼叫API，但它關注我們傳入的值對不對，執行單元測試看看結果。 可能到這邊會有一個疑問是，「廢話，Mock的物件是我們自己做的，我們想怎麼樣都馬可以！！」，一開始學到這段的時候也有這個疑問，所以容我解釋一下，還記得先前提到的觀念嗎？ 單元測試關注本身的邏輯，而非外部的關聯 如果今天上線後發現錯誤，而發生錯誤的地方是在呼叫API的程式，那該修改的是誰？當然是MyRestSharp.cs，也絕對不是PTX這支程式，因為它職責掌管的邏輯全部都是正確的。而我們現在單元測試以及MyRestSharpMock都是在做什麼？ 都是在輔助我們驗證PTX所有包含到的邏輯，我們並不關注外部其他程式到底幹了什麼，退一萬步說（好啦其實退一步就可以了）（你好煩）今天IRestSharp這個Interface你的夥伴忘記去實作導致程式上線壞了，那也不會是改你的PTX吧，要改可以，over my dead body先，所以希望這囉說的補充可以幫助釐清這件事情。 好的，上面這邊如果沒問題的話，那下一步應該心裡就會冒出一個OS :我的好天鵝啊！！ 如果外部相依的物件很多，每個都自己做Mock物件，做完都老了，單元測試沒寫完Deadline就到了，搞毛啊….看官稍安勿躁，你的心聲有人聽到了，所以接下來介紹一個可以省略掉剛剛一堆繁瑣的動作，登登登登，為您隆重介紹NSubstitute，怎麼用呢？讓我們在UnitTestDay3Tests這個專案透過Nuget安裝這個套件 怎麼用呢？先Using 12using NSubstitute; 然後… 1234567891011121314151617181920212223242526272829303132[TestClass()] public class PTXTests &#123; [TestMethod()] public void GetTest_傳入縣市和公車路線名稱_如果查的到資料_應回傳該路線的BusRouteDTO() &#123; //arrange //透過NSubstitute跟它說你想Mock實作的Interface var NsubRestSharpMock = Substitute.For&lt;IRestSharp&gt;(); var Sut = new PTX(NsubRestSharpMock); //注入 //期望API回傳的Json var sb = new System.Text.StringBuilder(12766); sb.AppendLine(@&quot;[&#123;&quot;&quot;RouteUID&quot;&quot;:&quot;&quot;TPE16111&quot;&quot;,&quot;&quot;RouteID&quot;&quot;:&quot;&quot;16111&quot;&quot;,&quot;&quot;RouteName&quot;&quot;:...後略&quot;); //這邊的意思是,當這個透過NSubstitute Mock的物件 //被呼叫Get的方法時,且帶入的參數是我們這邊寫的字串 //就回傳Returns那裡面我們設定的字串 NsubRestSharpMock.Get(&quot;http://ptx.transportdata.tw/MOTC/v2/Bus/StopOfRoute/City/Taipei/307?%24top=1&amp;%24format=JSON&quot;) .Returns(sb.ToString()); var City = &quot;Taipei&quot;; var RouteName = &quot;307&quot;; var expected = &quot;307&quot;; //act var actual = Sut.Get(City, RouteName); //assert Assert.AreEqual(actual.Name, expected); &#125; &#125; 因為NSubstitute Mock出來實作IRestSharp的物件也會有Get的方法，他還可以設定帶入參數為何才回傳值，如果比對的Url不符合預期，則就會回傳String的預設值Null，是不是超方便的！！ 當然如果你的方法是要回傳物件，一樣往Returns擺進去就對了，且它驗證參數的方法還有很多種而且很彈性，例如帶入如果是數字，你可以說大於100才回傳結果之類的，因為太多有需要的話還是直接參考他的文件比較快。 那今天的部分就談到這邊，能幫助我們做到Mock的套件還有很多，這邊只是其中一種我使用的而已，不一定要一樣，但只要了解原來Mock是這麼回事即可。","categories":[{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】Day 3 - 專注於邏輯，隔離與外部的關聯","slug":"【Unit-Test】Day-3-專注於邏輯，隔離與外部的關聯","date":"2017-04-19T07:59:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2017/04/19/【Unit-Test】Day-3-專注於邏輯，隔離與外部的關聯/","link":"","permalink":"https://toyo0103.github.io/2017/04/19/%E3%80%90Unit-Test%E3%80%91Day-3-%E5%B0%88%E6%B3%A8%E6%96%BC%E9%82%8F%E8%BC%AF%EF%BC%8C%E9%9A%94%E9%9B%A2%E8%88%87%E5%A4%96%E9%83%A8%E7%9A%84%E9%97%9C%E8%81%AF/","excerpt":"","text":"Demo檔案 : Git傳送門 昨天有提到對於外部有關聯時該如何寫單元測試，例如API就是一個典型的例子，當在沒有網路環境時，對於要拿到API的結果做後續處理，這時候該怎麼辦？今天要來實作並且落實昨天提到的重要特性 單元測試應該是隨時隨地都要能正確執行，只要它本身的邏輯是正確的！！ ****來看看今天的情境範例我們有一個需求，它要能夠讓我們帶入台北市的公車路線名稱，並取回該路線的站點資料，該資料來源從公共運輸整合資訊流通服務平台的API取得。 測試API : http://ptx.transportdata.tw/MOTC/v2/Bus/StopOfRoute/City/Taipei/307?$top=1&amp;$format=JSON 從呼叫API看到的呼叫結果大致如下 開始寫程式首先我們準備了一個主控台專案，裡面有一個PTX的Class，希望他有個方法能帶入縣市、公車路線名稱，然後回傳該路線所有站牌名稱與ID 1234567891011121314151617181920212223242526272829/// &lt;summary&gt; /// 巴士路線(該方法要回傳的結果) /// &lt;/summary&gt; public class BusRouteDTO &#123; /// &lt;summary&gt; /// 路線名稱 /// &lt;/summary&gt; public string Name &#123; get; set; &#125; /// &lt;summary&gt; /// 巴士站列表 /// &lt;/summary&gt; public List&lt;BusStop&gt; BusStops &#123; get; set; &#125; /// &lt;summary&gt; /// 巴士站 /// &lt;/summary&gt; public class BusStop &#123; /// &lt;summary&gt; /// 站名 /// &lt;/summary&gt; public string Name &#123; get; set; &#125; public string ID &#123; get; set; &#125; &#125; &#125; 用來承接API回傳資料的DTO 1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt; /// 取PTX BusRoute的結果 /// &lt;/summary&gt; public class PTXBusRouteResult &#123; public NameDTO RouteName &#123; get; set; &#125; public List&lt;StopDTO&gt; Stops &#123; get; set; &#125; /// &lt;summary&gt; /// 巴士路線名稱 /// &lt;/summary&gt; public class NameDTO &#123; public string Zh_tw &#123; get; set; &#125; public string En &#123; get; set; &#125; &#125; /// &lt;summary&gt; /// 站點 /// &lt;/summary&gt; public class StopDTO &#123; /// &lt;summary&gt; /// 站點ID /// &lt;/summary&gt; public string StopUID &#123; get; set; &#125; /// &lt;summary&gt; /// 站點名稱 /// &lt;/summary&gt; public NameDTO StopName &#123; get; set; &#125; public class NameDTO &#123; public string Zh_tw &#123; get; set; &#125; public string En &#123; get; set; &#125; &#125; &#125; &#125; PTX的程式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class PTX &#123; /// &lt;summary&gt; /// 取得巴士路線資料 /// &lt;/summary&gt; /// &lt;param name=&quot;city&quot;&gt;縣市名稱&lt;/param&gt; /// &lt;param name=&quot;routeName&quot;&gt;巴士路線名稱&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public BusRouteDTO Get(string city,string routeName) &#123; BusRouteDTO Result = null; //Use RestSharp Call API var client = new RestClient($&quot;http://ptx.transportdata.tw/MOTC/v2/Bus/StopOfRoute/City/&#123;city&#125;/&#123;routeName&#125;?%24top=1&amp;%24format=JSON&quot;); var request = new RestRequest(Method.GET); request.AddHeader(&quot;cache-control&quot;, &quot;no-cache&quot;); IRestResponse response = client.Execute(request); if (response.StatusCode == HttpStatusCode.OK) &#123; var APIResult = JsonConvert.DeserializeObject&lt;List&lt;PTXBusRouteResult&gt;&gt;(response.Content); if (APIResult != null &amp;&amp; APIResult.Count &gt; 0) &#123; var Route = APIResult.First(); Result = new BusRouteDTO &#123; Name = Route.RouteName.Zh_tw, BusStops = new List&lt;BusRouteDTO.BusStop&gt;() &#125;; foreach (var stop in Route.Stops) &#123; Result.BusStops.Add(new BusRouteDTO.BusStop &#123; ID = stop.StopUID, Name = stop.StopName.Zh_tw &#125;); &#125; &#125; &#125; return Result; &#125; &#125; 這邊呼叫API用的套件為RestSharp 將回傳的Json格式轉成DTO的套件是Newtonsoft.Json OK，因為是範例程式，所以一些寫作風格或是是否會Null的問題我們就先擺一邊吧，還是專注在我們的怎麼寫單元測試上。 接著我們來執行看看程式是否依照我們預期的可以取回結果 1234567891011121314class Program &#123; static void Main(string[] args) &#123; var PTXFunction = new PTX(); var Result = PTXFunction.Get(&quot;Taipei&quot;,&quot;307&quot;); Console.Write(JsonConvert.SerializeObject(Result)); Console.ReadKey(); &#125; &#125; 程式正確執行也取得回資料，第一階段搞定！！接下來開始寫單元測試了 單元測試首先替它加上單元測試吧，老樣子在PTX的Get方法右鍵 &gt; 建立單元測試 寫單元測試，這邊稍微解釋一下，因為還沒說怎麼驗證整個Class的內容比對，所以這邊先驗證回傳結果名稱就好，之後的章節會講怎麼驗證整個回傳內容的數值 1234567891011121314151617181920[TestClass()] public class PTXTests &#123; [TestMethod()] public void GetTest_傳入縣市和公車路線名稱_如果查的到資料_應回傳該路線的BusRouteDTO() &#123; //arrange var Sut = new PTX(); var City = &quot;Taipei&quot;; var RouteName = &quot;307&quot;; var expected = &quot;307&quot;; //act var actual = Sut.Get(City, RouteName); //assert Assert.AreEqual(actual.Name, expected); &#125; &#125; 執行看看，得到正確的結果！！ 但這邊我們都知道，如果今天網路斷掉或是對方API暫時提供服務，則我們的單元測試就會壞掉，因為他呼叫不到真實的API，而這其實違反我們之前說的「單元測試應該關注的是它的邏輯，而非外部的關聯」。如果今天因為環境就出錯，單元測試一多，可能我們常常都要花很多時間去找目前狀況是什麼，更可能的是查到最後才發現原來你的程式沒錯…. 所以回頭看看我們的PTX程式，它的外部關聯是什麼？它關注的邏輯又是什麼？ PTX.Get程式目前內部的邏輯如下1.將帶入的參數組成API Url並進行呼叫2.將取回的Json轉成DTO3.判斷回傳的DTO是否有值？有則轉成我們要的結果回傳3.1 否則直接回傳Null 從這邊我會把它拆成1.呼叫外部API為外部行為，因為如果今天網路斷掉或是對方API壞掉、甚至是對方的API還沒開發好，理論上都不是我們程式的問題，而是網路或是對方要依照規格來處理。 所以第一步是我們要把外部行為隔離出去，並且想辦法讓我們可以模擬它而不是真正去呼叫線上的API，當然這邊做法有很多種，我選擇將Call API的行為還是視為PTX這個物件的內部行為，所以沒有獨立到別的Class去處理，而是封裝起來 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PTX &#123; /// &lt;summary&gt; /// 取得巴士路線資料 /// &lt;/summary&gt; /// &lt;param name=&quot;city&quot;&gt;縣市名稱&lt;/param&gt; /// &lt;param name=&quot;routeName&quot;&gt;巴士路線名稱&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public BusRouteDTO Get(string city,string routeName) &#123; BusRouteDTO Result = null; var JsonResult = CallAPI(city, routeName); if (!string.IsNullOrEmpty(JsonResult)) &#123; var APIResult = JsonConvert.DeserializeObject&lt;List&lt;PTXBusRouteResult&gt;&gt;(JsonResult); if (APIResult != null &amp;&amp; APIResult.Count &gt; 0) &#123; var Route = APIResult.First(); Result = new BusRouteDTO &#123; Name = Route.RouteName.Zh_tw, BusStops = new List&lt;BusRouteDTO.BusStop&gt;() &#125;; foreach (var stop in Route.Stops) &#123; Result.BusStops.Add(new BusRouteDTO.BusStop &#123; ID = stop.StopUID, Name = stop.StopName.Zh_tw &#125;); &#125; &#125; &#125; return Result; &#125; /// &lt;summary&gt; /// Call API /// &lt;/summary&gt; /// &lt;param name=&quot;city&quot;&gt;縣市&lt;/param&gt; /// &lt;param name=&quot;routeName&quot;&gt;巴士路線名稱&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private string CallAPI(string city, string routeName) &#123; //Use RestSharp Call API var client = new RestClient($&quot;http://ptx.transportdata.tw/MOTC/v2/Bus/StopOfRoute/City/&#123;city&#125;/&#123;routeName&#125;?%24top=1&amp;%24format=JSON&quot;); var request = new RestRequest(Method.GET); request.AddHeader(&quot;cache-control&quot;, &quot;no-cache&quot;); IRestResponse response = client.Execute(request); if (response.StatusCode == HttpStatusCode.OK) &#123; return response.Content; &#125; return string.Empty; &#125; &#125; 這樣就達到分離了Call API這個外部行為，但是接下來的問題是我們該如何模擬CallAPI的行為，因為目前的程式還是會去呼叫外部API。 讓我們把CallAPI從private改成protect吧，並且把它改成可以virtual，讓繼承它的子類別都可以改寫它 接著我們在單元測試專案中，然後開一個PTXStub的Class來繼承它並賦予他特殊屬性能改寫CallAPI的內部行為 這邊提到Stub，在單元測試中還有一種叫做Ｍock，詳情定義跟討論可以參考stackoverflow - What’s the difference between a mock &amp; stub? 1234567891011121314151617public class PTXStub :PTX &#123; /// &lt;summary&gt; /// 用來模擬API回傳的Json Result /// &lt;/summary&gt; public string CallAPIResult; protected override string CallAPI(string city, string routeName) &#123; if (!string.IsNullOrEmpty(CallAPIResult)) &#123; return CallAPIResult; &#125; return base.CallAPI(city, routeName); &#125; &#125; 我們將CallAPIResult的方法改寫掉，讓他回傳我們對外開放出來的CallAPIResult這個屬性，此屬性可以讓我們設定API應該回傳的結果。 接下就回頭改單元測試的部分 123456789101112131415161718192021222324[TestMethod()] public void GetTest_傳入縣市和公車路線名稱_如果查的到資料_應回傳該路線的BusRouteDTO() &#123; //arrange var Sut = new PTXStub(); //改成PTXStub var City = &quot;Taipei&quot;; var RouteName = &quot;307&quot;; //API應該回傳的結果 var sb = new System.Text.StringBuilder(12766); sb.AppendLine(@&quot;[&#123;&quot;&quot;RouteUID&quot;&quot;:&quot;&quot;TPE16111&quot;&quot;,&quot;&quot;RouteID&quot;&quot;:&quot;&quot;16111&quot;&quot;,&quot;&quot;RouteName&quot;&quot;:&#123;&quot;&quot;Zh_tw&quot;&quot;:&quot;&quot;307&quot;&quot;,&quot;&quot;En&quot;&quot;:&quot;&quot;307&quot;&quot;&#125;,&quot;&quot;KeyPattern&quot;&quot;:false,&quot;&quot;SubRouteUID&quot;&quot;:&quot;&quot;TPE157462&quot;&quot;,&quot;&quot;SubRouteID&quot;&quot;:&quot;&quot;157462&quot;&quot;,&quot;&quot;SubRouteName&quot;&quot;:&#123;&quot;&quot;Zh_tw&quot;&quot;:&quot;&quot;307莒光經板橋前站&quot;&quot;,&quot;&quot;En&quot;&quot;:&quot;&quot;307&quot;&quot;&#125;,&quot;&quot;Direction&quot;&quot;:0,&quot;&quot;Stops&quot;&quot;:[&#123;&quot;&quot;StopUID&quot;&quot;:&quot;&quot;TPE15294&quot;&quot;,&quot;&quot;StopID&quot;&quot;:&quot;&quot;15294&quot;&quot;,&quot;&quot;StopName&quot;&quot;:&#123;&quot;&quot;Zh_tw&quot;&quot;:&quot;&quot;莊敬里&quot;&quot;,]............&quot;); //設定CallAPI回傳結果 Sut.CallAPIResult = sb.ToString(); var expected = &quot;307&quot;; //act var actual = Sut.Get(City, RouteName); //assert Assert.AreEqual(actual.Name, expected); &#125; &#125; API應該回傳的結果那邊因為太長，所以省略部分回傳結果，但在實際程式是完整貼上，詳請看Git的Source Code。 這樣就可以模擬CallAPI這個跟外部連結的結果，但依然可以測試我們所關注的邏輯，是否可卻轉成我們要的結果，執行後可以發現單元測試還是顯示綠燈的正確無誤。 但這個方法也不是百分之百沒有缺點，你應該也可以觀察到其中一段在這單元測試中無法被涵蓋到，那就是組API Url那段，在這種透過繼承解耦合的方式中，因為回傳結果是自己設定的，實際上組成的URL正確與否我們並不知道，換句話說，如果我們今天這樣寫測試可能會過，但上線後才會發現錯誤，檢查之下發現原來是在串Url的時候錯字之類的。 這是這種測試方法的缺點，但今天就先談到這邊，還有別種方法可以解決這個問題，只是通常有一好沒兩好，各自都會有優缺點，就看實際專案情形自行判斷跟取捨了。","categories":[{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】Day 2 - 如何寫一個好的單元測試","slug":"【Unit-Test】Day-2-如何寫一個好的單元測試","date":"2017-04-18T09:52:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2017/04/18/【Unit-Test】Day-2-如何寫一個好的單元測試/","link":"","permalink":"https://toyo0103.github.io/2017/04/18/%E3%80%90Unit-Test%E3%80%91Day-2-%E5%A6%82%E4%BD%95%E5%AF%AB%E4%B8%80%E5%80%8B%E5%A5%BD%E7%9A%84%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/","excerpt":"","text":"接著來討論一下單元測試究竟該怎麼寫，你可能也會有這樣的疑問，如果今天我的程式是要呼叫資料庫來取得資料，那是否真要接上一個資料庫去做單元測試呢？又公司的資料庫如果對外是連不到的，悲苦的工程師回家怎麼做單元測試呢？ 那如果是外部API呢？網路不通時單元測試是不是就都壞掉了？ 那該怎麼知道現在單元測試是真正的邏輯錯誤還是只是因為網路或是資料庫連不上導致的錯誤？是不是寫了單元測試後反而我要花大量的時間常常在檢查到底現在是錯哪邊啊…..。 其實我剛開始接觸單元測試的時候上面的問題也都想過一輪，但這也點出了單元測試一個很重要的特性 單元測試應該是隨時隨地都要能正確執行，只要它本身的邏輯是正確的！！ 看完這句話你可能會默默響起ＯＳ，「阿鬼，你還是說中文吧～」。不過這段容我之後另外篇幅再做詳盡的解說，現在只要有這樣的觀念就好，單元測試不應該隨著你在的環境不同而有結果的落差，他關注的是邏輯而不是與外部的關聯。****那好，假設我們做到了單元測試跟外部的關聯都斷開了，只專注在自己的邏輯上，這樣就稱得上是好的單元測試了嗎？ 當然不是！ 單元測試的命名也是一個很重要的課題 單元測試的標題需要具備好的可讀性、明確、標題與測試的內容精確吻合 還記得上一篇文章提到，撰寫良好的單元測試應該像是規格書一般，不僅要讓專案品質提高，更是要充當新接觸專案人員能透過閱讀單元測試對程式有基本認識的工具。 舉例來說：有一個單元測試標題這樣寫「public void GetTest_呼叫得到True()」，對於一個不看單元測試內容的人來說，這個標題一點意義都沒有，首先他不知道這個方法裡面是在幹嘛的，再來他究竟會做什麼事情導致他得到True，帶入的參數意義是什麼…等，這樣的單元測試反而是造成專案難以維護的幫兇。 所以比較好的單元測試標題應該詳盡，例：「public void GetTest_帶入會員ID＿應回該ID搜尋到的會員資料DTO」，盡量符合 受測方法＿傳入參數意義＿期望得到的結果 比起第一種命名方式是否明確易懂多了。 你可能又會冒出一個問題，如果這個方法帶進的ID查不到會員時，我會回傳Null，但怎麼在一個單元測試表示？這邊點出另一個重點 一個測試只應該關注一件事情，如果受測目標有多種狀況，應該分成好幾個測試去涵蓋所有邏輯 順著上面的邏輯，這個方法應該就會有另一個測試為「public void GetTest_帶入會員ID＿如搜尋不到該ID的會員＿回傳Null」。 所以如果一個方法裡面的IF ELSE很多，導致程式邏輯複雜度提高，則單元測試可能就會有對應的很多方法來涵蓋所有可能，所以如果有寫單元測試，則職責分離就是一個重要的課題，如果你把很多職責都放在同一段程式中，你的單元測試可能是倍數成長之外，測試也會變得很難撰寫。 從上面的舉例也可以看出，每個單元測試都只關注一種邏輯，一個方法難免包含多種邏輯狀況，但當修改程式時如果單元測試錯誤，也能幫助你快速鎖定可能是哪一段邏輯錯了，減少除錯的時間。再者，因為每個單元測試名稱都很明確，執行的方法帶入的參數也都明確的情況下，讓人閱讀時可以很容易進入狀況，符合一開始提到的可以執行的規格書，對專案是非常有幫助的。 接著來探討單元測試的內文該如何撰寫，首先應該符合所謂的3A原則 Arrange = 準備受測物件、參數、預期結果Act = 執行受測方法Assert = 驗證執行結果與預測結果是否一致 拿昨天的單元測試來說明 1234567891011121314[TestMethod()] public void Method1Test_呼叫時應回傳結果為7() &#123; //arrange var Sut = new EasyMethod(); var expected = 7; //act var actual = Sut.Method1(); //assert Assert.AreEqual(expected, actual); &#125; Arrange中Sut(System Under Test&nbsp;),受測的目標為EasyMethod這跟Class,而這個單元測試預期的結果為7。 Act中actual是EasyMethod執行Method1這個方法得到的結果。 Assert中用MsTest提供的Assert.AreEqual方法驗證得到的結果與預期的結果是否一致。 如果每個單元測試都照著這樣的風格撰寫，則對於閱讀的人來說會很清楚歸類出每個區段各自的職責。 那今天就談到這邊，之後應該就會有比較多的實作了(擦汗)","categories":[{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】Day 1 - 為何要寫單元測試","slug":"【Unit-Test】Day-1-為何要寫單元測試","date":"2017-04-17T03:55:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2017/04/17/【Unit-Test】Day-1-為何要寫單元測試/","link":"","permalink":"https://toyo0103.github.io/2017/04/17/%E3%80%90Unit-Test%E3%80%91Day-1-%E7%82%BA%E4%BD%95%E8%A6%81%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/","excerpt":"","text":"Demo檔案 : Git傳送門 算一算開始寫單元測試也快兩年了，很感謝當時能有機會得到前輩的指導並接觸到這個技術，在實際運用到開發上面時，也真正的感受到它的好，為了將單元測試這好東西分享給更多人知道，所以有了寫這系列文章的想法。 這系列文章是希望在讀者讀完後，能讓你從一位不會寫單元測試的開發者，粗略的搞懂單元測試為何、如何撰寫、並且能透過實作中體會到它如何幫助專案更加穩固。 我不是什麼技術大牛，如果發現文章有疏漏的地方，還請不吝指正指導。 感謝!! 為何我要寫單元測試不知你可曾遇過這樣的狀況…. 情境一 :接手了一個很舊的系統維護，關於規格與文件皆已不可考，連開發過的工程師們都已離職不幹了，現在PM跟你說他想改一個功能，並拍拍你肩說「這個很簡單，一下下就好」。而你卻不知道該從何下手….__單元測試能幫你做什麼? 優良的單元測試就像活著的規格書，不僅能幫助你了解那些不是你負責的功能，更是能夠執行的規格書 情境二:是否曾經改發生過改好新功能，但舊功能就壞掉，修好舊功能，新功能又壞掉了呢?&nbsp; 假設下圖就是你的功能，而你希望它三個能同時選取時.... 單元測試能幫你做什麼? 它能告訴你目前的程式，是否執行都符合當時所要求的規格與產出結果，如果舊規格舊方法沒有改的情況下，單元測試壞了，那就表示你這次的改動絕對有影響到它，趕緊去修好它吧!! 情境三 :一個你覺得很簡單的功能，直到你上線才發現原來功能是錯的無法正常執行，偵錯下去才發現，天殺的，原來是自己觀念上錯誤或不熟悉。例如Double&nbsp;a&nbsp; = 1.1加上Double b&nbsp;=&nbsp;1.2，而你以為它的結果會是2.3....&nbsp; _ __單元測試能幫你做什麼?_ 它能即時的驗證你的想法，而不是到上線時才賭人品，尤其是那些你覺得理所當然會對的功能中，魔鬼往往藏在細節裡 在你還沒寫單元測試之前，上述狀況是否都似曾相識呢?如果你想解決這些問題，那麼開始寫單元測試將是可以大幅度降低這些錯誤的有效方法，而且你一定會愛上它。 該如何開始寫單元測試接著我們就來用實際案例重現上面提到了一些問題，並且透過撰寫單元測試來看看它如何幫我們避免這些狀況。 首先準備一個類別庫專案******寫下一段簡單的程式，而這段程式很簡單，就只是把基數加上2回傳回去即可 ****** 12345678910public class EasyMethod&#123; private int BaseNumber = 5; public int Method1() &#123; return BaseNumber + 2; &#125; &#125; 而這段程式真的非常簡單，簡單到你一看就覺得它回傳是7，不過沒關係我們繼續完成單元測試，看它能幫助我們什麼 接著建立單元測試專案 在Method1的的方案下右鍵 &gt; 建立單元測試 如果你是用VS2017，可能會發現沒有建立單元測試這個選項，請將VS更新到最新版就有了 接著就會看到單元測試專案已經幫你建立完成 讓我們來寫下第一個完整的單元測試，將那個自動建立的單元測試改成 1234567891011121314[TestMethod()] public void Method1Test_呼叫時應回傳結果為7() &#123; //arrange var Sut = new EasyMethod(); var expected = 7; //act var actual = Sut.Method1(); //assert Assert.AreEqual(expected, actual); &#125; 稍微檢視一下這個單元測試能帶給我們什麼？首先從標題上我們可以知道這個方法的目的跟應得到的結果，接著我們可以從單元測試的程式碼中看出這個方法該如何使用。 接著我們在測試總管中執行單元測試，知道目前這個方法符合我們需求跟得到預期的結果 當我們面臨需求的更改…..接著我們知道日常狀況是，需求總是一直的在擴充及變動，所以我們有了一個新需求 我希望能有個新的方法，並且呼叫它時能回傳給我10這個答案，而且因應業務需求，基數需要改變成2 OK!!一切聽起來都不是太難，那就讓我們直接動手下去做吧首先我先將基數改成2，並且新增一個Method2的方法，並且讓他加上基數後得到10這個結果回傳。 老方法，在Method2那邊按下右鍵 &gt; 建立單元測試，並寫上新的方法的單元測試 1234567891011121314151617181920212223242526272829303132333435namespace UnitTestDay1.Tests&#123; [TestClass()] public class EasyMethodTests &#123; [TestMethod()] public void Method1Test_呼叫時應回傳結果為7() &#123; //arrange var Sut = new EasyMethod(); var expected = 7; //act var actual = Sut.Method1(); //assert Assert.AreEqual(expected, actual); &#125; [TestMethod()] public void Method2Test_呼叫時應回傳結果為10() &#123; //arrange var Sut = new EasyMethod(); var expected = 10; //act var actual = Sut.Method2(); //assert Assert.AreEqual(expected, actual); &#125; &#125;&#125; 一切完美直到你執行單元測試時你會發現，原本的Method1壞掉啦！！ 原來因為我們更改了基數所以造成了Method1回傳時不符合當時所制定的規格，這時候我們如果確定原需求沒有變動的情況下，那就是去修改原本的方法讓它能通過單元測試。這樣新舊需求就都確保正確的情況下更正完成了。 今日小結從這個範例中我們可以整理出一些單元測試所能帶來的好處。 首先，因為在撰寫程式時，我們會在當下寫上單元測試，並且讓它通過，日後不管任何原因它壞掉了，我們都能從標題中或是案例來知道當時的需求與狀況，形成上面提到的所謂活著可執行的規格書，（當然前提是你的標題跟內容要寫得乾淨易懂，否則維護單元測試可能又是另一場災難），即便規格書遺失或是人員異動，對於程式本身的維護都有一定品質的保障。 接著是需求異動，雖然這個範例舉例的有點極端，但我只是想表達一種狀況，常常我們在改動共用方法或是核心功能時，往往不知道這樣改可能會造成哪邊的錯誤，甚至是編譯執行都是正常，但其實違反了當時所定義的程式或商業邏輯，而這往往是要上線的時候才會發現，但從這案例中，基數被改變時，雖然把Mehod2順利地完成的，但我們卻忽略了Method1可能導致它變動進而產生錯誤，有了單元測試或是整合測試，這樣的狀況可以有效地減少跟被控管（特別強調：非百分之百！！所以整合測試跟單元測試都一樣很重要，如果可以，兩個都做會是最好的選擇） 好的，希望第一篇文章可以淺顯易懂的讓大家感受單元測試的好處！！","categories":[{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【FluentValidation】與MVC 5綁定Model Validation","slug":"【FluentValidation】與MVC-5綁定Model-Validation","date":"2017-03-29T03:12:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2017/03/29/【FluentValidation】與MVC-5綁定Model-Validation/","link":"","permalink":"https://toyo0103.github.io/2017/03/29/%E3%80%90FluentValidation%E3%80%91%E8%88%87MVC-5%E7%B6%81%E5%AE%9AModel-Validation/","excerpt":"","text":"MVC很早就提供Model Validation的驗證方式，只要在Parameter Class的Property加上限制 123456789101112131415public class Movie &#123; [Required] public int ID &#123; get; set; &#125; [DataType(DataType.Date)] public DateTime ReleaseDate &#123; get; set; &#125; [Range(1, 100)] [DataType(DataType.Currency)] public decimal Price &#123; get; set; &#125; [StringLength(5)] public string Rating &#123; get; set; &#125;&#125; 接著在Action之中使用ModelState.IsValid即可驗證參數是否符合規定 12345678910111213[HttpPost]public ActionResult Create(Movie movie)&#123; if (ModelState.IsValid) &#123; db.Movies.Add(movie); db.SaveChanges(); return RedirectToAction(&quot;Index&quot;); &#125; return View(movie);&#125; 最近比較習慣使用FluentValidation，剛好它也在MVC5上設定一下，就可以用ModelState.IsValid來得知參數驗證是否成功，以下紀錄實作方法 1.首先在MVC專案中安裝FluentValidation.MVC5 [![](https://2.bp.blogspot.com/-OYlSu6hpFFQ/WNsigw1fSyI/AAAAAAAAIF4/pO02UtoeK5g1ipJT0T6Z6JLb_8a5PkjCwCLcB/s1600/1.png)](https://2.bp.blogspot.com/-OYlSu6hpFFQ/WNsigw1fSyI/AAAAAAAAIF4/pO02UtoeK5g1ipJT0T6Z6JLb_8a5PkjCwCLcB/s1600/1.png) 2.接著在Global &nbsp;Application_Start加上 12FluentValidationModelValidatorProvider.Configure(); 3.準備一個要驗證的參數類別 1234567public class WantValidateParameter&#123; public string ID &#123; get; set; &#125; public string Name &#123; get; set; &#125;&#125; 4.跟前幾天提到的文章一樣，寫對應的驗證方法 12345678910111213141516171819202122232425public class ParameterValidator :AbstractValidator&lt;WantValidateParameter&gt;&#123; public ParameterValidator() &#123; this.RuleFor(x =&gt; x.ID) .NotNull() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;ID不能為Null&quot;) .NotEmpty() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;ID不能為空字串&quot;); this.RuleFor(x =&gt; x.Name) .NotNull() .WithErrorCode(&quot;401&quot;) .WithMessage(&quot;Name不能為Null&quot;) .NotEmpty() .WithErrorCode(&quot;401&quot;) .WithMessage(&quot;Name不能為空字串&quot;) .Length(4, 6) .WithErrorCode(&quot;401&quot;) .WithMessage(&quot;Name必須在4~6字之間&quot;); &#125;&#125; 5.接著在剛剛要驗證的參數類別上加上Attribute 12345678[Validator(typeof(ParameterValidator))] public class WantValidateParameter &#123; public string ID &#123; get; set; &#125; public string Name &#123; get; set; &#125; &#125; 6.在Action裡面就可以用ModelState.IsValid來得知參數是否驗證成功啦!! 1234567891011121314151617public ActionResult Test(WantValidateParameter parameter) &#123; string Result = string.Empty; if (!ModelState.IsValid) &#123; //取得錯誤的訊息 var Error = ModelState.Values.SelectMany(x =&gt; x.Errors).FirstOrDefault(); Result = Error.ErrorMessage; &#125; else &#123; Result = &quot;驗證成功&quot;; &#125; return View(model: Result); &#125; 參考文章 :1.https://github.com/JeremySkinner/FluentValidation/wiki/h.-MVC2.MSDN :&nbsp;Adding Validation to the Model","categories":[],"tags":[{"name":"FluentValidation","slug":"FluentValidation","permalink":"https://toyo0103.github.io/tags/FluentValidation/"}]},{"title":"如何設定檔案、資料夾匿名驗證存取權限","slug":"如何設定檔案、資料夾匿名驗證存取權限","date":"2017-03-22T03:43:00.000Z","updated":"2022-08-09T13:36:17.097Z","comments":true,"path":"2017/03/22/如何設定檔案、資料夾匿名驗證存取權限/","link":"","permalink":"https://toyo0103.github.io/2017/03/22/%E5%A6%82%E4%BD%95%E8%A8%AD%E5%AE%9A%E6%AA%94%E6%A1%88%E3%80%81%E8%B3%87%E6%96%99%E5%A4%BE%E5%8C%BF%E5%90%8D%E9%A9%97%E8%AD%89%E5%AD%98%E5%8F%96%E6%AC%8A%E9%99%90/","excerpt":"","text":"每次討論到windows或是IIS權限都是我的弱項，碰到這類問題總是要搞個老半天，所以處理完趕緊來記錄一下!! 情境 :同事希望某個資料夾下的Json檔案都不能被外部存取，但唯獨某一支有資訊安全問題，想要排除 解決方案:一開始單純的想說透過IIS的驗證設定將該資料夾的匿名驗證停用，但這樣就變成所有在該資料夾底下的檔案都讀取不到了。[![](https://2.bp.blogspot.com/-RnKuPAsgeo4/WNHuiKDxc5I/AAAAAAAAIFo/iW3Vy1dIanMIQnrg8fN8Bey6ieywbJX8ACLcB/s640/1.png)](https://2.bp.blogspot.com/-RnKuPAsgeo4/WNHuiKDxc5I/AAAAAAAAIFo/iW3Vy1dIanMIQnrg8fN8Bey6ieywbJX8ACLcB/s1600/1.png) 最後查了一下後，採取透過Web.config設定的方式來達成!! 首先在Web.config的system.webServer區段接入以下區段 ```xml 12345678910111213141516172. 接著在想要權限控管的那個資料夾底下加入一個新的web.config，並且寫入以下區段 &#96;&#96;&#96;xml&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;configuration&gt; &lt;system.web&gt; &lt;authorization&gt; &lt;deny users&#x3D;&quot;?&quot; &#x2F;&gt; &lt;&#x2F;authorization&gt; &lt;&#x2F;system.web&gt; &lt;location path&#x3D;&quot;xxx.json&quot;&gt; &lt;system.web&gt; &lt;authorization&gt; &lt;allow users&#x3D;&quot;?&quot; &#x2F;&gt; &lt;&#x2F;authorization&gt; &lt;&#x2F;system.web&gt; &lt;&#x2F;location&gt;&lt;&#x2F;configuration&gt; 這邊稍微解釋一下意思，首先authorization區段底下寫著deny user=”?”，表示匿名驗證的使用者都無法存取。 接著location path這段是表示，xxx.json，他的權限是可以允許(allow)匿名驗證者個存取。&amp;nbsp;&lt;/div&gt;&lt;div&gt; 這樣設定完後進行測試，的確該資料夾底下的所以檔案都會無法直接讀取，並且跳出401權限驗證錯誤，而xxx.json雖然在同資料夾下，但卻是可以直接讀取檔案的 因為關於權限設定真的是肉腳一枚，如果有寫錯或觀念偏誤的地方，也歡迎留言指正教導，感激不盡!!!","categories":[],"tags":[]},{"title":"【生產力】SmartPaster","slug":"【生產力】SmartPaster","date":"2017-03-13T02:20:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2017/03/13/【生產力】SmartPaster/","link":"","permalink":"https://toyo0103.github.io/2017/03/13/%E3%80%90%E7%94%9F%E7%94%A2%E5%8A%9B%E3%80%91SmartPaster/","excerpt":"","text":"常常我會在SSMS上面撰寫SQL語法，等到確定之後才會把他挪到專案內，這時候就會碰到要補上前後雙引號或是跳脫字元等問題，以前都會笨笨的一行一行慢慢改，直到朋友介紹我一款好藥好套件SmartPaster ** **[![](https://2.bp.blogspot.com/-z9hPIDANTMo/WMX_dl7i0HI/AAAAAAAAIFE/PS6PSdkYy4w1lh-BSUYlR608rsaAfU89wCLcB/s1600/1.png)](https://2.bp.blogspot.com/-z9hPIDANTMo/WMX_dl7i0HI/AAAAAAAAIFE/PS6PSdkYy4w1lh-BSUYlR608rsaAfU89wCLcB/s1600/1.png)** ** 下載位置 : https://marketplace.visualstudio.com/items?itemName=martinw.SmartPaster2013 它的功用是做什麼呢? 我想直接看圖就一目了然了 [![](https://4.bp.blogspot.com/-QzoRYhI2WNg/WMYAOrkP_DI/AAAAAAAAIFI/7dsnic6h8wohlRxmfLkli7y7krZfv5URACLcB/s1600/1.png)](https://4.bp.blogspot.com/-QzoRYhI2WNg/WMYAOrkP_DI/AAAAAAAAIFI/7dsnic6h8wohlRxmfLkli7y7krZfv5URACLcB/s1600/1.png) 只要你複製好任何字串，這邊以這串為例 select *from Employee 到VS裡面的時候點擊右鍵 &gt;&gt; Paste As… &gt;&gt; 選擇你要貼上的格式，登登~~~ [![](https://3.bp.blogspot.com/-Z0tq9CXFV1M/WMYBiGjJ7DI/AAAAAAAAIFU/8sWywyAkPfQRAE3w9FS-AJn7KJAyjH7cACLcB/s1600/1.png)](https://3.bp.blogspot.com/-Z0tq9CXFV1M/WMYBiGjJ7DI/AAAAAAAAIFU/8sWywyAkPfQRAE3w9FS-AJn7KJAyjH7cACLcB/s1600/1.png) 自動就會幫你補上可以執行的程式了，不用再自己前後雙引號、跳脫字元等等，搞到格式大亂啦!!!! YES","categories":[],"tags":[{"name":"生產力","slug":"生產力","permalink":"https://toyo0103.github.io/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"}]},{"title":"【UnitTest】Mock Controller Request","slug":"【UnitTest】Mock-Controller-Request","date":"2017-02-14T01:37:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2017/02/14/【UnitTest】Mock-Controller-Request/","link":"","permalink":"https://toyo0103.github.io/2017/02/14/%E3%80%90UnitTest%E3%80%91Mock-Controller-Request/","excerpt":"","text":"寫單元測試測試Controller的時候，有時候程式中會用到Controller.Request Property，但單元測試並不是真的Web連線行為，所以呼叫到Request的時候會是Null , 想要做一個假的塞給他，這個屬性卻是只能讀取不能寫入的 [![](https://2.bp.blogspot.com/-4_O_yEIRJeA/WKJdDhYR0MI/AAAAAAAAIEk/pa8aYvPcJw4jt62eTTSYrp6h-hK98eP1ACLcB/s1600/1.png)](https://2.bp.blogspot.com/-4_O_yEIRJeA/WKJdDhYR0MI/AAAAAAAAIEk/pa8aYvPcJw4jt62eTTSYrp6h-hK98eP1ACLcB/s1600/1.png) 每次寫完沒多久碰到就又會忘記，所以筆記下來方便以後查找，這邊一樣用NSubstitute套件做處理 [![](https://4.bp.blogspot.com/-dMNVp94tO1Y/WKJeLHnEa8I/AAAAAAAAIEs/7yAUVlh29F0wsXsmTjh_UcSZUdoC8MfpgCLcB/s1600/1.png)](https://4.bp.blogspot.com/-dMNVp94tO1Y/WKJeLHnEa8I/AAAAAAAAIEs/7yAUVlh29F0wsXsmTjh_UcSZUdoC8MfpgCLcB/s1600/1.png) 123456789YourController Sut = new YourController(); var request = Substitute.For&lt;HttpRequestBase&gt;(); var context = Substitute.For&lt;HttpContextBase&gt;(); request.HttpMethod.Returns(&quot;Get&quot;); context.Request.Returns(request); Sut.ControllerContext = new ControllerContext(context, new RouteData(), Sut);","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【C#】程式建立LocalDB(.mdf)與刪除","slug":"【C-】程式建立LocalDB-mdf-與刪除","date":"2017-01-23T07:21:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2017/01/23/【C-】程式建立LocalDB-mdf-與刪除/","link":"","permalink":"https://toyo0103.github.io/2017/01/23/%E3%80%90C-%E3%80%91%E7%A8%8B%E5%BC%8F%E5%BB%BA%E7%AB%8BLocalDB-mdf-%E8%88%87%E5%88%AA%E9%99%A4/","excerpt":"","text":"之前有寫如何對Repository層做單元測試【Unit Test】針對Repository做單元測試 (一)，當時是直接建立LocalDB放在專案之中，測試的時候對它執行，但因為公司導入CICD流程，這些MDF會殘留在佈署的機器上，造成資源的浪費，所以同事教了新的方法，用程式直接建立LocalDB，等到測試完畢後直接砍掉的方法。 這邊記錄一下實作方法，以利之後查找 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687private const string LocalDbMasterConnectionString = @&quot;Data Source=(LocalDB)\\MSSQLLocalDB;Initial Catalog=master;Integrated Security=True&quot;;private const string TestConnectionString = @&quot;Data Source=(LocalDB)\\MSSQLLocalDB;Initial Catalog=&#123;0&#125;;Integrated Security=True; MultipleActiveResultSets=True;AttachDBFilename=&#123;1&#125;.mdf&quot;;string DatabaseName &#123;get;set;&#125;void Main()&#123; this.DatabaseName = &quot;TestCreateDB&quot;; CreateDB();&#125;/// &lt;summary&gt;/// 建立DB/// &lt;/summary&gt;void CreateDB() &#123; //先看看有沒有相同的DB存在，如果有的話卸離並移除 this.DetachDatabase(); var fileName = this.CleanupDatabase(); using (var connection = new SqlConnection(LocalDbMasterConnectionString)) &#123; var commandText = new StringBuilder(); //Create DB的語法 commandText.AppendFormat( &quot;CREATE DATABASE &#123;0&#125; ON (NAME = N&#x27;&#123;0&#125;&#x27;, FILENAME = &#x27;&#123;1&#125;.mdf&#x27;);&quot;, this.DatabaseName, fileName); connection.Open(); var cmd = connection.CreateCommand(); cmd.CommandText = commandText.ToString(); cmd.ExecuteNonQuery(); &#125;&#125;/// &lt;summary&gt;/// Detaches the database./// &lt;/summary&gt;private void DetachDatabase()&#123; using (var connection = new SqlConnection(LocalDbMasterConnectionString)) &#123; connection.Open(); var cmd = connection.CreateCommand(); cmd.CommandText = string.Format(&quot;exec sp_detach_db &#x27;&#123;0&#125;&#x27;&quot;, this.DatabaseName); try &#123; cmd.ExecuteNonQuery(); &#125; catch &#123; Console.WriteLine(&quot;Could not detach&quot;); &#125; &#125;&#125;/// &lt;summary&gt;/// Cleanups the database./// &lt;/summary&gt;/// &lt;returns&gt;System.String.&lt;/returns&gt;private string CleanupDatabase()&#123; var fileName = string.Concat(@&quot;G:\\&quot;,this.DatabaseName); try &#123; var mdfPath = string.Concat(fileName, &quot;.mdf&quot;); var ldfPath = string.Concat(fileName, &quot;_log.ldf&quot;); var mdfExists = File.Exists(mdfPath); var ldfExists = File.Exists(ldfPath); if (mdfExists) File.Delete(mdfPath); if (ldfExists) File.Delete(ldfPath); &#125; catch &#123; Console.WriteLine(&quot;Could not delete the files (open in Visual Studio?)&quot;); &#125; return fileName;&#125; 最後就會在你寫的位置看到產生的DB了 [![](https://2.bp.blogspot.com/-zochbU5phtw/WIWuOeDVZ4I/AAAAAAAAID0/MwBAkQ4YEyQCLFLHbWnBaUiXVbtGrIseACLcB/s1600/1.png)](https://2.bp.blogspot.com/-zochbU5phtw/WIWuOeDVZ4I/AAAAAAAAID0/MwBAkQ4YEyQCLFLHbWnBaUiXVbtGrIseACLcB/s1600/1.png) 刪除首先要先在專案安裝Entity Framerok，並且補上以下的程式 1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt; /// 使用 EntityFramework 的 Database 類別 Delete 方法，確認 LocalDB 存在後再移除. /// &lt;/summary&gt; public static void DeleteLocalDb(string dbName) &#123; using (var connection = new SqlConnection( string.Format(TestConnectionString,dbName, dbName))) &#123; if (Database.Exists(connection)) &#123; try &#123; SqlConnection.ClearAllPools(); Database.Delete(connection); &#125; catch (Exception) &#123; using (SqlConnection masterConnection = new SqlConnection(LocalDbMasterConnectionString)) &#123; SqlCommand cmd = masterConnection.CreateCommand(); cmd.CommandText = string.Format( @&quot;ALTER DATABASE [&#123;0&#125;] SET SINGLE_USER WITH ROLLBACK IMMEDIATE; DROP DATABASE [&#123;0&#125;];&quot;, connection.Database); masterConnection.Open(); cmd.ExecuteNonQuery(); &#125; &#125; &#125; &#125; &#125; 接著呼叫，就可以砍掉剛剛建立出來的MDF了 123var DatabaseName = &quot;TestCreateDB&quot;;DeleteLocalDb(DatabaseName); 但有一點必須特別注意，如果你今天的專案結構跟我一樣 [![](https://3.bp.blogspot.com/-x8WxDPWuFrM/WIW661-YM_I/AAAAAAAAIEQ/kV7NxAeClFw5DllZUb6QK2QuKw25ksTKwCLcB/s1600/1.png)](https://3.bp.blogspot.com/-x8WxDPWuFrM/WIW661-YM_I/AAAAAAAAIEQ/kV7NxAeClFw5DllZUb6QK2QuKw25ksTKwCLcB/s1600/1.png) 刪除DB的程式碼寫在ControlLocalDB的專案中，並且在這個專案有安裝Entity Framework，而ConsoleApplication1只是引用ControlLocalDB專案來執行，而沒有安裝Entity Framework，那這時候 Database.Exists(connection) 會永遠回傳False，所以不會去砍掉DB，而且也不會引發Exception的錯誤，不知道算不算是EF的Bug，當時找超久的(崩潰)，所以還請特別注意這個地方，有用到這個方法的專案都要記得專EF 參考文章:1.HOW TO：使用 ADO.NET 與 Visual C# .NET 程式建立 SQL Server 資料庫2.Repository 測試使用 LocalDB - Part.2","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Regular Expression】分群與取代","slug":"【Regular-Expression】分群與取代","date":"2017-01-20T02:25:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2017/01/20/【Regular-Expression】分群與取代/","link":"","permalink":"https://toyo0103.github.io/2017/01/20/%E3%80%90Regular-Expression%E3%80%91%E5%88%86%E7%BE%A4%E8%88%87%E5%8F%96%E4%BB%A3/","excerpt":"","text":"在正規表示法中，可以將比對的資料做分群與命名，而在.Net中的語法是 (?:&lt;群組名稱&gt;) 應用方法如下 12345678string Date = &quot;2017/1/20&quot;;Regex reg = new Regex(@&quot;^(?&lt;Year&gt;\\d&#123;4&#125;)/(?&lt;Month&gt;\\d&#123;1,2&#125;)/(?&lt;Day&gt;\\d&#123;1,2&#125;)&quot;);var Match = reg.Match(Date);Console.WriteLine(string.Concat(&quot;年 :&quot;, Match.Groups[&quot;Year&quot;].Value));Console.WriteLine(string.Concat(&quot;月 :&quot;,Match.Groups[&quot;Month&quot;].Value));Console.WriteLine(string.Concat(&quot;日 :&quot;,Match.Groups[&quot;Day&quot;].Value)); 也可以用來做取代的用途 12345string Date = &quot;2017/1/20&quot;;Regex reg = new Regex(@&quot;^(\\d&#123;4&#125;)/(\\d&#123;1,2&#125;)/(\\d&#123;1,2&#125;)&quot;);Console.WriteLine(reg.Replace(Date,@&quot;$1年$2月$3日&quot;)); [![](https://4.bp.blogspot.com/-HQu1GmHFF_M/WIFzWkDPQQI/AAAAAAAAIDo/k5REjSoQ7fMeQBuCYZe7QRSQlXG0SXlFgCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://4.bp.blogspot.com/-HQu1GmHFF_M/WIFzWkDPQQI/AAAAAAAAIDo/k5REjSoQ7fMeQBuCYZe7QRSQlXG0SXlFgCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 括號()包起來的地方，正規表示法比對到時會把他當作一個群組，而其中Replace的地方寫著 $1代表第一個括號比對的東西放這邊，所以$1會變成2017，後面以此類推，就會變成2017年1月20日這種格式。 所以也可以改成這樣，變成國外表示年份的格式**$2-$3-$1**，就會變成 1-20-2017 以上筆記一下。","categories":[],"tags":[{"name":"Regular Expression","slug":"Regular-Expression","permalink":"https://toyo0103.github.io/tags/Regular-Expression/"}]},{"title":"【神奇事件】看不見的點","slug":"【神奇事件】看不見的點","date":"2017-01-11T03:18:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2017/01/11/【神奇事件】看不見的點/","link":"","permalink":"https://toyo0103.github.io/2017/01/11/%E3%80%90%E7%A5%9E%E5%A5%87%E4%BA%8B%E4%BB%B6%E3%80%91%E7%9C%8B%E4%B8%8D%E8%A6%8B%E7%9A%84%E9%BB%9E/","excerpt":"","text":"最近遇到一個Token怎麼送都錯誤的問題，找遍了程式都找不到原因出在哪，最後沒招只好把傳輸的封包都截下來，看看到底哪邊出了問題，結果發現…. “Te6g5R?” 這串部分Token看起來沒有什麼特別的，但如果你把滑鼠放到最後”的位置開始用鍵盤的往前鍵遍覽整串字，你會發現在R”中間需要按兩次才跳得過去，從封包監視器看到的結果卻是多了一個”點” [![](https://4.bp.blogspot.com/-XRCi-hr6diU/WHWjX1QA3RI/AAAAAAAAIDI/qTjeVZqBPm0M81EFKCe0Q1b_8UnOHU7dACLcB/s640/1.png)](https://4.bp.blogspot.com/-XRCi-hr6diU/WHWjX1QA3RI/AAAAAAAAIDI/qTjeVZqBPm0M81EFKCe0Q1b_8UnOHU7dACLcB/s1600/1.png)保哥有篇文章提到類似的問題 : &nbsp;[魔鬼般的細節：使用 C# 的 String.Trim() 方法刪除空白字元](http://blog.miniasp.com/post/2014/01/15/C-Sharp-String-Trim-ZWSP-Zero-width-space.aspx) 雖然我碰到的字元跟文章中碰到的不同，但應該是類似的問題，用BackSpace把那個看不到的點移除掉後，API就都正常了。 紀錄一下，提醒自己以後可能是因為這種…..奇怪的事情導致的，不要只顧著埋頭找程式Bug #更新那個看不見的點應該是 : Unicode Character ‘ZERO WIDTH SPACE’&nbsp;","categories":[],"tags":[{"name":"神奇事件","slug":"神奇事件","permalink":"https://toyo0103.github.io/tags/%E7%A5%9E%E5%A5%87%E4%BA%8B%E4%BB%B6/"}]},{"title":"【Regular Expression】正向環視、反向環視","slug":"【Regular-Expression】正向環視、反向環視","date":"2017-01-04T05:37:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2017/01/04/【Regular-Expression】正向環視、反向環視/","link":"","permalink":"https://toyo0103.github.io/2017/01/04/%E3%80%90Regular-Expression%E3%80%91%E6%AD%A3%E5%90%91%E7%92%B0%E8%A6%96%E3%80%81%E5%8F%8D%E5%90%91%E7%92%B0%E8%A6%96/","excerpt":"","text":"說正向環視、反向環視感覺有點文謅謅的而且很難懂，其實白話文就是，比對這個位置的左(反向環視)右邊(正向環視)是否符合你下的條件，舉個例子 ******註: **以下案例可以透過 https://regex101.com/ 做即時操作與測試 我想將下面中文的空格濾掉 哈 摟 你 好 嗎 ? Hello how are you? 變成這樣 哈摟你好嗎? Hello how are you? 如果要透過正規表示法比對出空格其實很簡單，只要下&nbsp;**\\s **即可，但如果這樣的話會變成這樣的結果。 哈摟你好嗎?Hellohowareyou? 因為所有的空格都被濾掉了，但其實英文跟英文單字之間的空格不能濾掉，這樣就變成無法理解的句子了，所以把我們的規則用中文表達就變成【我想濾掉空格，但該空格的左邊與右邊不能是英文字母】 這時候正向環視與反性環視就派上用場了 名稱正規表示法解釋正向環視(?=)這位置右邊要出現什麼反向環視(?&lt;=)這位置左邊要出現什麼正向環視否定(?!)這位置右邊不能出現什麼反向環視否定(?&lt;!)這位置左邊不能出現什麼 所以剛剛的表達方法應該改成 **(?&lt;![a-zA-Z])\\s****(?![a-zA-Z])**&nbsp;，其中**(?&lt;![a-zA-Z])**表示空格的左邊不能出現英文字母，**(?![a-zA-Z])**&nbsp;表示空格右邊的不能出現英文字母，只有這樣的空格才符合我們要求的，把他過濾掉，結果就會變成我們要的結果了 最後還有一個讀到的案例覺得也很實用，常常我們會需要在金錢上加上【，】來方便理解位數，例如 123,123,123 所以當我們拿到123456時，該怎麼把逗號加上去? 用中文表達就是，【我希望這個位置的右邊如果有三個數字，就幫我加上逗號】，所以寫出了**(?=\\d{3})**，結果就變成了這樣 ,1,2,3,456 看起來怪怪的，但其實符合我們下的判斷式，因為1、2、3右邊都可以數到三個數字，所以補上逗號合理，更精確我們的描述成【我希望這個位置的右邊有三個數字為一組，且比對到右邊不是數字為止，幫我加上逗號】，判斷式變成這樣**(?=(\\d{3})+(?!\\d))，其中三個數字一組的表達式(\\d{3})+，且比對到右邊不是數字為止(?!\\d)**，結果變成如下 ,123,456 的確三個數字一組的補上逗號，但是最一開頭那邊不應該有逗號，所以應該加上一串描述【且左邊要是數字時，才補上逗號】，所以最後結果就變成**(?=(\\d{3})+(?!\\d))(?&lt;=\\d)**，而且切出來也就會剛剛好的 123,456","categories":[],"tags":[{"name":"Regular Expression","slug":"Regular-Expression","permalink":"https://toyo0103.github.io/tags/Regular-Expression/"}]},{"title":"【EntityFramework】DBContext Dispose與否，與DB的連線數是否有關係","slug":"【EntityFramework】DBContext-Dispose與否，與DB的連線數是否有關係","date":"2016-12-19T07:31:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2016/12/19/【EntityFramework】DBContext-Dispose與否，與DB的連線數是否有關係/","link":"","permalink":"https://toyo0103.github.io/2016/12/19/%E3%80%90EntityFramework%E3%80%91DBContext-Dispose%E8%88%87%E5%90%A6%EF%BC%8C%E8%88%87DB%E7%9A%84%E9%80%A3%E7%B7%9A%E6%95%B8%E6%98%AF%E5%90%A6%E6%9C%89%E9%97%9C%E4%BF%82/","excerpt":"","text":"案情簡介: 手邊有一個中大型專案，最近Web版上線後，時不時會收到資料庫連線異常相關錯誤，不定時不定量，沒有特定會掛在哪支API，完全沒有邏輯可以歸納。 該Database Layer的ORM使用Entity Framwork(後面簡稱 EF)做為與DB溝通的橋樑，DBContext採用Singleton的方式，每個Request進來，不管跟DB溝通幾次都只會建造一次Context實體，Request結束後Dispose掉。 心中的想像:以前寫ADO.NET自己控制連線，都聽前輩說一定要自己Close連線，不然很可能會把連線的Pool占滿，所以寫EF時習慣也都會加上Using 123456using (var DbContext = new NorthwindEntities())&#123; //Do Something&#125; 而且自己覺得每次Dispose應該都會關閉該次連線，註1每次New Context都會建立新的連線，一切井然有序好不快樂，直到這個短時間會有大量的Request湧進來的服務上線後，一切都變調，時不時就會接到使用單位來詢問API不定時中斷問題，想破頭還是找不到問題在哪…. 驗證:****從外天空找到行天宮，最後發現最可能的原因是出在EF底層的運作，根據許多篇國外的文章指出，EF是自己控制連線，並不會依照你Dispose或是New Instance就關閉跟建立新連線，所以我特地寫一個範例立馬來實驗一下 首先寫一個ADO.NET版本，並且刻意不要寫SqlConnection . Close()，觀察SQL Connection Pool的狀況 123456789101112void Main()&#123; for (int i = 0; i &lt; 10; i++) &#123; SqlConnection conn = new SqlConnection(this.Connection.ConnectionString); conn.Open(); SqlCommand command = new SqlCommand(&quot;select top 1 CustomerID from Customers&quot;, conn); var Result = command.ExecuteScalar().ToString(); Result.Dump(); &#125;&#125; 資料庫那邊用以下語法查詢目前連線DB得使用者與狀態 12select * from sys.sysprocesses where status = &#x27;sleeping&#x27; and spid &gt; 50 order by login_time desc 實驗結果發現Pool立馬從4個暴增到14個 [![](https://1.bp.blogspot.com/-oEdNrW43zrg/WFj8I-X22EI/AAAAAAAAICY/hGYoeCGf7F0wxC4D-pLB5-ILQmOBQ7ASgCLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://1.bp.blogspot.com/-oEdNrW43zrg/WFj8I-X22EI/AAAAAAAAICY/hGYoeCGf7F0wxC4D-pLB5-ILQmOBQ7ASgCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) [![](https://3.bp.blogspot.com/-4UVQhQQHP_I/WFj74WVDqsI/AAAAAAAAICU/N8MWSU17kiIm9CoqwaOoJYGorDof8BBHQCLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-4UVQhQQHP_I/WFj74WVDqsI/AAAAAAAAICU/N8MWSU17kiIm9CoqwaOoJYGorDof8BBHQCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 接著寫測是第二個版本，有呼叫Close()看看結果 1234567891011121314void Main()&#123; for (int i = 0; i &lt; 10; i++) &#123; SqlConnection conn = new SqlConnection(this.Connection.ConnectionString); conn.Open(); SqlCommand command = new SqlCommand(&quot;select top 1 CustomerID from Customers&quot;, conn); var Result = command.ExecuteScalar().ToString(); Result.Dump(); conn.Close(); //有呼叫Close &#125;&#125; Pool裡面的閒置Connection數明顯下降，所以有沒有呼叫Close是有差別的，如果有Close的話，會有放掉Connection進而重用閒置的連線 [![](https://3.bp.blogspot.com/-n5iNtVFfa1A/WFj8v__0zPI/AAAAAAAAICg/pv_Yn0Yh3REK0G3quPsd2Q_TwuOOLmNqACLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-n5iNtVFfa1A/WFj8v__0zPI/AAAAAAAAICg/pv_Yn0Yh3REK0G3quPsd2Q_TwuOOLmNqACLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 接著來看看EF的版本，首先測試沒有呼叫Dispose()，且每次Create新的DBContext。(我是用LinqPad測試，所以建立DBContext的地方語法有點不一樣，但不影響結果) 123456789void Main()&#123; for (int i = 0; i &lt; 10; i++) &#123; var context = new TypedDataContext(); context.Customers.FirstOrDefault().CustomerID.Dump(); &#125;&#125; 結果看起來連線數也是會自己重用 [![](https://1.bp.blogspot.com/-9dcCNkudzVU/WFj-FcO1zEI/AAAAAAAAICw/u6OqldT3IboAR-5UjsFll0DK4bPdF0FwQCLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://1.bp.blogspot.com/-9dcCNkudzVU/WFj-FcO1zEI/AAAAAAAAICw/u6OqldT3IboAR-5UjsFll0DK4bPdF0FwQCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 既然EF會自己控制連線，那是否用Using來Dispose與否也沒差，連線並不會無限制增加?所以我把程式改成這樣再跑一次 1234567891011void Main()&#123; for (int i = 0; i &lt; 10; i++) &#123; using (var context = new TypedDataContext()) &#123; context.Customers.FirstOrDefault().CustomerID.Dump(); &#125; &#125;&#125; [![](https://3.bp.blogspot.com/-ueHmNj18HlA/WFj-9VzgvXI/AAAAAAAAIC4/W9-U8j0R3IEaHodcAc1lSR3WkA34LstAgCLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://3.bp.blogspot.com/-ueHmNj18HlA/WFj-9VzgvXI/AAAAAAAAIC4/W9-U8j0R3IEaHodcAc1lSR3WkA34LstAgCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 結果顯示，一模一樣的情況，所以EF的確有自己在控制網路連線這一環，與你Dispose無關，也驗證了這篇文章所說的「 Do I always have to call Dispose() on my DbContext objects? Nope」 ****解決方案 :&nbsp; 依照上面的時間結果觀察，EF的確有自己在控制連線狀態這件事情，而他什麼時候呼叫Close我並不知道，且還套用了Singleton Pattern，這樣交互影響下不確定是不是導致上述發生的結果，所以我把EF整個拿掉，整個Database Layer用Dapper翻寫，每次連線都自己控制，不再使用EF，上線後至今已經一個禮拜，不再出現任何資料庫連線錯誤。 雖然不敢保證中間推斷的是否百分之百正確，因為如果要更確定，應該要追到EF的底層Code來看他究竟是怎麼寫的，或許觀念大致相同，但是可能會跟我論述的有落差，但的確可以把問題收斂到是EF這個區塊的問題，因為改用Dapper就沒事了。 這個問題整整困擾了將近一年的時間，我想在徹底研究出EF該怎麼解決這個問題之前，大型服務我應該都會暫時放棄這條路了，雖然EF真的很方便阿!!!(吶喊~) 註1:依照DB Connection Pool的概念，如果有呼叫SqlConnection Close的話，會將Connection釋放到Pool，等到下次有連線時，會優先檢查Pool是否有閒置的可以使用，沒有才會建立新的。參考: MSDN - SqlConnection.Close 方法 () 參考文章1.&nbsp;[在 SQL Server 發現大量在 Sleeping 的連線](https://blogs.msdn.microsoft.com/jchiou/2012/12/10/sql-server-sleeping/)","categories":[],"tags":[{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://toyo0103.github.io/tags/Entity-Framework/"}]},{"title":"【IIS】405  不允許用來存取此網頁的HTTP 指令動詞","slug":"【IIS】405-不允許用來存取此網頁的HTTP-指令動詞","date":"2016-11-28T02:57:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2016/11/28/【IIS】405-不允許用來存取此網頁的HTTP-指令動詞/","link":"","permalink":"https://toyo0103.github.io/2016/11/28/%E3%80%90IIS%E3%80%91405-%E4%B8%8D%E5%85%81%E8%A8%B1%E7%94%A8%E4%BE%86%E5%AD%98%E5%8F%96%E6%AD%A4%E7%B6%B2%E9%A0%81%E7%9A%84HTTP-%E6%8C%87%E4%BB%A4%E5%8B%95%E8%A9%9E/","excerpt":"","text":"上線WebAPI專案的時候，發現只要用非Get與Post的動詞呼叫API，就會得到這個405的錯誤，最後上網找了一下資料跟請教同事，紀錄一下狀況。 首先如果IIS的的WebDAV功能有被啟動，那這些Http動詞就會被擋掉。但我同時也懷疑是安裝WebDeploy會開啟這個功能(目前沒有證實)，會這樣懷疑是因為這個服務之前是沒問題的，但當天安裝了WebDeploy要建置CI環境時，這服務相關動詞就掛了。但當天安裝WebDeploy的多台機器中，有些裝完也沒啟動WebDAV，現在不知道到底是需要特定環境或設定會開啟這個功能，還是一開始安裝IIS就勾選啟動了這功能，總之要小心就是了 [![](https://4.bp.blogspot.com/-HKu_UbhGZWg/WDubNA_FOUI/AAAAAAAAIBw/he7Kx_8_nh8GaCzrFKOzUgIn2zOeodTTwCLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://4.bp.blogspot.com/-HKu_UbhGZWg/WDubNA_FOUI/AAAAAAAAIBw/he7Kx_8_nh8GaCzrFKOzUgIn2zOeodTTwCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 如果發現WebDAV被啟動，同時發生405錯誤時，在該網站的WebConfig加上以下區段來解決。 12345678910111213&lt;system.webServer&gt; &lt;modules&gt; ...... &lt;remove name=&quot;WebDAVModule&quot;/&gt; ...... &lt;/modules&gt; &lt;handlers&gt; ....... &lt;remove name=&quot;WebDAV&quot; /&gt; ....... &lt;/handlers&gt;&lt;/system.webServer&gt;","categories":[],"tags":[{"name":"WebAPI","slug":"WebAPI","permalink":"https://toyo0103.github.io/tags/WebAPI/"},{"name":"IIS","slug":"IIS","permalink":"https://toyo0103.github.io/tags/IIS/"}]},{"title":"【FluentValidation】繼承父類別的驗證","slug":"【FluentValidation】繼承父類別的驗證","date":"2016-11-25T06:39:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2016/11/25/【FluentValidation】繼承父類別的驗證/","link":"","permalink":"https://toyo0103.github.io/2016/11/25/%E3%80%90FluentValidation%E3%80%91%E7%B9%BC%E6%89%BF%E7%88%B6%E9%A1%9E%E5%88%A5%E7%9A%84%E9%A9%97%E8%AD%89/","excerpt":"","text":"很多時候我們的類別會繼承同一個父類別，而父類別的欄位可能都驗證的規則都一致，一直重寫會覺得很煩 123456789101112131415public class Parent &#123; public string Name &#123;get;set;&#125;&#125;public class ChildA :Parent&#123; public string ChildACustomProperty &#123;get;set;&#125;&#125;public class ChildB : Parent&#123; public string ChildBCustomProperty &#123; get; set; &#125;&#125; 這邊有兩個類別分別為ChildA和 ChildB，它們都繼承Parent這個類別，這時候 Parent的Name規則就是不能為空值跟Null，但真正會傳進來使用的是ChildA 與ChildB這兩個子類別，難道只能將驗證Name的欄位兩邊都寫嗎?? 123456789101112131415161718192021222324252627282930313233343536373839404142public class ChildAValidators : AbstractValidator&lt;ChildA&gt;&#123; public ChildAValidators() &#123; // Name this.RuleFor(x =&gt; x.Name) .NotEmpty() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;Name 不能為空值&quot;) .NotNull() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;Name 不能為Null&quot;); // ChildACustomProperty this.RuleFor(x =&gt; x.ChildACustomProperty) .Length(1,6) .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;ChildACustomProperty 必須介於1~6個字之間&quot;); &#125;&#125;public class ChildBValidators : AbstractValidator&lt;ChildB&gt;&#123; public ChildBValidators() &#123; // Name this.RuleFor(x =&gt; x.Name) .NotEmpty() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;Name 不能為空值&quot;) .NotNull() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;Name 不能為Null&quot;); // ChildACustomProperty this.RuleFor(x =&gt; x.ChildBCustomProperty) .Length(1, 12) .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;ChildBCustomProperty 必須介於1~12個字之間&quot;); &#125;&#125; 這樣對程式設計來說不是很好，如果哪天Name的限制改變，所有繼承Parent的驗證都要翻出來改，其實FluentValidation也可以寫成繼承的方式，可以改成下面的方法 12345678910111213141516171819202122232425262728293031323334353637383940public class ChildAValidators : ParentValidators&lt;ChildA&gt;&#123; public ChildAValidators() &#123; // ChildACustomProperty this.RuleFor(x =&gt; x.ChildACustomProperty) .Length(1,6) .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;ChildACustomProperty 必須介於1~6個字之間&quot;); &#125;&#125;public class ChildBValidators : ParentValidators&lt;ChildB&gt;&#123; public ChildBValidators() &#123; // ChildACustomProperty this.RuleFor(x =&gt; x.ChildBCustomProperty) .Length(1, 12) .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;ChildBCustomProperty 必須介於1~12個字之間&quot;); &#125;&#125;public class ParentValidators&lt;T&gt; : AbstractValidator&lt;T&gt; where T : Parent&#123; public ParentValidators() &#123; // Name this.RuleFor(x =&gt; x.Name) .NotEmpty() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;Name 不能為空值&quot;) .NotNull() .WithErrorCode(&quot;400&quot;) .WithMessage(&quot;Name 不能為Null&quot;); &#125;&#125; 這樣就可以讓程式乾淨許多，也讓它符合物件導向的設計!!!","categories":[],"tags":[{"name":"FluentValidation","slug":"FluentValidation","permalink":"https://toyo0103.github.io/tags/FluentValidation/"}]},{"title":"【Linq】Multiple Column with OrderBy","slug":"【Linq】Multiple-Column-with-OrderBy","date":"2016-11-10T03:24:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2016/11/10/【Linq】Multiple-Column-with-OrderBy/","link":"","permalink":"https://toyo0103.github.io/2016/11/10/%E3%80%90Linq%E3%80%91Multiple-Column-with-OrderBy/","excerpt":"","text":"用Linq的好處是強型別，讓你在寫程式的時後不會因為Key錯字，但也有些衍伸的問題導致程式會寫得很醜，以前最常碰到的例子就是，當排序可能依據【多欄位】升降冪，程式就會又臭又長。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void Main()&#123; //要用來排序的欄位 OrderByColumnEnum OrderByColumn = OrderByColumnEnum.Pin; //排序的方法 OrderByEnum OrderBy = OrderByEnum.ASC; //準備資料 var BuildingList = new List&lt;Building&gt;(); for (int i = 0; i &lt; 5; i++) &#123; BuildingList.Add(new Building &#123; Age = 1 * (i+1), Pin = 1 * (i+1), CaseDate = DateTime.Now.AddDays(i +1) &#125;); &#125; //排序欄位 switch (OrderByColumn) &#123; case OrderByColumnEnum.Pin: switch (OrderBy) &#123; case OrderByEnum.ASC: //因為裡面用到的欄位不同,又是強型別,只能寫死... BuildingList = BuildingList.OrderBy(x =&gt; x.Pin).ToList(); break; case OrderByEnum.DESC: BuildingList = BuildingList.OrderByDescending(x =&gt; x.Pin).ToList(); break; &#125; break; case OrderByColumnEnum.Age: switch (OrderBy) &#123; case OrderByEnum.ASC: BuildingList = BuildingList.OrderBy(x =&gt; x.Age).ToList(); break; case OrderByEnum.DESC: BuildingList = BuildingList.OrderByDescending(x =&gt;x.Age).ToList(); break; &#125; break; case OrderByColumnEnum.CaseDate: switch (OrderBy) &#123; case OrderByEnum.ASC: BuildingList = BuildingList.OrderBy(x =&gt; x.CaseDate).ToList(); break; case OrderByEnum.DESC: BuildingList = BuildingList.OrderByDescending(x =&gt; x.CaseDate).ToList(); break; &#125; break; &#125; BuildingList.Dump();&#125;public class Building&#123; public int Pin &#123; get; set; &#125; public int Age &#123; get; set; &#125; public DateTime CaseDate &#123; get; set; &#125;&#125;/// &lt;summary&gt;/// 排序欄位/// &lt;/summary&gt;public enum OrderByColumnEnum&#123; /// &lt;summary&gt; /// 成交日期 /// &lt;/summary&gt; CaseDate, /// &lt;summary&gt; /// 建坪 /// &lt;/summary&gt; Pin, /// &lt;summary&gt; /// 屋齡 /// &lt;/summary&gt; Age&#125;/// &lt;summary&gt;/// 排序方法/// &lt;/summary&gt;public enum OrderByEnum&#123; ASC = 1, DESC = 2&#125; 因為每個欄位不同名稱,又有可能升降冪，所以寫的超級長，如果欄位達到5~6個時，幾乎已經無法維護，但其實只要搭配一點點反射可以把這段改得很漂亮的 12345678910111213141516171819202122232425262728293031323334//要用來排序的欄位 OrderByColumnEnum OrderByColumn = OrderByColumnEnum.Pin; //排序的方法 OrderByEnum OrderBy = OrderByEnum.ASC; //準備資料 var BuildingList = new List&lt;Building&gt;(); for (int i = 0; i &lt; 5; i++) &#123; BuildingList.Add(new Building &#123; Age = 1 * (i+1), Pin = 1 * (i+1), CaseDate = DateTime.Now.AddDays(i +1) &#125;); &#125; //排序欄位 var param = OrderByColumnEnum.Pin.ToString(); //透過PropertyInfo操作 var propertyInfo = typeof(Building).GetProperty(param); switch (OrderBy) &#123; case OrderByEnum.ASC: BuildingList = BuildingList.OrderBy(x =&gt; propertyInfo.GetValue(x, null)).ToList(); break; case OrderByEnum.DESC: BuildingList = BuildingList.OrderByDescending(x =&gt; propertyInfo.GetValue(x, null)).ToList(); break; &#125; BuildingList.Dump(); 這樣程式是不是變得乾淨許多,但這邊要特別注意的是，因為我的Enum跟Building的屬性剛好都可以對應起來，如果我的Enum名稱與Building的屬性不能對應，那要另外寫對應方式，例如寫到擴充的Enum Attribute，或是用最簡單的Switch Case解決。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"LINQ","slug":"LINQ","permalink":"https://toyo0103.github.io/tags/LINQ/"}]},{"title":"【Unit Test】Fake DLL發生does not exist in the namespace 'System.Diagnostics.Tracing'","slug":"【Unit-Test】Fake-DLL發生does-not-exist-in-the-namespace-System-Diagnostics-Tracing","date":"2016-10-17T06:49:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2016/10/17/【Unit-Test】Fake-DLL發生does-not-exist-in-the-namespace-System-Diagnostics-Tracing/","link":"","permalink":"https://toyo0103.github.io/2016/10/17/%E3%80%90Unit-Test%E3%80%91Fake-DLL%E7%99%BC%E7%94%9Fdoes-not-exist-in-the-namespace-System-Diagnostics-Tracing/","excerpt":"","text":"上一篇【Unit Test】Fake System.DateTime&nbsp;寫到如何Fake DLL，在本機建置與進行測試都沒問題，唯獨放到CICD機器去做自動化部屬時，一直鬼擋牆的跳建置方案錯誤，錯誤內容如下 The type or namespace name ‘EventSourceCreatedEventArgs’ does not exist in the namespace ‘System.Diagnostics.Tracing’ (are you missing an assembly reference?)&nbsp;上網查了一下找到以下解法 打開mscorlib.fakes，改成以下內容```csharp ``` 自動化佈署機器這樣去建置佈署就過關了!!!!","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】Fake System.DateTime","slug":"【Unit-Test】Fake-System-DateTime","date":"2016-10-17T06:26:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2016/10/17/【Unit-Test】Fake-System-DateTime/","link":"","permalink":"https://toyo0103.github.io/2016/10/17/%E3%80%90Unit-Test%E3%80%91Fake-System-DateTime/","excerpt":"","text":"在寫程式的時後，常常會用到DateTime.Now來判斷目前時間，依照時間邏輯去撈取不同的資料，但碰到單元測試要驗證的時候就是個大麻煩，因為DateTime.Now每次執行的時候時間都會改變，所以以前的做法都是這樣 1234567891011121314public static class SystemTime&#123; //Internal For UnitTest internal static Func&lt;DateTime&gt; SetCurrentTime = () =&gt; DateTime.Now; public static DateTime Now &#123; get &#123; return SetCurrentTime(); &#125; &#125;&#125; 然後在在程式碼裡面使用的時候不直接使用DateTime.Now，改用SystemTime.Now 123456789101112void Main()&#123; if (SystemTime.Now == new DateTime(2016,10,17,12,0,0)) &#123; &quot;時間到了&quot;.Dump(); &#125; else &#123; &quot;時間不對&quot;.Dump(); &#125;&#125; 之後單元測試驗證時，動態去改寫SetCurrentTime，就能確保拿到自己要的時間 12SystemTime.SetCurrentTime = () =&gt; new DateTime(2016,10,17,12,0,0); 雖然這樣可以解決問題沒錯，但實在太麻煩，為了單元測試要多寫一堆Code之外，System底下很多東西有用到時，都要因為可以單元測試的關係而擴充出來。 還好之後有找到方法可以針對DLL做Fake，讓我們可以繼續安心使用DateTime.Now之餘，單元測試也能指定時間，接下來就來實作一下這個步驟 首先在單元測試的專案對參考的組件System按下右鍵，新增Fake物件 [![](https://4.bp.blogspot.com/-2CmHnA1rUMA/WARsswfjOPI/AAAAAAAAIBI/HGzYnnuIOzM6DuGEl8psJIIA4EtBmutgQCLcB/s1600/1.png)](https://4.bp.blogspot.com/-2CmHnA1rUMA/WARsswfjOPI/AAAAAAAAIBI/HGzYnnuIOzM6DuGEl8psJIIA4EtBmutgQCLcB/s1600/1.png) 接著就會跑出Fake資料夾 [![](https://3.bp.blogspot.com/-QhvjMs19Dr4/WARtB33gWvI/AAAAAAAAIBM/ptqbpm0CKTgbi5C8CWZY3DjWbmykiJa4gCLcB/s1600/1.png)](https://3.bp.blogspot.com/-QhvjMs19Dr4/WARtB33gWvI/AAAAAAAAIBM/ptqbpm0CKTgbi5C8CWZY3DjWbmykiJa4gCLcB/s1600/1.png) 接著只要在單元測試的地方寫如此寫，就能設定DateTime.Now應該回傳的時間了```csharp[TestMethod] public void 取得現在時間() &#123; using (ShimsContext.Create()) &#123; System.Fakes.ShimDateTime.NowGet= () =&gt; &#123; return new DateTime(2016, 9, 25); &#125;; //arrange var expected = new DateTime(2016, 9, 25); //act var actual = DateTime.Now; //assert Assert.AreEqual(expected, actual); &#125; &#125; ``` 補充2017/01/24單元測試Fake的功能，以Visual Studio 2015來說只有Enterprise版本才有支援，所以使用的時候請特別小心，像今天公司因為授權費的關係，要求調降成Professional，之前有用到Fake的地方就都測不過了，還請特別注意 各版本比較 : Compare Visual Studio 2015 Offerings 參考文章[Huan-Lin - Microsoft Fakes 入門](http://huan-lin.blogspot.com/2012/10/microsoft-fakes.html)","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Swagger】客製化可以輸入Header的欄位","slug":"【Swagger】客製化可以輸入Header的欄位","date":"2016-10-14T06:26:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2016/10/14/【Swagger】客製化可以輸入Header的欄位/","link":"","permalink":"https://toyo0103.github.io/2016/10/14/%E3%80%90Swagger%E3%80%91%E5%AE%A2%E8%A3%BD%E5%8C%96%E5%8F%AF%E4%BB%A5%E8%BC%B8%E5%85%A5Header%E7%9A%84%E6%AC%84%E4%BD%8D/","excerpt":"","text":"上一篇【Swagger】活著的API規格書&nbsp;提到如何使用Swagger來產生規格與測試API，但遇到一個問題是，很多API會把驗證的Key放到Header傳遞，但Swagger產出來的頁面並沒有設定Header的地方，這時候就要來小調整一下已符合需求。 首先我們先把原本的API改成要吃Header的Key值才算驗證通過 123456789101112131415161718192021222324252627282930313233343536public class TestSwaggerController : ApiController &#123; /// &lt;summary&gt; /// 測試Swagger的API /// &lt;/summary&gt; /// &lt;param name=&quot;parameter&quot;&gt;The parameter.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpGet] [Route(&quot;api/testSwagger&quot;)] public HttpResponseMessage Get([FromUri]testSwaggerGetParameter parameter) &#123; //沒有帶Appkey在Header if (!Request.Headers.Contains(&quot;X-Key&quot;)) &#123; return Request.CreateResponse(HttpStatusCode.NotAcceptable, &quot;必須輸入AppKey&quot;); &#125; var AppKey = Request.Headers.GetValues(&quot;X-Key&quot;).FirstOrDefault(); if (AppKey != &quot;MyKey&quot;) &#123; return Request.CreateResponse(HttpStatusCode.NotAcceptable, &quot;AppKey不正確!!!&quot;); &#125; if (parameter != null &amp;&amp; parameter.ID == &quot;toyo&quot; &amp;&amp; parameter.PassWord == &quot;123456&quot;) &#123; return Request.CreateResponse(HttpStatusCode.OK, &quot;帳號密碼正確&quot;); &#125; return Request.CreateResponse(HttpStatusCode.OK, &quot;帳號密碼錯誤摟!!!!!&quot;); &#125; &#125; 這時候測試一下原本的API，會發現因為吃不到Header裡面的X-Key，導致輸出驗證失敗的錯誤 [![](https://1.bp.blogspot.com/-hntf0ZIC-cQ/WAB1wx9JTOI/AAAAAAAAIAU/R5nql0g5UZwtIU6pdfk82zPO7EjDp4FggCLcB/s640/1.png)](https://1.bp.blogspot.com/-hntf0ZIC-cQ/WAB1wx9JTOI/AAAAAAAAIAU/R5nql0g5UZwtIU6pdfk82zPO7EjDp4FggCLcB/s1600/1.png) Header中也再次確認沒有帶X-key在其中 [![](https://1.bp.blogspot.com/-pevW7o5r1eg/WAB2BE9-ayI/AAAAAAAAIAY/ErtqWFRqK7k0WBAKQXBZB32ghXOn3196gCLcB/s640/1.png)](https://1.bp.blogspot.com/-pevW7o5r1eg/WAB2BE9-ayI/AAAAAAAAIAY/ErtqWFRqK7k0WBAKQXBZB32ghXOn3196gCLcB/s1600/1.png) 開始客製化吧 首先先建立一個JS檔，讓Swagger的View能引用這支JS，然後透過這支JS與Jquery去改View，我將這支JS就命名為AppKey.js [![](https://1.bp.blogspot.com/-VdaLRHRtOlI/WAB3LAbaafI/AAAAAAAAIAc/tDB1aQ-EzzEutJ0RXZkrr4TRwvcWwFUnwCLcB/s1600/1.png)](https://1.bp.blogspot.com/-VdaLRHRtOlI/WAB3LAbaafI/AAAAAAAAIAc/tDB1aQ-EzzEutJ0RXZkrr4TRwvcWwFUnwCLcB/s1600/1.png) 接著請在這支JS檔案寫下以下JS 12345678910111213141516171819202122232425262728293031$(function () &#123; $(&#x27;#input_apiKey&#x27;).hide(); //加上Header區塊 var HeaderBar = $(&#x27;&lt;div id=&quot;headerbar&quot;&gt;&#x27; + &#x27;&lt;h2 class=&quot;heading&quot;&gt;Header&lt;/h2&gt;&#x27; + &#x27;&lt;table style=&quot;background-color:#E8E8D0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&#x27; + &#x27;&lt;th style=&quot;width: 100px; max-width: 100px&quot; data-sw-translate=&quot;&quot;&gt;Parameter&lt;/th&gt;&#x27; + &#x27;&lt;th style=&quot;width: 310px; max-width: 310px&quot; data-sw-translate=&quot;&quot;&gt;Value&lt;/th&gt;&#x27; + &#x27;&lt;th style=&quot;width: 200px; max-width: 200px&quot; data-sw-translate=&quot;&quot;&gt;Description&lt;/th&gt;&#x27; + &#x27;&lt;/tr&gt;&lt;/thead&gt;&#x27; + &#x27;&lt;tbody class=&quot;operation-params&quot;&gt;&#x27; + &#x27;&lt;tr&gt;&#x27; + &#x27;&lt;td class=&quot;code required&quot;&gt;&lt;label for=&quot;custom_appkey&quot;&gt;appkey&lt;/label&gt;&lt;/td&gt;&#x27; + &#x27;&lt;td&gt;&lt;input class=&quot;parameter required&quot; minlength=&quot;1&quot; name=&quot;custom_appkey&quot; placeholder=&quot;(required)&quot; id=&quot;custom_appkey&quot; type=&quot;text&quot; value=&quot;&quot;&gt;&lt;/td&gt;&#x27; + &#x27;&lt;td class=&quot;markdown&quot;&gt;&lt;p&gt;AppKey&lt;/p&gt;&lt;/td&gt;&#x27; + &#x27;&lt;/tr&gt;&#x27; + &#x27;&lt;/tbody&gt;&lt;/table&gt;&#x27; + &#x27;&lt;/div&gt;&#x27;); $(&#x27;#resources_container&#x27;).before(HeaderBar); //把值加到Header $(&#x27;#custom_appkey&#x27;).on(&#x27;change&#x27;, function () &#123; var key = this.value; if (key &amp;&amp; key.trim() !== &#x27;&#x27;) &#123; swaggerUi.api.clientAuthorizations.add(&quot;key&quot;, new SwaggerClient.ApiKeyAuthorization(&quot;X-Key&quot;, key, &quot;header&quot;)); &#125; &#125;);&#125;); 主要內容就是抓到特定區塊，然後組Html用Jquery的方式放上去，然後透過Swagger開放的API塞到Header裡面送出 接著請將這支JS修改屬性 &gt; 建置動作 &gt; 內嵌資源 [![](https://4.bp.blogspot.com/-BwLvO5AMcYw/WAB4kuDTvUI/AAAAAAAAIAg/QBIkgR01zCYDIxd2UjHmhHLanbuwCchqQCLcB/s320/1.png)](https://4.bp.blogspot.com/-BwLvO5AMcYw/WAB4kuDTvUI/AAAAAAAAIAg/QBIkgR01zCYDIxd2UjHmhHLanbuwCchqQCLcB/s1600/1.png) 打開SwaggerConfig找到188~189行的地方把註解拿掉改成如下[![](https://2.bp.blogspot.com/-kG8umCQL1M0/WAB5FrxW2gI/AAAAAAAAIAo/RwoPyjGGq0YB1SE6f9jTvJ3h9mcveFFlQCLcB/s640/1.png)](https://2.bp.blogspot.com/-kG8umCQL1M0/WAB5FrxW2gI/AAAAAAAAIAo/RwoPyjGGq0YB1SE6f9jTvJ3h9mcveFFlQCLcB/s1600/1.png) 12c.InjectJavaScript(thisAssembly, &quot;WebApplication1.CustomSwagger.AppKey.js&quot;); 接著再次執行專案[![](https://2.bp.blogspot.com/-jAdPbsrj5yI/WAB5_JNiKdI/AAAAAAAAIAs/7DMJc1iTBl4kAm6_7yTv2f4pmNCfqFEQQCLcB/s640/1.png)](https://2.bp.blogspot.com/-jAdPbsrj5yI/WAB5_JNiKdI/AAAAAAAAIAs/7DMJc1iTBl4kAm6_7yTv2f4pmNCfqFEQQCLcB/s1600/1.png)Header欄位出現了 試試看欄位是否有效，因為剛剛程式是改成要帶**MyKey**，所以來測試看看 [![](https://1.bp.blogspot.com/-v7nxyvIuGfs/WAB6YhN2EEI/AAAAAAAAIAw/luDPe_40Fpc-xvazlnkwp6qEPRdUbKMvgCLcB/s640/1.png)](https://1.bp.blogspot.com/-v7nxyvIuGfs/WAB6YhN2EEI/AAAAAAAAIAw/luDPe_40Fpc-xvazlnkwp6qEPRdUbKMvgCLcB/s1600/1.png)可以抓到X-Key了 完成!!!! 因為是透過Jquery的方式去改變欄位，所以只要透過上述的方式去載入JS，要怎麼改View應該都不是問題了，以上。 參考文章Customize Authentication Header in SwaggerUI using Swashbuckle","categories":[],"tags":[{"name":"Swagger","slug":"Swagger","permalink":"https://toyo0103.github.io/tags/Swagger/"}]},{"title":"【Swagger】活著的API規格書","slug":"【Swagger】活著的API規格書","date":"2016-10-14T03:01:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2016/10/14/【Swagger】活著的API規格書/","link":"","permalink":"https://toyo0103.github.io/2016/10/14/%E3%80%90Swagger%E3%80%91%E6%B4%BB%E8%91%97%E7%9A%84API%E8%A6%8F%E6%A0%BC%E6%9B%B8/","excerpt":"","text":"所謂的工程師就是，【接手別人專案時，總是問怎麼沒有規格書? 自己開發專案時卻又不喜歡寫規格書】的一群人，本人也是一個極度不喜歡寫規格書的人，簡單說就是懶到極致，懶到深處無怨尤。而且常常改版時來匆匆忙忙，寫程式的時間都不夠了，誰還管你規格書有沒有更新，就這樣恍神個兩三次忘記回去更新規格，這本規格書就光榮列入公司十大(搞不好百大?)不可思議天書，可謂極度麻煩費時討厭….. 還好同事介紹了Swagger的用法，讓你邊開發程式時，規格就產生書產生出來了，而且還是本可以使用的規格書，讓你從今以後再也不用擔心規格書與實際規格脫鉤的問題，以下就筆記一下如何使用 [![](https://4.bp.blogspot.com/-DHN0U1Vqe3U/WAA8GQA474I/AAAAAAAAH-o/idcyU1UFoPoM9sI2fs7Jga7vTRrA_Lz7gCLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://4.bp.blogspot.com/-DHN0U1Vqe3U/WAA8GQA474I/AAAAAAAAH-o/idcyU1UFoPoM9sI2fs7Jga7vTRrA_Lz7gCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)Swagger-當開發完API時，規格書也就完成了!![![](https://4.bp.blogspot.com/-Q_gy5BypWEQ/WAA8wzGS32I/AAAAAAAAH-s/dbAyDeDRpPgfEc-OjH9_s2GIaafUpCBjACLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://4.bp.blogspot.com/-Q_gy5BypWEQ/WAA8wzGS32I/AAAAAAAAH-s/dbAyDeDRpPgfEc-OjH9_s2GIaafUpCBjACLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)輸入的參數與說明也寫得清清楚楚[![](https://1.bp.blogspot.com/-WbKmvP1AzgE/WAA-rbXKmUI/AAAAAAAAH-8/-tLhejDldqI_HmO2FNDS1gO6ImyOrrfngCLcB/s640/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://1.bp.blogspot.com/-WbKmvP1AzgE/WAA-rbXKmUI/AAAAAAAAH-8/-tLhejDldqI_HmO2FNDS1gO6ImyOrrfngCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)按下Try it Out後，可以馬上測試API跟觀看結果!! 使用步驟 首先我先開一個WebAPI專案，然後寫一支簡單的API讓他可以運作開一個WebAPI專案[![](https://3.bp.blogspot.com/-VmbQGY5UMMU/WABBEd25TPI/AAAAAAAAH_I/MGng_1nDDSEQ-zLiXyahRK5GTT9XMtSEwCLcB/s640/2.png)](https://3.bp.blogspot.com/-VmbQGY5UMMU/WABBEd25TPI/AAAAAAAAH_I/MGng_1nDDSEQ-zLiXyahRK5GTT9XMtSEwCLcB/s1600/2.png)新增一個新的TestSwaggerController [![](https://1.bp.blogspot.com/-AENbjbb3Ia4/WABBERDf0cI/AAAAAAAAH_M/Ea_va3RXz0kCcplepPRx-nBqaHHpLLsCwCLcB/s1600/3.png)](https://1.bp.blogspot.com/-AENbjbb3Ia4/WABBERDf0cI/AAAAAAAAH_M/Ea_va3RXz0kCcplepPRx-nBqaHHpLLsCwCLcB/s1600/3.png) 開始撰寫幾個簡單的API跟輸入輸出參數 ```csharp public class testSwaggerGetParameter { /// /// 帳號 /// /// /// The identifier. /// public string ID { get; set; } /// &lt;summary&gt; /// 密碼 /// &lt;/summary&gt; /// &lt;value&gt; /// The passWord. /// &lt;/value&gt; public string PassWord &#123; get; set; &#125; } 123456789101112131415161718192021222324&#96;&#96;&#96;csharppublic class TestSwaggerController : ApiController &#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 測試Swagger的API &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;parameter&quot;&gt;The parameter.&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; [HttpGet] [Route(&quot;api&#x2F;testSwagger&quot;)] public HttpResponseMessage Get([FromUri]testSwaggerGetParameter parameter) &#123; if (parameter !&#x3D; null &amp;&amp; parameter.ID &#x3D;&#x3D; &quot;toyo&quot; &amp;&amp; parameter.PassWord &#x3D;&#x3D; &quot;123456&quot;) &#123; return Request.CreateResponse(HttpStatusCode.OK, &quot;帳號密碼正確&quot;); &#125; return Request.CreateResponse(HttpStatusCode.OK, &quot;帳號密碼錯誤摟!!!!!&quot;); &#125; &#125; 接著先來測試API的運作是否正常[![](https://3.bp.blogspot.com/-NGEX0U-saSw/WABFAd9ksPI/AAAAAAAAH_c/AQuEDjoIGL4jbBYZs2PJ7B7lnAS7fB8xQCLcB/s640/2.png)](https://3.bp.blogspot.com/-NGEX0U-saSw/WABFAd9ksPI/AAAAAAAAH_c/AQuEDjoIGL4jbBYZs2PJ7B7lnAS7fB8xQCLcB/s1600/2.png)輸入正確的測試 [![](https://1.bp.blogspot.com/-i923xx2aY30/WABFABbQrdI/AAAAAAAAH_Y/cvhLOl1x6xw3aJ5Yvd-T7gBcePHTb8GCwCLcB/s640/1.png)](https://1.bp.blogspot.com/-i923xx2aY30/WABFABbQrdI/AAAAAAAAH_Y/cvhLOl1x6xw3aJ5Yvd-T7gBcePHTb8GCwCLcB/s1600/1.png)輸入錯誤的測試 API都準備就緒後，來安裝Swagger吧首先打開Nuget搜尋Swashbuckle並安裝[![](https://1.bp.blogspot.com/-I6T6On4UU0I/WABGKKbp_4I/AAAAAAAAH_g/thsWbtJB9d8M-wBG3oHoBHct0d6N-7ohwCLcB/s640/1.png)](https://1.bp.blogspot.com/-I6T6On4UU0I/WABGKKbp_4I/AAAAAAAAH_g/thsWbtJB9d8M-wBG3oHoBHct0d6N-7ohwCLcB/s1600/1.png) 接著打開專案屬性，設定輸出XML說明格式 [![](https://3.bp.blogspot.com/-Q35LXg-ZAbc/WABHQqOA9II/AAAAAAAAH_o/IqpSnKPL7AIkGskPH8LPMKDBYKS-cJvNACLcB/s640/1.png)](https://3.bp.blogspot.com/-Q35LXg-ZAbc/WABHQqOA9II/AAAAAAAAH_o/IqpSnKPL7AIkGskPH8LPMKDBYKS-cJvNACLcB/s1600/1.png)[![](https://2.bp.blogspot.com/-kTvzjXCAY7Q/WABHWnjk79I/AAAAAAAAH_s/WYApFDnj0RACcVPP3KQC9qGsgdxf3a3swCLcB/s640/2.png)](https://2.bp.blogspot.com/-kTvzjXCAY7Q/WABHWnjk79I/AAAAAAAAH_s/WYApFDnj0RACcVPP3KQC9qGsgdxf3a3swCLcB/s1600/2.png) 打開SwaggerConfig做些設定 [![](https://1.bp.blogspot.com/-3KPOfrFBs7A/WABHvcNMO4I/AAAAAAAAH_w/-tsOz_SqAGcvVxxSOOwok_Q1yTpZyDAiQCLcB/s1600/1.png)](https://1.bp.blogspot.com/-3KPOfrFBs7A/WABHvcNMO4I/AAAAAAAAH_w/-tsOz_SqAGcvVxxSOOwok_Q1yTpZyDAiQCLcB/s1600/1.png) 在第一百行的地方把註解拿掉 [![](https://2.bp.blogspot.com/-sNuzZJH1_Tk/WABH-ckCYAI/AAAAAAAAH_0/dY91muQCTvAggbaSNAxXFuf687P37-f4wCLcB/s640/1.png)](https://2.bp.blogspot.com/-sNuzZJH1_Tk/WABH-ckCYAI/AAAAAAAAH_0/dY91muQCTvAggbaSNAxXFuf687P37-f4wCLcB/s1600/1.png) 在最下面補上以下程式碼 [![](https://2.bp.blogspot.com/-LZWGCrO2m1E/WABIPqVRXuI/AAAAAAAAH_4/XDwqWQFF4zIfyBMKgjUfNqisGADqPMPvQCLcB/s640/1.png)](https://2.bp.blogspot.com/-LZWGCrO2m1E/WABIPqVRXuI/AAAAAAAAH_4/XDwqWQFF4zIfyBMKgjUfNqisGADqPMPvQCLcB/s1600/1.png) 重新執行WebAPI，並且在網址列輸入……./Swagger[![](https://2.bp.blogspot.com/-VKr_8qKHN7Y/WABIxRpt8gI/AAAAAAAAH_8/XaVeA3uG-9whtv0DrZ7DQYIzKXjaHryYgCLcB/s640/1.png)](https://2.bp.blogspot.com/-VKr_8qKHN7Y/WABIxRpt8gI/AAAAAAAAH_8/XaVeA3uG-9whtv0DrZ7DQYIzKXjaHryYgCLcB/s1600/1.png)看到API被輸出成規格了，參數的註解是跟著Summary的 來測試看看!!![![](https://1.bp.blogspot.com/-651X7h-rIVw/WABJN-3Jf-I/AAAAAAAAIAA/iBthsKVDiscN_ItWjk4WUUSgemSLEfDLQCLcB/s640/1.png)](https://1.bp.blogspot.com/-651X7h-rIVw/WABJN-3Jf-I/AAAAAAAAIAA/iBthsKVDiscN_ItWjk4WUUSgemSLEfDLQCLcB/s1600/1.png) [![](https://3.bp.blogspot.com/-JPjRZMJusSE/WABJOPutBbI/AAAAAAAAIAE/aFON9GjhDe0HKHY_jjJ8M8JfstfCDLoLgCLcB/s640/2.png)](https://3.bp.blogspot.com/-JPjRZMJusSE/WABJOPutBbI/AAAAAAAAIAE/aFON9GjhDe0HKHY_jjJ8M8JfstfCDLoLgCLcB/s1600/2.png) 最後，Swagger雖然已經非常好用了，也能符合大部分的情境運用，但還是有些美中不足的地方，例如如果今天API部分資訊要帶在Header裡面傳給API，在預設產生的地方是沒有提供可以輸入的地方。 但慶幸的是Swagger可以很彈性的去改寫這張最後會產生的View，可以自己擴充需要的欄位，下一篇在來介紹如何客製化Swagger頁面!!! 參考文章 mrkt&nbsp;- ASP.NET Web API 文件產生器 - 使用 Swagger mrkt-&nbsp;Swashbuckle - Swagger for Web Api 顯示內容的調整","categories":[],"tags":[{"name":"Swagger","slug":"Swagger","permalink":"https://toyo0103.github.io/tags/Swagger/"}]},{"title":"用 FluentValidation 驗證參數","slug":"用-FluentValidation-驗證參數","date":"2016-10-12T07:12:00.000Z","updated":"2022-08-09T13:36:17.098Z","comments":true,"path":"2016/10/12/用-FluentValidation-驗證參數/","link":"","permalink":"https://toyo0103.github.io/2016/10/12/%E7%94%A8-FluentValidation-%E9%A9%97%E8%AD%89%E5%8F%83%E6%95%B8/","excerpt":"","text":"FluentValidation是個很不錯的套件，且擴充性也高，解決了一些以前常常要寫很多遍的驗證邏輯。 以前常常驗證參數時都會有很多的If..Else，搞得程式碼很長很醜之外，閱讀性不佳。自從公司同事推薦了這個套件後，用了兩三個專案發現程式碼變得簡潔易懂之外，寫了一些擴充方法也可以重複使用，不像以前常常重複造輪子 12345678910111213141516171819202122232425262728293031void Main()&#123; var Parameter = new APIInputParameter &#123; ID = &quot;123&quot;, Name = &quot;Toyo&quot; &#125;; Guid _ID; //驗證邏輯 if (string.IsNullOrWhiteSpace(Parameter.ID) || !Guid.TryParse(Parameter.ID,out _ID) || string.IsNullOrWhiteSpace(Parameter.Name) ) &#123; &quot;參數錯誤&quot;.Dump(); &#125; else &#123; &quot;參數正確&quot;.Dump(); &#125;&#125;public class APIInputParameter &#123; //此參數應該為Guid，但為了能Log下來所以接的時候要先接成String //否則輸入端不是傳入GUID就記錄不到了 public string ID &#123; get; set; &#125; public string Name &#123;get;set;&#125;&#125; 上面的範例是以前的寫法，常常欄位多，各個欄位又有不同的要求時，總是把驗證的邏輯寫得又臭又長。 加上公司要求所有輸入輸出的欄位都要被Log下來，所以基本上參數都要是String型別，否則如果ID寫成GUID，因為傳入的時候不是GUID會接不到，自然無法被Log到，但也因此衍生了驗證的複雜度提高的問題。 想想如果各個參數錯誤要回傳的訊息會不同時，又該寫的多複雜才做得到呢…… 那讓來看看如何透FluentValidation 驗證參數， 首先先把驗證邏輯寫成一個Class12345678910111213141516171819202122public class APIInputParameterValidator : AbstractValidator&lt;APIInputParameter&gt;&#123; public APIInputParameterValidator() &#123; //ID - 必填，應為GUID this.RuleFor(x =&gt; x.ID) .NotEmpty() .WithErrorCode(&quot;X400&quot;) .WithMessage(&quot;ID不得為空字串&quot;) .NotNull() .WithErrorCode(&quot;X400&quot;) .WithMessage(&quot;ID不得為Null&quot;); this.RuleFor(x =&gt; x.Name) .NotEmpty() .WithErrorCode(&quot;X401&quot;) .WithMessage(&quot;Name不得為空字串&quot;) .NotNull() .WithErrorCode(&quot;X401&quot;) .WithMessage(&quot;Name不得為Null&quot;); &#125;&#125; 自己寫一個HasError的Extension```csharp/// /// FluentValidation 自訂驗證擴充方法./// public static class FluentValidationExtensions{/// /// 驗證結果是否有 Error./// /// /// public static bool HasError(this ValidationFailure validationFailure){return validationFailure != null &amp;&amp; !string.IsNullOrWhiteSpace(validationFailure.ErrorMessage);}} 12345678910111213141516171819203. 驗證的地方改成如下 &#96;&#96;&#96;csharpvar Parameter &#x3D; new APIInputParameter &#123; ID &#x3D; &quot;123&quot;, Name &#x3D; &quot;Toyo&quot; &#125;; &#x2F;&#x2F; 檢查輸入參數 var validator &#x3D; new APIInputParameterValidator(); var error &#x3D; validator.Validate(Parameter).Errors.FirstOrDefault(); if (error.HasError()) &#123; string.Format(&quot;&#123;0&#125;-&#123;1&#125;&quot;,error.ErrorCode,error.ErrorMessage).Dump(); &#125; else &#123; &quot;驗證成功&quot;.Dump(); &#125; 這樣只要有參數帶入錯誤，他就會依照你要求的帶回ErrorCode跟ErrorMessage，那可能各位會發現，阿驗證是否為GUID的地方怎麼不見了?? 因為套件並沒有提供，所以這邊要自己擴充 先寫一個驗證String是否為Guid的方法 ```csharp/// /// 驗證是否為GUID /// /// public class GUIDValidator : PropertyValidator { /// &lt;summary&gt; /// 是否允許字串參數為空白. /// &lt;/summary&gt; /// &lt;value&gt;&lt;c&gt;true&lt;/c&gt; if [allow empty]; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/value&gt; private bool AllowEmpty &#123; get; set; &#125; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref=&quot;GUIDValidator&quot;/&gt; class. /// &lt;/summary&gt; /// &lt;param name=&quot;allowEmpty&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [allow empty].&lt;/param&gt; public GUIDValidator( bool allowEmpty = false) : base(&quot;傳入參數錯誤。&quot;) &#123; this.AllowEmpty = allowEmpty; &#125; /// &lt;summary&gt; /// Returns true if ... is valid. /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;The context.&lt;/param&gt; /// &lt;returns&gt; /// &lt;c&gt;true&lt;/c&gt; if the specified context is valid; otherwise, &lt;c&gt;false&lt;/c&gt;. /// &lt;/returns&gt; protected override bool IsValid(PropertyValidatorContext context) &#123; var propertyValue = context.PropertyValue as string; if (AllowEmpty &amp;&amp; string.IsNullOrWhiteSpace(propertyValue)) &#123; return true; &#125; Guid guid; return Guid.TryParse(propertyValue, out guid); &#125; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445462. 接著在Extension的地方補上兩個擴充方法，分別是【應該是GUID】、【應該是GUID但允許其為空字串或Null】 &#96;&#96;&#96;csharp&#x2F;&#x2F;&#x2F; &lt;summary&gt;&#x2F;&#x2F;&#x2F; FluentValidation 自訂驗證擴充方法.&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;public static class FluentValidationExtensions&#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 驗證結果是否有 Error. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;validationFailure&quot;&gt;&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt; public static bool HasError(this ValidationFailure validationFailure) &#123; return validationFailure !&#x3D; null &amp;&amp; !string.IsNullOrWhiteSpace(validationFailure.ErrorMessage); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 應該是 GUID 型別. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;&lt;&#x2F;typeparam&gt; &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TProperty&quot;&gt;The type of the t property.&lt;&#x2F;typeparam&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;ruleBuilder&quot;&gt;The rule builder.&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;IRuleBuilderOptions&lt;T, TProperty&gt;.&lt;&#x2F;returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsGUID&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) &#123; return ruleBuilder.SetValidator(new GUIDValidator(allowEmpty: false)); &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 應該是 GUID 型別, 但允許 String.Empty. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;&lt;&#x2F;typeparam&gt; &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TProperty&quot;&gt;The type of the t property.&lt;&#x2F;typeparam&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;ruleBuilder&quot;&gt;The rule builder.&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt;IRuleBuilderOptions&lt;T, TProperty&gt;.&lt;&#x2F;returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsGUIDAllowEmpty&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) &#123; return ruleBuilder.SetValidator(new GUIDValidator(allowEmpty: true)); &#125;&#125; 接著在原本驗證的地方補上123456789101112//ID - 必填，應為GUIDthis.RuleFor(x =&gt; x.ID) .NotEmpty() .WithErrorCode(&quot;X400&quot;) .WithMessage(&quot;ID不得為空字串&quot;) .NotNull() .WithErrorCode(&quot;X400&quot;) .WithMessage(&quot;ID不得為Null&quot;) .IsGUID() .WithErrorCode(&quot;X400&quot;) .WithMessage(&quot;ID應為GUID&quot;); 再執行原本的驗證就會得到錯誤訊息 X400-ID應為GUID對我來說不止讓程式可讀性增加之外，也讓驗證的地方被分離出來，做到所謂的關注點分離 以下補上幾個我常常用到的驗證擴充出來的方法供各位參考，再強調一次，因為公司要求輸入輸出都要被Log下來，所以所有參數都是從String出發去驗證 驗證是否為DateTime or TimeStamp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt; /// 驗證是否為DateTime /// &lt;/summary&gt; /// &lt;seealso cref=&quot;FluentValidation.Validators.PropertyValidator&quot; /&gt; public class DateTimeValidator : PropertyValidator &#123; /// &lt;summary&gt; /// 是否允許參數為空白. /// &lt;/summary&gt; /// &lt;value&gt;&lt;c&gt;true&lt;/c&gt; if [allow empty]; otherwise, &lt;c&gt;false&lt;/c&gt;.&lt;/value&gt; private bool AllowEmpty &#123; get; set; &#125; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref=&quot;DateTimeValidator&quot;/&gt; class. /// &lt;/summary&gt; /// &lt;param name=&quot;allowEmpty&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [allow empty].&lt;/param&gt; public DateTimeValidator(bool allowEmpty) : base(&quot;型別錯誤&quot;) &#123; this.AllowEmpty = allowEmpty; &#125; /// &lt;summary&gt; /// Returns true if ... is valid. /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;The context.&lt;/param&gt; /// &lt;returns&gt; /// &lt;c&gt;true&lt;/c&gt; if the specified context is valid; otherwise, &lt;c&gt;false&lt;/c&gt;. /// &lt;/returns&gt; protected override bool IsValid(PropertyValidatorContext context) &#123; var propertyValue = context.PropertyValue as string; if (this.AllowEmpty &amp;&amp; string.IsNullOrWhiteSpace(propertyValue)) &#123; return true; &#125; int value; bool result = int.TryParse(propertyValue, out value); //TimeStamp if (result &amp;&amp; value &gt; 0) &#123; return true; &#125; DateTime dateTimeValue; return DateTime.TryParse(propertyValue, out dateTimeValue); &#125; &#125; 擴充方法```csharp/// /// 是 DateTime 型別 or TimeStamp . /// /// /// The type of the t property. /// The rule builder. /// IRuleBuilderOptions&lt;T, TProperty&gt;. public static IRuleBuilderOptions&lt;T, TProperty&gt; IsDateTimeOrTimeStamp&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) { return ruleBuilder.SetValidator(new DateTimeValidator(allowEmpty: false)); } /// &lt;summary&gt; /// 是 DateTime 型別 or TimeStamp, 但允許 String.Empty. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the t property.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;returns&gt;IRuleBuilderOptions&amp;lt;T, TProperty&amp;gt;.&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsDateTimeOrTimeStampAllowEmpty&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) &#123; return ruleBuilder.SetValidator(new DateTimeValidator(allowEmpty: true)); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061* **&lt;span style&#x3D;&quot;color: #073763;&quot;&gt;驗證是否為GUID Array &lt;&#x2F;span&gt;** &#96;&#96;&#96;csharp&#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 驗證是否為GUID Array &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public class GUIDArrayValidator : PropertyValidator &#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 是否允許字串參數為空白. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;value&gt;&lt;c&gt;true&lt;&#x2F;c&gt; if [allow empty]; otherwise, &lt;c&gt;false&lt;&#x2F;c&gt;.&lt;&#x2F;value&gt; private bool AllowEmpty &#123; get; set; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; Initializes a new instance of the &lt;see cref&#x3D;&quot;GUIDArrayValidator&quot;&#x2F;&gt; class. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;allowEmpty&quot;&gt;if set to &lt;c&gt;true&lt;&#x2F;c&gt; [allow empty].&lt;&#x2F;param&gt; public GUIDArrayValidator( bool allowEmpty &#x3D; false) :base(&quot;傳入參數錯誤。&quot;) &#123; this.AllowEmpty &#x3D; allowEmpty; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; Returns true if ... is valid. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;context&quot;&gt;The context.&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt; &#x2F;&#x2F;&#x2F; &lt;c&gt;true&lt;&#x2F;c&gt; if the specified context is valid; otherwise, &lt;c&gt;false&lt;&#x2F;c&gt;. &#x2F;&#x2F;&#x2F; &lt;&#x2F;returns&gt; protected override bool IsValid(PropertyValidatorContext context) &#123; var propertyValue &#x3D; context.PropertyValue as List&lt;string&gt;; if (AllowEmpty &amp;&amp; (propertyValue &#x3D;&#x3D; null || propertyValue.Count &#x3D;&#x3D; 0)) &#123; return true; &#125; if (!AllowEmpty &amp;&amp; (propertyValue &#x3D;&#x3D; null || propertyValue.Count &#x3D;&#x3D; 0)) &#123; return false; &#125; Guid guid; foreach (var item in propertyValue) &#123; if (!Guid.TryParse(item, out guid)) &#123; return false; &#125; &#125; return true; &#125; &#125; 擴充方法```csharp/// /// 是 Guid Array, 但允許空集合. /// /// /// The type of the t property. /// The rule builder. /// IRuleBuilderOptions&lt;T, TProperty&gt;. public static IRuleBuilderOptions&lt;T, TProperty&gt; IsGUIDArrayAllowEmpty&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) { return ruleBuilder.SetValidator(new GUIDArrayValidator(allowEmpty: true)); } /// &lt;summary&gt; /// 是 Guid Array. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the t property.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;returns&gt;IRuleBuilderOptions&amp;lt;T, TProperty&amp;gt;.&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsGUIDArray&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) &#123; return ruleBuilder.SetValidator(new GUIDArrayValidator(allowEmpty: false)); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051* **&lt;span style&#x3D;&quot;color: #073763;&quot;&gt;驗證是否為數字 &lt;&#x2F;span&gt;** &#96;&#96;&#96;csharp&#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 驗證是否為Integer &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;seealso cref&#x3D;&quot;FluentValidation.Validators.PropertyValidator&quot; &#x2F;&gt; public class IntegerValidator : PropertyValidator &#123; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 是否允許字串參數為空白. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;value&gt;&lt;c&gt;true&lt;&#x2F;c&gt; if [allow empty]; otherwise, &lt;c&gt;false&lt;&#x2F;c&gt;.&lt;&#x2F;value&gt; private bool AllowEmpty &#123; get; set; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; Initializes a new instance of the &lt;see cref&#x3D;&quot;IntegerValidator&quot;&#x2F;&gt; class. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;allowEmpty&quot;&gt;if set to &lt;c&gt;true&lt;&#x2F;c&gt; [allow empty].&lt;&#x2F;param&gt; public IntegerValidator(bool allowEmpty &#x3D; false) : base(&quot;型別錯誤&quot;) &#123; this.AllowEmpty &#x3D; allowEmpty; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; Returns true if ... is valid. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;context&quot;&gt;The context.&lt;&#x2F;param&gt; &#x2F;&#x2F;&#x2F; &lt;returns&gt; &#x2F;&#x2F;&#x2F; &lt;c&gt;true&lt;&#x2F;c&gt; if the specified context is valid; otherwise, &lt;c&gt;false&lt;&#x2F;c&gt;. &#x2F;&#x2F;&#x2F; &lt;&#x2F;returns&gt; &#x2F;&#x2F;&#x2F; &lt;exception cref&#x3D;&quot;NotImplementedException&quot;&gt;&lt;&#x2F;exception&gt; protected override bool IsValid(PropertyValidatorContext context) &#123; var propertyValue &#x3D; context.PropertyValue as string; if (this.AllowEmpty &amp;&amp; string.IsNullOrWhiteSpace(propertyValue)) &#123; return true; &#125; int value; bool result &#x3D; int.TryParse(propertyValue, out value); return result; &#125; &#125; 擴充方法```csharp/// /// 是 Integer 型別. /// /// /// The type of the t property. /// The rule builder. /// IRuleBuilderOptions&lt;T, TProperty&gt;. public static IRuleBuilderOptions&lt;T, TProperty&gt; IsInteger&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) { return ruleBuilder.SetValidator(new IntegerValidator(allowEmpty: false)); } /// &lt;summary&gt; /// 是 Integer 型別, 但允許 String.Empty. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the t property.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;returns&gt;IRuleBuilderOptions&amp;lt;T, TProperty&amp;gt;.&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsIntegerAllowEmpty&lt;T, TProperty&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) &#123; return ruleBuilder.SetValidator(new IntegerValidator(allowEmpty: true)); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778* **&lt;span style&#x3D;&quot;color: #073763;&quot;&gt;檢查數字是否在要求範圍內 &lt;&#x2F;span&gt;** &#96;&#96;&#96;csharp&#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 驗證數字是否在範圍內 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TNumeric&quot;&gt;The type of the numeric.&lt;&#x2F;typeparam&gt; &#x2F;&#x2F;&#x2F; &lt;seealso cref&#x3D;&quot;FluentValidation.Validators.PropertyValidator&quot; &#x2F;&gt; public class NumericBetweenInValidator&lt;TNumeric&gt; : PropertyValidator where TNumeric : IComparable &#123; private TNumeric compareValueUp; private TNumeric compareValueDown; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 是否允許字串參數為空白. &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; &#x2F;&#x2F;&#x2F; &lt;value&gt;&lt;c&gt;true&lt;&#x2F;c&gt; if [allow empty]; otherwise, &lt;c&gt;false&lt;&#x2F;c&gt;.&lt;&#x2F;value&gt; private bool AllowEmpty &#123; get; set; &#125; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 轉型是否成功 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; private bool IsConvertable; &#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; 是否允許等於輸入的上下閥值值 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; private bool AllowEquals; public NumericBetweenInValidator( string valueUp, string valueDown, bool allowEquals &#x3D; false, bool allowEmpty &#x3D; false) : base(&quot;傳入參數錯誤。&quot;) &#123; this.compareValueUp &#x3D; ConvertHelper.ToT&lt;TNumeric&gt;(valueUp, out IsConvertable); this.compareValueDown &#x3D; ConvertHelper.ToT&lt;TNumeric&gt;(valueDown, out IsConvertable); this.AllowEquals &#x3D; allowEquals; this.AllowEmpty &#x3D; allowEmpty; &#125; protected override bool IsValid(PropertyValidatorContext context) &#123; var propertyValue &#x3D; context.PropertyValue as string; if (this.AllowEmpty &amp;&amp; string.IsNullOrWhiteSpace(propertyValue)) &#123; return true; &#125; var value &#x3D; ConvertHelper.ToT&lt;TNumeric&gt;(propertyValue, out IsConvertable); if (!IsConvertable) &#123; return false; &#125; &#x2F;&#x2F; -1 value &lt; compareValue &#x2F;&#x2F; 0 value &#x3D; compareValue &#x2F;&#x2F; 1 value &gt; compareValue if (AllowEquals) &#123; return value.CompareTo(compareValueDown) &gt;&#x3D; 0 &amp;&amp; value.CompareTo(compareValueUp) &lt;&#x3D; 0; &#125; return value.CompareTo(compareValueDown) &gt; 0 &amp;&amp; value.CompareTo(compareValueUp) &lt; 0; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// &lt;summary&gt; /// Class ConvertHelper /// &lt;/summary&gt; internal static class ConvertHelper &#123; /// &lt;summary&gt; /// 轉型成 T. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; /// &lt;exception cref=&quot;System.ArgumentException&quot;&gt;Convert fail.;Convert&lt;/exception&gt; public static T ToT&lt;T&gt;(string value, out bool result) where T : IComparable &#123; result = false; try &#123; switch (Type.GetTypeCode(typeof(T))) &#123; case TypeCode.Double: double doubleValue; if (double.TryParse(value, out doubleValue)) &#123; result = true; &#125; return (T)(object)Convert.ToDouble(value); case TypeCode.Int16: Int16 int16Value; if (Int16.TryParse(value, out int16Value)) &#123; result = true; &#125; return (T)(object)Convert.ToInt16(value); case TypeCode.Int32: Int32 int32Value; if (Int32.TryParse(value, out int32Value)) &#123; result = true; &#125; return (T)(object)Convert.ToInt32(value); case TypeCode.Int64: Int64 int64Value; if (Int64.TryParse(value, out int64Value)) &#123; result = true; &#125; return (T)(object)Convert.ToInt64(value); case TypeCode.Decimal: decimal decimalValue; if (decimal.TryParse(value, out decimalValue)) &#123; result = true; &#125; return (T)(object)Convert.ToDecimal(value); default: return default(T); &#125; &#125; catch (Exception ex) &#123; return default(T); &#125; &#125; &#125; 擴充方法```csharp/// /// 符合數字區間,但允許空值. /// EX : (1 &lt; x &lt; 3) /// /// /// The type of the property. /// The type of the numeric. /// The rule builder. /// Up threshold. /// Down threshold. /// public static IRuleBuilderOptions&lt;T, TProperty&gt; IsNumericAllowEmptyOrBetweenOf&lt;T, TProperty, TNumeric&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder, string upThreshold, string downThreshold) where TNumeric : IComparable { return ruleBuilder.SetValidator( new NumericBetweenInValidator( upThreshold, downThreshold, allowEquals: false, allowEmpty: true)); } /// &lt;summary&gt; /// 符合數字區間且允許等於閥值,但允許空值. /// &lt;para&gt;EX : (1 &amp;lt;= x &amp;lt;= 3) &lt;/para&gt; /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the property.&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TNumeric&quot;&gt;The type of the numeric.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;param name=&quot;upThreshold&quot;&gt;Up threshold.&lt;/param&gt; /// &lt;param name=&quot;downThreshold&quot;&gt;Down threshold.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsNumericAllowEmptyOrBetweenOfAllowEquals&lt;T, TProperty, TNumeric&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder, string upThreshold, string downThreshold) where TNumeric : IComparable &#123; return ruleBuilder.SetValidator( new NumericBetweenInValidator&lt;TNumeric&gt;( upThreshold, downThreshold, allowEquals: true, allowEmpty: true)); &#125; /// &lt;summary&gt; /// 符合數字區間. /// &lt;para&gt;EX : (1 &amp;lt; x &amp;lt; 3) &lt;/para&gt; /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the property.&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TNumeric&quot;&gt;The type of the numeric.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;param name=&quot;upThreshold&quot;&gt;Up threshold.&lt;/param&gt; /// &lt;param name=&quot;downThreshold&quot;&gt;Down threshold.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsNumericBetweenOf&lt;T, TProperty, TNumeric&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder, string upThreshold, string downThreshold) where TNumeric : IComparable &#123; return ruleBuilder.SetValidator( new NumericBetweenInValidator&lt;TNumeric&gt;( upThreshold, downThreshold, allowEquals: false, allowEmpty: false)); &#125; /// &lt;summary&gt; /// 符合數字區間且允許等於閥值 /// &lt;para&gt;EX : (1 &amp;lt;= x &amp;lt;= 3) &lt;/para&gt; /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the property.&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TNumeric&quot;&gt;The type of the numeric.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;param name=&quot;upThreshold&quot;&gt;Up threshold.&lt;/param&gt; /// &lt;param name=&quot;downThreshold&quot;&gt;Down threshold.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsNumericBetweenOfAllowEquals&lt;T, TProperty, TNumeric&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder, string upThreshold, string downThreshold) where TNumeric : IComparable &#123; return ruleBuilder.SetValidator( new NumericBetweenInValidator&lt;TNumeric&gt;( upThreshold, downThreshold, allowEquals: true, allowEmpty: false)); &#125; 123456789使用方法 &#96;&#96;&#96;csharp&#x2F;&#x2F;OrderBy - 允許空值或(0、1)this.RuleFor(x &#x3D;&gt; x.OrderBy) .NotNumericAllowEmptyOrBetweenOfAllowEquals&lt;GetBuildingDealCaseParameter, string, int&gt;( &quot;2&quot;, &quot;1&quot;) .WithErrorCode(&quot;X400&quot;) .WithMessage(&quot;OrderBy應該在1~2之間&quot;); 驗證是否為數字Array 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/// &lt;summary&gt; /// 驗證是否為數字 Array /// &lt;/summary&gt; /// &lt;seealso cref=&quot;FluentValidation.Validators.PropertyValidator&quot; /&gt; public class NumericArrayValidator&lt;TNumeric&gt; : PropertyValidator where TNumeric : IComparable &#123; /// &lt;summary&gt; /// 是否允許Array為Null或空集合. /// &lt;/summary&gt; /// &lt;value&gt; /// &lt;c&gt;true&lt;/c&gt; if [allow empty]; otherwise, &lt;c&gt;false&lt;/c&gt;. /// &lt;/value&gt; private bool AllowEmpty &#123; get; set; &#125; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref=&quot;NumericArrayValidator&#123;TNumeric&#125;&quot;/&gt; class. /// &lt;/summary&gt; /// &lt;param name=&quot;allowEmpty&quot;&gt;if set to &lt;c&gt;true&lt;/c&gt; [allow empty].&lt;/param&gt; public NumericArrayValidator(bool allowEmpty) : base(&quot;型別錯誤&quot;) &#123; this.AllowEmpty = allowEmpty; &#125; /// &lt;summary&gt; /// Returns true if ... is valid. /// &lt;/summary&gt; /// &lt;param name=&quot;context&quot;&gt;The context.&lt;/param&gt; /// &lt;returns&gt; /// &lt;c&gt;true&lt;/c&gt; if the specified context is valid; otherwise, &lt;c&gt;false&lt;/c&gt;. /// &lt;/returns&gt; protected override bool IsValid(PropertyValidatorContext context) &#123; var propertyValue = context.PropertyValue as List&lt;string&gt;; if (this.AllowEmpty &amp;&amp; (propertyValue == null || propertyValue.Count == 0)) &#123; return true; &#125; //不允許空集合或Null if (!this.AllowEmpty &amp;&amp; (propertyValue == null || propertyValue.Count == 0)) &#123; return false; &#125; bool IsConvertable; foreach (var x in propertyValue) &#123; ConvertHelper.ToT&lt;TNumeric&gt;(x, out IsConvertable); if (!IsConvertable) &#123; return false; &#125; &#125; return true; &#125; &#125; 擴充方法*```csharp/// /// 是數字 Array,但允許空陣列或Null. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the property.&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TNumeric&quot;&gt;The type of the numeric.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsNumericArrayAllowEmpty&lt;T, TProperty, TNumeric&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) where TNumeric : IComparable &#123; return ruleBuilder.SetValidator( new NumericArrayValidator&lt;TNumeric&gt;(allowEmpty: true)); &#125; /// &lt;summary&gt; /// 是數字 Array. /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TProperty&quot;&gt;The type of the property.&lt;/typeparam&gt; /// &lt;typeparam name=&quot;TNumeric&quot;&gt;The type of the numeric.&lt;/typeparam&gt; /// &lt;param name=&quot;ruleBuilder&quot;&gt;The rule builder.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IRuleBuilderOptions&lt;T, TProperty&gt; IsNumericArray&lt;T, TProperty, TNumeric&gt;( this IRuleBuilder&lt;T, TProperty&gt; ruleBuilder) where TNumeric : IComparable &#123; return ruleBuilder.SetValidator( new NumericArrayValidator&lt;TNumeric&gt;(allowEmpty: false)); &#125;","categories":[],"tags":[{"name":"FluentValidation","slug":"FluentValidation","permalink":"https://toyo0103.github.io/tags/FluentValidation/"}]},{"title":"【四元樹】透過四元樹搜尋範圍內的座標","slug":"【四元樹】透過四元樹搜尋範圍內的座標","date":"2016-09-26T06:52:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2016/09/26/【四元樹】透過四元樹搜尋範圍內的座標/","link":"","permalink":"https://toyo0103.github.io/2016/09/26/%E3%80%90%E5%9B%9B%E5%85%83%E6%A8%B9%E3%80%91%E9%80%8F%E9%81%8E%E5%9B%9B%E5%85%83%E6%A8%B9%E6%90%9C%E5%B0%8B%E7%AF%84%E5%9C%8D%E5%85%A7%E7%9A%84%E5%BA%A7%E6%A8%99/","excerpt":"","text":"將之前四元樹的程式改良後寫成筆記，之後用到才不會忘記 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/// &lt;summary&gt; /// Class QuadTreeNode. /// &lt;/summary&gt; public class QuadTreeNode&lt;T&gt; where T : IQuadTreeNodeData &#123; /// &lt;summary&gt; /// 西北象限. /// &lt;/summary&gt; /// &lt;value&gt; /// The north west. /// &lt;/value&gt; public QuadTreeNode&lt;T&gt; NorthWest &#123; get; set; &#125; /// &lt;summary&gt; /// 東北象限. /// &lt;/summary&gt; /// &lt;value&gt; /// The north east. /// &lt;/value&gt; public QuadTreeNode&lt;T&gt; NorthEast &#123; get; set; &#125; /// &lt;summary&gt; /// 西南象限. /// &lt;/summary&gt; /// &lt;value&gt; /// The south west. /// &lt;/value&gt; public QuadTreeNode&lt;T&gt; SouthWest &#123; get; set; &#125; /// &lt;summary&gt; /// 東南象限. /// &lt;/summary&gt; /// &lt;value&gt; /// The south east. /// &lt;/value&gt; public QuadTreeNode&lt;T&gt; SouthEast &#123; get; set; &#125; /// &lt;summary&gt; /// 邊界 /// &lt;/summary&gt; public BoundingBox BoundingBox &#123; get; set; &#125; /// &lt;summary&gt; /// 節點數量 /// &lt;/summary&gt; public int BucketCapacity &#123; get; set; &#125; /// &lt;summary&gt; /// 節點 /// &lt;/summary&gt; public List&lt;T&gt; Points &#123; get; set; &#125; /// &lt;summary&gt; /// Initializes a new instance of the &lt;see cref=&quot;QuadTreeNode&#123;T&#125;&quot;/&gt; class. /// &lt;/summary&gt; /// &lt;param name=&quot;boundingBox&quot;&gt;The bounding box.&lt;/param&gt; /// &lt;param name=&quot;capacity&quot;&gt;The capacity.&lt;/param&gt; public QuadTreeNode(BoundingBox boundingBox, int capacity) &#123; BoundingBox = boundingBox; BucketCapacity = capacity; Points = new List&lt;T&gt;(); &#125; &#125; 要使用四元樹，就要將資料結點實作這個介面 1234567891011121314/// &amp;lt;summary&amp;gt; /// Interface IQuadTreeNodeData. /// &amp;lt;/summary&amp;gt; public interface IQuadTreeNodeData &#123; /// &amp;lt;summary&amp;gt; /// Gets or sets the position. /// &amp;lt;/summary&amp;gt; /// &amp;lt;value&amp;gt; /// The position. /// &amp;lt;/value&amp;gt; Coordinate Position &#123; get; set; &#125; &#125; 要搜尋範圍的DTO 12345678910111213141516/// &lt;summary&gt; /// Class BoundingBox. /// &lt;/summary&gt; public class BoundingBox &#123; /// &lt;summary&gt; /// 左上角節點 /// &lt;/summary&gt; public Coordinate LeftTop &#123; get; set; &#125; /// &lt;summary&gt; /// 右下角節點 /// &lt;/summary&gt; public Coordinate RightBottom &#123; get; set; &#125; &#125; 123456789101112131415/// &lt;summary&gt; /// Class Coordinate. /// &lt;/summary&gt; public class Coordinate &#123; /// &lt;summary&gt; /// 緯度 /// &lt;/summary&gt; public double Latitude &#123; get; set; &#125; /// &lt;summary&gt; /// 經度 /// &lt;/summary&gt; public double Longitude &#123; get; set; &#125; &#125; 四元樹搜尋邏輯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277/// &lt;summary&gt; /// Class QuadTreeService. /// &lt;/summary&gt; public static class QuadTreeService &#123; /// &lt;summary&gt; /// Inserts the specified node. /// &lt;/summary&gt; /// &lt;param name=&quot;node&quot;&gt;The node.&lt;/param&gt; /// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool Insert&lt;T&gt;(QuadTreeNode&lt;T&gt; node, T data) where T : IQuadTreeNodeData &#123; // Bail if our coordinate is not in the boundingBox if (!CheckBoundingBoxContainData(node.BoundingBox, data)) &#123; return false; &#125; // Add the coordinate to the points array if ((node.Points.Count + 1) &lt;= node.BucketCapacity) &#123; node.Points.Add(data); return true; &#125; // Check to see if the current node is a leaf, if it is, split if (node.NorthWest == null) &#123; Subdivide(node); &#125; // Traverse the tree if (Insert(node.NorthWest, data)) return true; if (Insert(node.NorthEast, data)) return true; if (Insert(node.SouthWest, data)) return true; if (Insert(node.SouthEast, data)) return true; return false; &#125; /// &lt;summary&gt; /// 搜尋在範圍內的所有節點 /// &lt;/summary&gt; /// &lt;param name=&quot;node&quot;&gt;四元樹節點&lt;/param&gt; /// &lt;param name=&quot;range&quot;&gt;範圍&lt;/param&gt; /// &lt;param name=&quot;datas&quot;&gt;&lt;/param&gt; public static void SearchDataInRange&lt;T&gt;( QuadTreeNode&lt;T&gt; node, BoundingBox range, ref List&lt;T&gt; datas) where T : IQuadTreeNodeData &#123; //如果QuadTree完全在要搜尋的Range之內， //那包含在它底下的分裂節點都不用判斷,一定全部都在範圍內 if (CheckBoundingBoxIncludeInRange(node.BoundingBox, range)) &#123; GetNodeAllPointData(node, ref datas); return; &#125; // If range is not contained in the node&#x27;s boundingBox then bail if (!CheckIntersectionBoundingBox(node.BoundingBox, range)) &#123; return; &#125; foreach (var item in node.Points) &#123; // Gather points contained in range if (CheckBoundingBoxContainData(range, item)) &#123; datas.Add(item); &#125; &#125; // Bail if node is leaf if (node.NorthWest == null) &#123; return; &#125; // Otherwise traverse down the tree SearchDataInRange(node.NorthWest, range, ref datas); SearchDataInRange(node.NorthEast, range, ref datas); SearchDataInRange(node.SouthWest, range, ref datas); SearchDataInRange(node.SouthEast, range, ref datas); &#125; /// &lt;summary&gt; /// 建立四元樹. /// &lt;/summary&gt; /// &lt;param name=&quot;data&quot;&gt;The data.&lt;/param&gt; /// &lt;param name=&quot;boundingBox&quot;&gt;QuadTree Bounding&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static QuadTreeNode&lt;T&gt; CreateQuadTree&lt;T&gt;(List&lt;T&gt; data, BoundingBox boundingBox) where T : IQuadTreeNodeData &#123; var TreeNode = new QuadTreeNode&lt;T&gt;( boundingBox: boundingBox, capacity: 1); foreach (var d in data) &#123; Insert(TreeNode, d); &#125; return TreeNode; &#125; /// &lt;summary&gt; /// 取得節點以及所有子節點的Point Data /// &lt;/summary&gt; /// &lt;param name=&quot;node&quot;&gt;The node.&lt;/param&gt; /// &lt;param name=&quot;datas&quot;&gt;The datas.&lt;/param&gt; static void GetNodeAllPointData&lt;T&gt;(QuadTreeNode&lt;T&gt; node, ref List&lt;T&gt; datas) where T : IQuadTreeNodeData &#123; datas.AddRange(node.Points); if (node.NorthWest == null) &#123; return; &#125; GetNodeAllPointData(node.NorthWest, ref datas); GetNodeAllPointData(node.NorthEast, ref datas); GetNodeAllPointData(node.SouthWest, ref datas); GetNodeAllPointData(node.SouthEast, ref datas); &#125; /// &lt;summary&gt; /// 確認兩個區域是否有交集 /// &lt;/summary&gt; /// &lt;param name=&quot;BoundingBox&quot;&gt;The bounding box.&lt;/param&gt; /// &lt;param name=&quot;range&quot;&gt;The range.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool CheckIntersectionBoundingBox(BoundingBox BoundingBox, BoundingBox range) &#123; if (BoundingBox.LeftTop.Latitude.ToString() == BoundingBox.RightBottom.Latitude.ToString() &amp;&amp; BoundingBox.LeftTop.Longitude.ToString() == BoundingBox.RightBottom.Longitude.ToString()) &#123; //Point var Lng = range.LeftTop.Longitude &lt;= BoundingBox.LeftTop.Longitude &amp;&amp; BoundingBox.LeftTop.Longitude &lt;= range.RightBottom.Longitude; var Lat = range.RightBottom.Latitude &lt;= BoundingBox.LeftTop.Latitude &amp;&amp; BoundingBox.LeftTop.Latitude &lt;= range.LeftTop.Latitude; return Lng &amp;&amp; Lat; &#125; else &#123; var MinCx = Math.Max(range.LeftTop.Longitude, BoundingBox.LeftTop.Longitude); var MaxCy = Math.Min(range.LeftTop.Latitude, BoundingBox.LeftTop.Latitude); var MaxCx = Math.Min(range.RightBottom.Longitude, BoundingBox.RightBottom.Longitude); var MinCy = Math.Max(range.RightBottom.Latitude, BoundingBox.RightBottom.Latitude); return (MinCx &lt; MaxCx) &amp;&amp; (MinCy &lt; MaxCy); &#125; &#125; /// &lt;summary&gt; /// 確認BoundingBox是否完全包含在要搜尋的區域範圍內(小於等於). /// &lt;/summary&gt; /// &lt;param name=&quot;BoundingBox&quot;&gt;The bounding box.&lt;/param&gt; /// &lt;param name=&quot;range&quot;&gt;The range.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static bool CheckBoundingBoxIncludeInRange(BoundingBox BoundingBox, BoundingBox range) &#123; var LTLng = (range.LeftTop.Longitude &lt;= BoundingBox.LeftTop.Longitude &amp;&amp; BoundingBox.LeftTop.Longitude &lt;= range.RightBottom.Longitude); var LTLat = (range.RightBottom.Latitude &lt;= BoundingBox.LeftTop.Latitude &amp;&amp; BoundingBox.LeftTop.Latitude &lt;= range.LeftTop.Latitude); var RBLng = (range.LeftTop.Longitude &lt;= BoundingBox.RightBottom.Longitude &amp;&amp; BoundingBox.RightBottom.Longitude &lt;= range.RightBottom.Longitude); var RBLat = (range.RightBottom.Latitude &lt;= BoundingBox.RightBottom.Latitude &amp;&amp; BoundingBox.RightBottom.Latitude &lt;= range.LeftTop.Latitude); return LTLng &amp;&amp; LTLat &amp;&amp; RBLng &amp;&amp; RBLat; &#125; static bool CheckBoundingBoxContainData(BoundingBox boundingBox, IQuadTreeNodeData data) &#123; var CheckLng = (boundingBox.LeftTop.Longitude &lt;= data.Position.Longitude &amp;&amp; data.Position.Longitude &lt;= boundingBox.RightBottom.Longitude); var CheckLat = (boundingBox.RightBottom.Latitude &lt;= data.Position.Latitude &amp;&amp; data.Position.Latitude &lt;= boundingBox.LeftTop.Latitude); return CheckLng &amp;&amp; CheckLat; &#125; /// &lt;summary&gt; /// 四元樹分裂 /// &lt;/summary&gt; /// &lt;param name=&quot;node&quot;&gt;四元樹節點&lt;/param&gt; static void Subdivide&lt;T&gt;(QuadTreeNode&lt;T&gt; node) where T:IQuadTreeNodeData &#123; var box = node.BoundingBox; //中心點 double LatMid = (box.LeftTop.Latitude + box.RightBottom.Latitude) / 2.0; double LngMid = (box.LeftTop.Longitude + box.RightBottom.Longitude) / 2.0; //左上 var NorthWest = new BoundingBox &#123; LeftTop = new Coordinate &#123; Latitude = box.LeftTop.Latitude, Longitude = box.LeftTop.Longitude &#125;, RightBottom = new Coordinate &#123; Latitude = LatMid, Longitude = LngMid &#125; &#125;; node.NorthWest = new QuadTreeNode&lt;T&gt;(NorthWest, node.BucketCapacity); //右上 var NorthEast = new BoundingBox &#123; LeftTop = new Coordinate &#123; Latitude = box.LeftTop.Latitude, Longitude = LngMid &#125;, RightBottom = new Coordinate &#123; Latitude = LatMid, Longitude = box.RightBottom.Longitude &#125; &#125;; node.NorthEast = new QuadTreeNode&lt;T&gt;(NorthEast, node.BucketCapacity); //左下 var SouthWest = new BoundingBox &#123; LeftTop = new Coordinate &#123; Latitude = LatMid, Longitude = box.LeftTop.Longitude &#125;, RightBottom = new Coordinate &#123; Latitude = box.RightBottom.Latitude, Longitude = LngMid &#125; &#125;; node.SouthWest = new QuadTreeNode&lt;T&gt;(SouthWest, node.BucketCapacity); //右下 var SouthEast = new BoundingBox &#123; LeftTop = new Coordinate &#123; Latitude = LatMid, Longitude = LngMid &#125;, RightBottom = new Coordinate &#123; Latitude = box.RightBottom.Latitude, Longitude = box.RightBottom.Longitude &#125; &#125;; node.SouthEast = new QuadTreeNode&lt;T&gt;(SouthEast, node.BucketCapacity); &#125; &#125; ————使用方法—————–**** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182void Main()&#123; Stopwatch timer = new Stopwatch(); timer.Reset(); timer.Start(); var YouWantToSearchData = new List&lt;UserQuery.YourCoordinateData&gt;(); for (int i = 0; i &lt; 5000000; i++) &#123; YouWantToSearchData.Add( new YourCoordinateData &#123; Position = new Coordinate &#123; Latitude = GetRandomNumber(22,26), Longitude = GetRandomNumber(120,122) &#125; &#125;); &#125; var QuadTree = QuadTreeService.CreateQuadTree(YouWantToSearchData,GetBoundingBox()); //建立四元樹 string.Format(&quot;建資料花了: &#123;0&#125; ticks (&#123;1&#125; msec)&quot;, timer.ElapsedTicks, timer.ElapsedMilliseconds).Dump(); //要搜尋的範圍 BoundingBox range = new BoundingBox &#123; LeftTop = new Coordinate &#123; Latitude = 24.997123, Longitude = 121.21940612793 &#125;, RightBottom = new Coordinate &#123;Latitude =24.958553314209,Longitude = 121.485925&#125; &#125;; //一般搜尋 timer.Reset(); timer.Start(); var Result1 = Search(range,YouWantToSearchData); string.Format(&quot;搜尋資料花了: &#123;0&#125; ticks (&#123;1&#125; msec)&quot;, timer.ElapsedTicks, timer.ElapsedMilliseconds).Dump(); //四元樹搜尋 timer.Reset(); timer.Start(); var Result2 = new List&lt;YourCoordinateData&gt;(); QuadTreeService.SearchDataInRange(QuadTree,range,ref Result2); string.Format(&quot;四元樹搜尋資料花了: &#123;0&#125; ticks (&#123;1&#125; msec)&quot;, timer.ElapsedTicks, timer.ElapsedMilliseconds).Dump(); string.Format(&quot;一般搜尋資料筆數: &#123;0&#125;&quot;,Result1.Count()).Dump(); string.Format(&quot;四元樹搜尋資料筆數: &#123;0&#125;&quot;,Result2.Count()).Dump();&#125;public List&lt;YourCoordinateData&gt; Search(BoundingBox range, List&lt;YourCoordinateData&gt; Datas) &#123; return Datas.Where(x =&gt; range.RightBottom.Latitude &lt;= x.Position.Latitude &amp;&amp; x.Position.Latitude &lt;= range.LeftTop.Latitude &amp;&amp; range.LeftTop.Longitude &lt;= x.Position.Longitude &amp;&amp; x.Position.Longitude &lt;= range.RightBottom.Longitude).ToList();&#125;public class YourCoordinateData : IQuadTreeNodeData &#123; public Coordinate Position&#123;get;set;&#125;&#125;//台灣的範圍public BoundingBox GetBoundingBox()&#123; return new BoundingBox &#123; //台灣範圍 LeftTop = new Coordinate &#123; Latitude = 26, Longitude = 120 &#125;, RightBottom = new Coordinate &#123; Latitude = 22, Longitude = 122 &#125; &#125;;&#125;//隨機取得經緯度亂數static Random random = new Random();public static double GetRandomNumber(double minimum, double maximum)&#123; return random.NextDouble() * (maximum - minimum) + minimum;&#125; 分別實驗了10萬筆與500萬筆的搜尋數據，當然筆數擴張的越大，這個數據差距會越大 [![](https://3.bp.blogspot.com/-ZxXLvUMEaU8/V-jEmww86II/AAAAAAAAH98/12-o58aYKrcsVPIi6iPjGxEbt8ngHFFvwCLcB/s1600/1.png)](https://3.bp.blogspot.com/-ZxXLvUMEaU8/V-jEmww86II/AAAAAAAAH98/12-o58aYKrcsVPIi6iPjGxEbt8ngHFFvwCLcB/s1600/1.png)10萬筆 [![](https://2.bp.blogspot.com/-Kba3y7eAdFo/V-jFYZ5hXoI/AAAAAAAAH-I/_Mk3UU4NCII26OC6RqXubc5SdEkAMawogCLcB/s1600/2.png)](https://2.bp.blogspot.com/-Kba3y7eAdFo/V-jFYZ5hXoI/AAAAAAAAH-I/_Mk3UU4NCII26OC6RqXubc5SdEkAMawogCLcB/s1600/2.png)500萬筆","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"QuadTree","slug":"QuadTree","permalink":"https://toyo0103.github.io/tags/QuadTree/"}]},{"title":"【重構系列】(三) 單一職責原則(Single Responsibility Principle , SRP)","slug":"【重構系列】-三-單一職責原則-Single-Responsibility-Principle-SRP","date":"2016-08-18T03:16:00.000Z","updated":"2022-08-09T13:36:17.097Z","comments":true,"path":"2016/08/18/【重構系列】-三-單一職責原則-Single-Responsibility-Principle-SRP/","link":"","permalink":"https://toyo0103.github.io/2016/08/18/%E3%80%90%E9%87%8D%E6%A7%8B%E7%B3%BB%E5%88%97%E3%80%91-%E4%B8%89-%E5%96%AE%E4%B8%80%E8%81%B7%E8%B2%AC%E5%8E%9F%E5%89%87-Single-Responsibility-Principle-SRP/","excerpt":"","text":"SourceCode :&nbsp;https://github.com/toyo0103/Demo_EditTemplate_1 這邊提供幾篇覺得很棒的文章，看完其實也可以略過這篇了XD &nbsp;1.&nbsp;30天快速上手 TDD Day 12 - Refactoring - 職責分離 &nbsp;By 91 &nbsp;2. [ASP.NET]91之ASP.NET由淺入深 不負責講座 Day17 – 單一職責原則 &nbsp;3.&nbsp;Clean code: 無瑕的程式碼 – 書摘心得（二） 好的!!誠如上面幾篇文章提到的，我對於SRP的理解是「每個類別應該都只有一個理由被修改」。 其實看起來很簡單但卻又抽象到頭痛，之前寫程式時常常為了分離程式碼而頭痛不已，不可否認的是，全部寫成一起在開發上又快又方便，但這其實無形中堆高了技術債，為了在改動需求或修改程式時，要嘛就從頭看到尾找出其中的一兩行改，要嘛就是乾脆重寫，因為互相綁得太死了，牽一髮動全身阿(遠目) [![](https://2.bp.blogspot.com/-cYpekfGnPkg/V7UdvdmnldI/AAAAAAAAH84/MR0-YMqszPUeIoiFGPID_Tmx_ERoWnO0wCLcB/s320/srp.jpg)](https://2.bp.blogspot.com/-cYpekfGnPkg/V7UdvdmnldI/AAAAAAAAH84/MR0-YMqszPUeIoiFGPID_Tmx_ERoWnO0wCLcB/s1600/srp.jpg)如果想在這萬能的瑞士刀加上一個新型刀片，除了重做一個更長的基座，似乎無解阿.... 一、分析 讓我們來看看原本的程式中哪邊明顯的沒有單一職責? ****Application層****傳入Channel ID,透過IPOISerice取得對應的POI資料並且回傳資料，看起來職責非常明確 123456789101112131415161718public class HomeController : Controller &#123; IPOIService _POIService; public HomeController(IPOIService poiService) &#123; //POIService改成依賴介面IPOIService //並且實體是由外部來決定，也就是所謂的依賴注入DI _POIService = poiService; &#125; public ActionResult Index(string id) &#123; //依賴外部注入的IPOIService介面 var POIs = _POIService.Get(id); return Json(POIs,JsonRequestBehavior.AllowGet); &#125; &#125; Repository層 看起來兩個供應商的Repository也都恰如其分的只撈自己所屬的資料，職責明確，要改哪個供應商撈資料的方式，打開對應的Repository檔案即可，腎好腎好 (難道肝不好嗎?)**** 1234567891011121314151617181920/// &lt;summary&gt; /// POI A供應商 /// &lt;/summary&gt; internal class ASupplierRepository : ISupplierRepository &#123; public List&lt;POI&gt; Get() &#123; Random rnd = new Random(); //隨機建立十筆Supplier為A的資料回傳 var fixture = new Fixture(); var Result = fixture.Build&lt;POI&gt;() .With(x =&gt; x.Name, string.Concat(&quot;捷運&quot;, rnd.Next(1, 100))) .With(x =&gt; x.Supplier, SupplierEnum.A) .CreateMany().ToList(); return Result; &#125; &#125; 1234567891011121314151617181920/// &lt;summary&gt; /// POI B供應商 /// &lt;/summary&gt; internal class BSupplierRepository : ISupplierRepository &#123; public List&lt;POI&gt; Get() &#123; Random rnd = new Random(); //隨機建立十筆Supplier為B的資料回傳 var fixture = new Fixture(); var Result = fixture.Build&lt;POI&gt;() .With(x =&gt; x.Name, string.Concat(&quot;捷運&quot;, rnd.Next(1, 100))) .With(x =&gt; x.Supplier, SupplierEnum.B) .CreateMany().ToList(); return Result; &#125; &#125; ** **Service層** ** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class POIService :IPOIService &#123; public List&lt;POI&gt; Get(string channelID) &#123; var Result = new List&lt;POI&gt;(); var channel = GetChannel(channelID); //逐一搜尋頻道底下的各類別 foreach (var category in channel.Categorys) &#123; //依據該類別所指定的供應商向Repository要資料 category.Supplier.ForEach(x =&gt; &#123; var Repository = SupplierFactory.Generate(x); var POIs = Repository.Get(); Result.AddRange(POIs); &#125;); &#125; //並接總合的結果回傳 return Result; &#125; /// &lt;summary&gt; /// 模擬頻道類別對應表 /// &lt;/summary&gt; /// &lt;param name=&quot;channelID&quot;&gt;The channel identifier.&lt;/param&gt; /// &lt;returns&gt;Channel.&lt;/returns&gt; Channel GetChannel(string channelID) &#123; if (channelID == &quot;1&quot;) &#123; return new Channel &#123; ID = &quot;1&quot;, Categorys = new List&lt;Channel.Category&gt; &#123; new Channel.Category &#123; Name = &quot;交通&quot;, Supplier =new List&lt;SupplierEnum&gt; &#123; SupplierEnum.A &#125; &#125; &#125; &#125;; &#125; return new Channel &#123; ID = channelID, Categorys = new List&lt;Channel.Category&gt; &#123; new Channel.Category &#123; Name = &quot;交通&quot;, Supplier = new List&lt;SupplierEnum&gt; &#123; SupplierEnum.A , SupplierEnum.B &#125; &#125; &#125; &#125;; &#125; &#125; 讓我們用人話的方式說說它目前都做了啥(驚世劇場口氣)!! Get() : 傳入Channel ID,先呼叫私有方法GetChannel，取得該頻道該有的類別跟對應POI廠商表，然後依據POI廠商去跟源頭Repository要資料 GetChannel() : 傳入Channel ID，取回該頻道該有的類別與對應的POI廠商表 如果今天我要修改取POI源頭資料的邏輯，我要打開POIService修改。 如果今天我要修改取頻道與廠商的對應表邏輯，或是接上真實的DB資料，我也要打開POIService修改 對於POIService來說，它的職責已經包含兩個不同面向的事情了，所以在這邊我們要抽離取頻道與廠商的對應表邏輯到專屬負責的類別去，來符合SRP 二、重構開始 首先在**Service層**建立專屬的類別來取頻道與廠商的對應表，所以這邊建立一個**ChannelService**，然後將原本屬於POIService的邏輯搬到這邊來 12345678910111213141516171819202122232425262728293031323334353637383940public class ChannelService &#123; /// &lt;summary&gt; /// 模擬頻道類別對應表 /// &lt;/summary&gt; /// &lt;param name=&quot;channelID&quot;&gt;The channel identifier.&lt;/param&gt; /// &lt;returns&gt;Channel.&lt;/returns&gt; public Channel Get(string channelID) &#123; if (channelID == &quot;1&quot;) &#123; return new Channel &#123; ID = &quot;1&quot;, Categorys = new List&lt;Channel.Category&gt; &#123; new Channel.Category &#123; Name = &quot;交通&quot;, Supplier =new List&lt;SupplierEnum&gt; &#123; SupplierEnum.A &#125; &#125; &#125; &#125;; &#125; return new Channel &#123; ID = channelID, Categorys = new List&lt;Channel.Category&gt; &#123; new Channel.Category &#123; Name = &quot;交通&quot;, Supplier = new List&lt;SupplierEnum&gt; &#123; SupplierEnum.A , SupplierEnum.B &#125; &#125; &#125; &#125;; &#125; &#125; 把原本不該屬於POIService的程式碼刪除，改成如下 12345678910111213141516171819202122232425262728public class POIService :IPOIService &#123; public List&lt;POI&gt; Get(string channelID) &#123; var Result = new List&lt;POI&gt;(); //取得ChannelService實體，取得Channel對應供應商資料 var channelService = new ChannelService(); var channel = channelService.Get(channelID); //逐一搜尋頻道底下的各類別 foreach (var category in channel.Categorys) &#123; //依據該類別所指定的供應商向Repository要資料 category.Supplier.ForEach(x =&gt; &#123; var Repository = SupplierFactory.Generate(x); var POIs = Repository.Get(); Result.AddRange(POIs); &#125;); &#125; //並接總合的結果回傳 return Result; &#125; &#125; 接下來是不是因為達成職責分離了，所以大家可以手拉手一起去吃冰快樂的下午茶了阿。如果是的話請到旁邊面壁思過(拍掉已經牽起來的手)，**說好的高內聚低耦合呢? 說好的IOC與DI呢 ? 說好的面對抽象呢? **(左手心拍右手背) 隔離ChannelService，建立Interface [![](https://2.bp.blogspot.com/-CbLQzZGAVWA/V7Uk_BjnrQI/AAAAAAAAH9I/2X3Wh9Igf34lYISJFe19Tu2pANOaX6tUgCLcB/s1600/1.png)](https://2.bp.blogspot.com/-CbLQzZGAVWA/V7Uk_BjnrQI/AAAAAAAAH9I/2X3Wh9Igf34lYISJFe19Tu2pANOaX6tUgCLcB/s1600/1.png) 12345public interface IChannelService &#123; Channel Get(string channelID); &#125; POIService透過DI與IOC的概念，面對IChannelService而非實體 ```csharppublic class POIService :IPOIService { IChannelService _ChannelService; public POIService(IChannelService channelService) &#123; //DI _ChannelService = channelService; &#125; public List&lt;POI&gt; Get(string channelID) &#123; var Result = new List&lt;POI&gt;(); //面對抽象 var channel = _ChannelService.Get(channelID); //逐一搜尋頻道底下的各類別 foreach (var category in channel.Categorys) &#123; //依據該類別所指定的供應商向Repository要資料 category.Supplier.ForEach(x =&gt; &#123; var Repository = SupplierFactory.Generate(x); var POIs = Repository.Get(); Result.AddRange(POIs); &#125;); &#125; //並接總合的結果回傳 return Result; &#125; } ``` 別忘記到Unity把Interface與實體的關係註冊起來三、小結 看看執行的結果是否正常 [![](https://3.bp.blogspot.com/-rn9m0xATZ2A/V7Umyyoz9_I/AAAAAAAAH9U/rAETSPwprloEh1HSjPDpP3v0Cq0iAp_gACLcB/s640/1.png)](https://3.bp.blogspot.com/-rn9m0xATZ2A/V7Umyyoz9_I/AAAAAAAAH9U/rAETSPwprloEh1HSjPDpP3v0Cq0iAp_gACLcB/s1600/1.png)妥妥的阿!!! 所以這邊我們重構了Service的部分，讓它職責更為明確，而且也用了前幾篇提到的物件導向觀念，讓彼此是互相合作但是又具有高獨立性的。 如果現在真的想把取Channel的對應資料改去接DB，我們只要打開ChannelService去接對應的Repository即可，其他地方都不會動到。 如果現在是主管說Demo的時候要用假資料，正式機要接DB取真實的Channel資料，那我們只要保留原本ChannelService，另外寫一個ChannelFromDBService，然後都實做IChannelService，並且在Unity那邊做個開關動態改變註冊的實體即可 應該有漸漸感受到，物件導向對於變動這件事情的高擴展性與可維護性了，相信天下沒有不改需求的PM，所以也就不可能有不改版的軟體了阿(再次遠目) 最後記住一件事情，「別讓你的Code又臭又長」，那麼下回見啦~ [![](https://2.bp.blogspot.com/-NHl1LCbQLR0/V7UoU2H1ijI/AAAAAAAAH9g/1CJwhDpona4tNKcNlesR5HCDoruhHCvVgCLcB/s320/687474703a2f2f692e696d6775722e636f6d2f63464a6b6638692e6a7067.jpg)](https://2.bp.blogspot.com/-NHl1LCbQLR0/V7UoU2H1ijI/AAAAAAAAH9g/1CJwhDpona4tNKcNlesR5HCDoruhHCvVgCLcB/s1600/687474703a2f2f692e696d6775722e636f6d2f63464a6b6638692e6a7067.jpg)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Refactor","slug":"Refactor","permalink":"https://toyo0103.github.io/tags/Refactor/"}]},{"title":"【重構系列】(二) DI與IOC","slug":"【重構系列】-二-DI與IOC","date":"2016-08-17T08:36:00.000Z","updated":"2022-08-09T13:36:17.097Z","comments":true,"path":"2016/08/17/【重構系列】-二-DI與IOC/","link":"","permalink":"https://toyo0103.github.io/2016/08/17/%E3%80%90%E9%87%8D%E6%A7%8B%E7%B3%BB%E5%88%97%E3%80%91-%E4%BA%8C-DI%E8%88%87IOC/","excerpt":"","text":"SourceCode :&nbsp;https://github.com/toyo0103/Demo_EditTemplate_1 依據前一篇延續，接著我們把焦點放在Application與Service之間的狀況 [![](https://3.bp.blogspot.com/-urWNSzGdlp8/V7O6-tD1woI/AAAAAAAAH6w/z2GwsqBn9hANkslSqNpALNAuRiBIuuI4ACLcB/s400/1.png)](https://3.bp.blogspot.com/-urWNSzGdlp8/V7O6-tD1woI/AAAAAAAAH6w/z2GwsqBn9hANkslSqNpALNAuRiBIuuI4ACLcB/s1600/1.png) 前一篇有提到程式應該要面對**抽象**避免高耦合的情況發生，改一髮進而動全身，所以有用**介面**的方式去處理 [![](https://3.bp.blogspot.com/-O7kXIwvgtDk/V7O7kOH1D0I/AAAAAAAAH60/M49OysRZ7R4LxOLv4UNE9WJVLBBpsICJwCLcB/s400/1.png)](https://3.bp.blogspot.com/-O7kXIwvgtDk/V7O7kOH1D0I/AAAAAAAAH60/M49OysRZ7R4LxOLv4UNE9WJVLBBpsICJwCLcB/s1600/1.png) 然而來看看目前實際的程式狀況 : 直接耦合 [![](https://4.bp.blogspot.com/-csgLbuLY5Dw/V7O9BEEADYI/AAAAAAAAH7A/n6mzb9hYUiksdAHYuQmBXuH6aPO0Sk8-wCLcB/s400/1.png)](https://4.bp.blogspot.com/-csgLbuLY5Dw/V7O9BEEADYI/AAAAAAAAH7A/n6mzb9hYUiksdAHYuQmBXuH6aPO0Sk8-wCLcB/s1600/1.png) [![](https://2.bp.blogspot.com/-LkVwTAXMQHc/V7O9TcpERgI/AAAAAAAAH7I/18cwMlw6YtQxVKhppexI25lzS--gxIIagCLcB/s400/1.png)](https://2.bp.blogspot.com/-LkVwTAXMQHc/V7O9TcpERgI/AAAAAAAAH7I/18cwMlw6YtQxVKhppexI25lzS--gxIIagCLcB/s1600/1.png) 這邊會談到兩個用來解開這種狀況的觀念 依賴注入(Dependency Injection)簡稱DI **控制反轉(**Inversion Of Control)簡稱IOC 先看看Google怎麼解釋控制反轉（Inversion of Control，縮寫為IoC），是面向對象編程中的一種設計原則，可以用來減低計算機代碼之間的耦合度。其中最常見的方式叫做依賴注入（Dependency Injection，簡稱DI） 不知道看完有沒有懂的感覺XD，明明都是中文看完卻很想說「先生(小姐)可以講中文嗎?」。撇開這些專業的術語不看，我們直接開始重構來體會這兩個概念 一、重構開始 抽取介面避免直接耦合的第一步，抽取介面來隔離實體，既然這邊實際耦合了POIService，那我們就為它抽取出Interface IPOIService [![](https://3.bp.blogspot.com/-LrWsJfLH2vU/V7PAEPoqZKI/AAAAAAAAH7Y/VCUD_9YVxnEPfAzFCKpQvHY3jQRkMBD9ACLcB/s1600/1.png)](https://3.bp.blogspot.com/-LrWsJfLH2vU/V7PAEPoqZKI/AAAAAAAAH7Y/VCUD_9YVxnEPfAzFCKpQvHY3jQRkMBD9ACLcB/s1600/1.png) 12345678910public interface IPOIService &#123; /// &lt;summary&gt; /// 取得屬於頻道的POI資料 /// &lt;/summary&gt; /// &lt;param name=&quot;channelID&quot;&gt;The channel identifier.&lt;/param&gt; /// &lt;returns&gt;List&amp;lt;POI&amp;gt;.&lt;/returns&gt; List&lt;POI&gt; Get(string channelID); &#125; 將POIService掛上IPOIService [![](https://2.bp.blogspot.com/-YS5Dd3-SnX4/V7PA1QAh0ZI/AAAAAAAAH7g/Av6PbiG5yYgct0SYM1kP_n8mTQTLy0N2ACLcB/s400/1.png)](https://2.bp.blogspot.com/-YS5Dd3-SnX4/V7PA1QAh0ZI/AAAAAAAAH7g/Av6PbiG5yYgct0SYM1kP_n8mTQTLy0N2ACLcB/s1600/1.png) **讓Application依賴介面** 上一篇遇到這種狀況時，我們會做一個Factory來產生實體，並且封裝在Service層。這次我們不這麼做，改成用依賴注入(DI)的方式來實作，將IPOIService改成用建構子帶入 123456789101112131415161718public class HomeController : Controller &#123; IPOIService _POIService; public HomeController(IPOIService poiService) &#123; //POIService改成依賴介面IPOIService //並且實體是由外部來決定，也就是所謂的依賴注入DI _POIService = poiService; &#125; public ActionResult Index(string id) &#123; //依賴外部注入的IPOIService介面 var POIs = _POIService.Get(id); return Json(POIs,JsonRequestBehavior.AllowGet); &#125; &#125; 這邊用的IPOIService是由外部注入的，實體已經不由HomeController 內部來決定了(不New實體了)，也就是上面所提到的DI 依賴注入(要用的實體由建構子注入)，IOC控制反轉(實體已經由內部控制改由外部控制了) 接下來面臨的問題是，雖然我們讓實體改成用外部注入的方式，但HomeController在建立的時候是由系統去產生的，它怎麼知道IPOIService的實體是要注入誰，所以現在執行程式會看到以下結果 [![](https://4.bp.blogspot.com/-0ijdWklCbSk/V7QYVfZnz_I/AAAAAAAAH7w/Bj3Sa8cECEcTJNOsObhzWMd6vMjwUJIggCLcB/s1600/1.png)](https://4.bp.blogspot.com/-0ijdWklCbSk/V7QYVfZnz_I/AAAAAAAAH7w/Bj3Sa8cECEcTJNOsObhzWMd6vMjwUJIggCLcB/s1600/1.png) 這時候就要介紹Unity這個套件來幫我們解決這個問題了 ** **何謂Unity [![](https://1.bp.blogspot.com/-PEXphTQycyE/V7QY_Y7zGoI/AAAAAAAAH70/n8FT2stz8PQnOEXWrUSl95ilLNBrmTz1gCLcB/s400/MSUNITY.jpg)](https://1.bp.blogspot.com/-PEXphTQycyE/V7QY_Y7zGoI/AAAAAAAAH70/n8FT2stz8PQnOEXWrUSl95ilLNBrmTz1gCLcB/s1600/MSUNITY.jpg)MSDN上的Unity套件介紹 : [https://msdn.microsoft.com/en-us/library/ff647202.aspx](https://msdn.microsoft.com/en-us/library/ff647202.aspx) ** **其實這個套件說穿了就是在Application啟動時，註冊每個Interface對應的實體是誰，當碰到要注入這個Interface時，Unity就會去找找看你有沒有跟它說對應的實體，如果有，它就把實體產生出來幫你帶入。那就一步一步做做看邊體會它的意思 **1.安裝Unity套件&nbsp;** 請在Application專案透過Nuget搜尋Unity安裝**Unity.Mvc** [![](https://2.bp.blogspot.com/-HhIfl_RkSKA/V7QbZyR_3SI/AAAAAAAAH8M/C4VxtKVrLdUkdbq6eGIXxg0bH9m_A6DpACLcB/s640/1.png)](https://2.bp.blogspot.com/-HhIfl_RkSKA/V7QbZyR_3SI/AAAAAAAAH8M/C4VxtKVrLdUkdbq6eGIXxg0bH9m_A6DpACLcB/s1600/1.png) ** ****2.註冊Interface應該對應的實體** ** **這時候打開App_Start資料夾應該會看到多了一個檔案**UnityConfig.cs** [![](https://2.bp.blogspot.com/-MCmsg-5dEEY/V7Qb_xiRLFI/AAAAAAAAH8U/3JMMEHww4joUlfQI3HjpW0abcn343O9KwCLcB/s320/1.png)](https://2.bp.blogspot.com/-MCmsg-5dEEY/V7Qb_xiRLFI/AAAAAAAAH8U/3JMMEHww4joUlfQI3HjpW0abcn343O9KwCLcB/s1600/1.png) 打開它會看到以下Code跟註解，教你怎麼使用它[![](https://2.bp.blogspot.com/-B5FxVSeEW9Q/V7QcPsxDVeI/AAAAAAAAH8Y/lsWGO864ftoAVFsUH3nmO9mB4LL0lOAZwCLcB/s640/1.png)](https://2.bp.blogspot.com/-B5FxVSeEW9Q/V7QcPsxDVeI/AAAAAAAAH8Y/lsWGO864ftoAVFsUH3nmO9mB4LL0lOAZwCLcB/s1600/1.png) 請將**RegisterTypes**&nbsp;改成以下 ```csharp /// Registers the type mappings with the Unity container. /// The unity container to configure. /// There is no need to register concrete types such as controllers or API controllers (unless you want to /// change the defaults), as Unity allows resolving a concrete type even if it was not previously registered. public static void RegisterTypes(IUnityContainer container) { //TransientLifetimeManager為這個實體的創建生命週期 //表示執行程式時，每次碰到IPOIService都會去new 一個新的POIService //Unity有許多生命週期可以使用，可以參考官方的文件 //例如PerResolveLifetimeManager就是本次Request只有New一次實體，如果同個Request碰到多次 //都還是會返回第一次New的實體，直到Reqeust結束才會被消滅掉,Singleton的概念 container.RegisterType&lt;IPOIService, POIService&gt;(new TransientLifetimeManager()); &#125; 1234567891011121314151617關於Unity創建實體的生命週期請參考官方文件 :&amp;nbsp;[https:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;ff660872(v&#x3D;pandp.20).aspx](https:&#x2F;&#x2F;msdn.microsoft.com&#x2F;en-us&#x2F;library&#x2F;ff660872(v&#x3D;pandp.20).aspx)註冊好後接著執行看看，會發現程式又活過來了，不會再出現剛剛的錯誤頁面，因為程式已經知道該Interface對應的實體是誰，當由外部注入時，Unity會自己去幫你控制實體的產生並且注入&lt;div class&#x3D;&quot;separator&quot; style&#x3D;&quot;clear: both; text-align: center;&quot;&gt;[![](https:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-QgBTpClZA_g&#x2F;V7QgW_P_VNI&#x2F;AAAAAAAAH8o&#x2F;EBBv1BKh0pIIbOKaZoPRQB4Gt-dmnLcmgCLcB&#x2F;s640&#x2F;1.png)](https:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-QgBTpClZA_g&#x2F;V7QgW_P_VNI&#x2F;AAAAAAAAH8o&#x2F;EBBv1BKh0pIIbOKaZoPRQB4Gt-dmnLcmgCLcB&#x2F;s1600&#x2F;1.png)&lt;&#x2F;div&gt;透過這個重構的實例，我們可以從裡面瞭解到何謂**DI**與**IOC**的概念，但可能會想說，那這樣的好處是什麼? 直接New錯了嗎?回到前一篇提到的，如果直接New的話也就是高耦合的狀況，如果今天面對的實體改動時，很難避免耦合的地方不會跟著變動，所以我們**依賴抽象**(Interface)，用了Unity後其實又牽扯到一個大重點&quot;**職責分離**&quot;。以後如果有Interface與實體的對應關係，直接就會想到要去**UnityConfig.cs**來改，所有的註冊表在這邊統一管理而且一目了然，如果哪天主管跟你說**POIService**它不喜歡，要重新寫個**NewPOIService**，那我們是不是直接把**NewPOIService實作**&lt;span style&#x3D;&quot;color: #bf9000;&quot;&gt;IPOIService&lt;&#x2F;span&gt;後，然後打開**UnityConfig.cs**改成這樣即可&#96;&#96;&#96;csharpcontainer.RegisterType&lt;IPOIService, NewPOIService&gt;(new TransientLifetimeManager()); 其他地方連動都不用動，就已經直接將對應的實體給換掉了!!! 統一管理之外，也能達到最小更動原則。 這次的重構就先到這邊~","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Refactor","slug":"Refactor","permalink":"https://toyo0103.github.io/tags/Refactor/"}]},{"title":"【重構系列】(一) 多型","slug":"【重構系列】-一-多型","date":"2016-08-16T07:33:00.000Z","updated":"2022-08-09T13:36:17.097Z","comments":true,"path":"2016/08/16/【重構系列】-一-多型/","link":"","permalink":"https://toyo0103.github.io/2016/08/16/%E3%80%90%E9%87%8D%E6%A7%8B%E7%B3%BB%E5%88%97%E3%80%91-%E4%B8%80-%E5%A4%9A%E5%9E%8B/","excerpt":"","text":"以下實做的SourceCode已經放到GitHub :https://github.com/toyo0103/Demo_EditTemplate_1 最近在幫專案成員導入開發分層以及物件導向的觀念，也想把這Demo的過程記錄下來。畢竟想法可能隨著專案的經歷而不斷的在修正，也可藉此不斷回頭檢視自己的基本功是否足夠 一、首先來看一下專案分層的關聯圖 [![](https://2.bp.blogspot.com/-2uYHHE-iq7c/V7JxJbl6gCI/AAAAAAAAH3w/I-gYOBfJq8U_fLoVSQTuySsCtNMSb9J6ACLcB/s1600/1.png)](https://2.bp.blogspot.com/-2uYHHE-iq7c/V7JxJbl6gCI/AAAAAAAAH3w/I-gYOBfJq8U_fLoVSQTuySsCtNMSb9J6ACLcB/s1600/1.png) Application : 應用層，參考了邏輯層 Service : &nbsp;邏輯層，參考了資料存取層 Repository : 資料存取層 Lib : 共用層 ，被Application、Service、Repository參考 二、目前各層尚未重構的程式 Repository層[![](https://2.bp.blogspot.com/-tg5bIS8XXLo/V7Kv7donQqI/AAAAAAAAH4A/LMM962SvdT8znywny9YxnzQbnxKS0H-oQCLcB/s1600/1.png)](https://2.bp.blogspot.com/-tg5bIS8XXLo/V7Kv7donQqI/AAAAAAAAH4A/LMM962SvdT8znywny9YxnzQbnxKS0H-oQCLcB/s1600/1.png) 模擬A廠商提供的POI(地圖座標點)資料 123456789101112131415161718/// &lt;summary&gt; /// POI A供應商 /// &lt;/summary&gt; public class ASupplierRepository &#123; public List&lt;POI&gt; Get() &#123; Random rnd = new Random(); //隨機建立十筆Supplier為A的資料回傳 var fixture = new Fixture(); var Result = fixture.Build&lt;POI&gt;() .With(x =&gt; x.Name, string.Concat(&quot;捷運&quot;, rnd.Next(1, 100))) .With(x =&gt; x.Supplier, SupplierEnum.A) .CreateMany().ToList(); return Result; &#125; &#125; ****Service層 [![](https://4.bp.blogspot.com/-Bcv7-vwubuU/V7KxJwqZf9I/AAAAAAAAH4I/9vgY1F6fzbI28ZdK-OCZZmF9bzaM9_FJQCLcB/s1600/1.png)](https://4.bp.blogspot.com/-Bcv7-vwubuU/V7KxJwqZf9I/AAAAAAAAH4I/9vgY1F6fzbI28ZdK-OCZZmF9bzaM9_FJQCLcB/s1600/1.png)** **** **傳入頻道代碼，依據頻道底下的類別，去各供應商取得POI資料，目前模擬頻道資料如下 [![](https://4.bp.blogspot.com/-e-CVa7nJHGo/V7KxhdAVBQI/AAAAAAAAH4M/4xbGZY9o5JE9Dg6fnyvtWQOmm0wMKcDXgCLcB/s320/1.png)](https://4.bp.blogspot.com/-e-CVa7nJHGo/V7KxhdAVBQI/AAAAAAAAH4M/4xbGZY9o5JE9Dg6fnyvtWQOmm0wMKcDXgCLcB/s1600/1.png) 頻道1底下有一個交通的類別，該類別的POI資料來源為A廠商提供頻道2底下有一個交通的類別，該類別的POI資料來源為A廠商與B廠商提供的總和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class POIService &#123; public List&lt;POI&gt; Get(string channelID) &#123; var Result = new List&lt;POI&gt;(); var channel = GetChannel(channelID); //逐一搜尋頻道底下的各類別 foreach (var category in channel.Categorys) &#123; //依據該類別所指定的供應商向Repository要資料 category.Supplier.ForEach(x =&gt; &#123; switch (x) &#123; case SupplierEnum.A: var ASupplier = new ASupplierRepository(); var APOIs = ASupplier.Get(); Result.AddRange(APOIs); break; case SupplierEnum.B: break; &#125; &#125;); &#125; //並接總合的結果回傳 return Result; &#125; /// &lt;summary&gt; /// 模擬頻道類別對應表 /// &lt;/summary&gt; /// &lt;param name=&quot;channelID&quot;&gt;The channel identifier.&lt;/param&gt; /// &lt;returns&gt;Channel.&lt;/returns&gt; Channel GetChannel(string channelID) &#123; if (channelID == &quot;1&quot;) &#123; return new Channel &#123; ID = &quot;1&quot;, Categorys = new List&lt;Channel.Category&gt; &#123; new Channel.Category &#123; Name = &quot;交通&quot;, Supplier =new List&lt;SupplierEnum&gt; &#123; SupplierEnum.A &#125; &#125; &#125; &#125;; &#125; return new Channel &#123; ID = channelID, Categorys = new List&lt;Channel.Category&gt; &#123; new Channel.Category &#123; Name = &quot;交通&quot;, Supplier = new List&lt;SupplierEnum&gt; &#123; SupplierEnum.A , SupplierEnum.B &#125; &#125; &#125; &#125;; &#125; &#125; Application層將傳入的ID透過Service去取得POI資料，並解用Json回傳 ** **```csharp public ActionResult Index(string id) { var Service = new POIService(); var POIs = Service.Get(id); return Json(POIs,JsonRequestBehavior.AllowGet); } 123456789101112131415161718192021222324252627282930目前執行結果&lt;div class&#x3D;&quot;separator&quot; style&#x3D;&quot;clear: both; text-align: center;&quot;&gt;[![](https:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-COJi7ExMLgY&#x2F;V7KzgT1tBuI&#x2F;AAAAAAAAH4c&#x2F;59FwAwpv1U4UniOKgZUJGJMy-jM4AxskgCLcB&#x2F;s320&#x2F;1.png)](https:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-COJi7ExMLgY&#x2F;V7KzgT1tBuI&#x2F;AAAAAAAAH4c&#x2F;59FwAwpv1U4UniOKgZUJGJMy-jM4AxskgCLcB&#x2F;s1600&#x2F;1.png)&lt;&#x2F;div&gt;### &lt;span style&#x3D;&quot;font-size: x-large;&quot;&gt;三、加入B廠商Repository&lt;&#x2F;span&gt;&lt;div&gt;&lt;span style&#x3D;&quot;font-size: x-large;&quot;&gt;&lt;&#x2F;span&gt;### &lt;span style&#x3D;&quot;font-size: x-large;&quot;&gt; **&lt;span style&#x3D;&quot;color: #444444; font-size: large;&quot;&gt;&lt;u&gt;Repository層加入BSupplierRepositoy&lt;&#x2F;u&gt;&lt;&#x2F;span&gt;** &lt;&#x2F;span&gt; &lt;span style&#x3D;&quot;font-size: x-large;&quot;&gt; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;separator&quot; style&#x3D;&quot;clear: both; text-align: center;&quot;&gt;[![](https:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-qhpGz7u6oVg&#x2F;V7K0fW7yuaI&#x2F;AAAAAAAAH4k&#x2F;nGTc-zqfiE4MS4uEtO_gG_mdHZbJkkNsACLcB&#x2F;s1600&#x2F;1.png)](https:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-qhpGz7u6oVg&#x2F;V7K0fW7yuaI&#x2F;AAAAAAAAH4k&#x2F;nGTc-zqfiE4MS4uEtO_gG_mdHZbJkkNsACLcB&#x2F;s1600&#x2F;1.png)&lt;&#x2F;div&gt;&lt;div&gt;**&lt;span style&#x3D;&quot;color: #990000;&quot;&gt;&lt;&#x2F;span&gt;** **&lt;span style&#x3D;&quot;color: #990000;&quot;&gt;&lt;&#x2F;span&gt;**&lt;&#x2F;div&gt;&#96;&#96;&#96;csharp&#x2F;&#x2F;&#x2F; &lt;summary&gt; &#x2F;&#x2F;&#x2F; POI B供應商 &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt; public class BSupplierRepository &#123; public List&lt;POI&gt; Get() &#123; Random rnd &#x3D; new Random(); &#x2F;&#x2F;隨機建立十筆Supplier為B的資料回傳 var fixture &#x3D; new Fixture(); var Result &#x3D; fixture.Build&lt;POI&gt;() .With(x &#x3D;&gt; x.Name, string.Concat(&quot;捷運&quot;, rnd.Next(1, 100))) .With(x &#x3D;&gt; x.Supplier, SupplierEnum.B) .CreateMany().ToList(); return Result; &#125; &#125; Service層12345678910111213141516171819202122//逐一搜尋頻道底下的各類別 foreach (var category in channel.Categorys) &#123; //依據該類別所指定的供應商向Repository要資料 category.Supplier.ForEach(x =&gt; &#123; switch (x) &#123; case SupplierEnum.A: var ASupplier = new ASupplierRepository(); var APOIs = ASupplier.Get(); Result.AddRange(APOIs); break; case SupplierEnum.B: //補上B廠商 var BSupplier = new BSupplierRepository(); var BPOIs = BSupplier.Get(); Result.AddRange(BPOIs); break; &#125; &#125;); &#125; 執行結果[![](https://3.bp.blogspot.com/-oLBfowU5dPE/V7K3te4Ug8I/AAAAAAAAH4w/HWxKp39vbfwkUb4zpQkvoB_umOlCnBk2gCLcB/s1600/1.png)](https://3.bp.blogspot.com/-oLBfowU5dPE/V7K3te4Ug8I/AAAAAAAAH4w/HWxKp39vbfwkUb4zpQkvoB_umOlCnBk2gCLcB/s1600/1.png) 四、重構開始 首先需要思考一個問題，雖然這樣已經可以達成需求，但很明顯的是如果今天提供POI的廠商一直增加的話，我們要一直替**Repository層**新增廠商之外，**Service層**也會一直在Switch那邊做修改。&nbsp; [![](https://3.bp.blogspot.com/-At8pfSKZU1A/V7O464uATbI/AAAAAAAAH6Y/_ZteovVvDKgiWIP4C7VOW0d_ID0T3Yn0gCLcB/s640/1.png)](https://3.bp.blogspot.com/-At8pfSKZU1A/V7O464uATbI/AAAAAAAAH6Y/_ZteovVvDKgiWIP4C7VOW0d_ID0T3Yn0gCLcB/s1600/1.png) [![](https://4.bp.blogspot.com/-_mL7zcPN80s/V7O5MABxbiI/AAAAAAAAH6c/iwdP7xw3pVkJlb08t52ggMFcpuNRywTZQCLcB/s640/1.png)](https://4.bp.blogspot.com/-_mL7zcPN80s/V7O5MABxbiI/AAAAAAAAH6c/iwdP7xw3pVkJlb08t52ggMFcpuNRywTZQCLcB/s1600/1.png) 那該怎麼改可以避免每次改Repository又要一直改Service層呢? 這時就會運用到OO原則中的**依賴抽象**概念，當我們面對的是實體(例如:**ASupplierRepository** , **BSupplierRepository**)時也就是所謂的高耦合，如果面對的實體有所變動時，所有耦合的地方都會有高機率要一起改動的風險。 因為要面對抽象，第一步我們就要來觀察這兩個實體共通處是什麼? 其實說穿了都是提供一個叫做Get()的方法，當呼叫他時，回傳對應的POI List，這就是它們共通的地方，接下來透過抽取介面的方式來實行隔離&nbsp; ** **** **[![](https://1.bp.blogspot.com/-8ZNSvrUREs8/V7O5d9RkdPI/AAAAAAAAH6g/l9zIPDnhW2MYl-bCWyutTDSp9UeRtpDigCLcB/s640/1.png)](https://1.bp.blogspot.com/-8ZNSvrUREs8/V7O5d9RkdPI/AAAAAAAAH6g/l9zIPDnhW2MYl-bCWyutTDSp9UeRtpDigCLcB/s1600/1.png) ** ****ISupplierRepository** 123456789101112/// &lt;summary&gt; /// Interface ISupplierRepository /// &lt;/summary&gt; public interface ISupplierRepository &#123; /// &lt;summary&gt; /// 取得POI資料 /// &lt;/summary&gt; /// &lt;returns&gt;List&amp;lt;POI&amp;gt;.&lt;/returns&gt; List&lt;POI&gt; Get(); &#125; 將ASupplierRepository&nbsp;, BSupplierRepository都套上介面 [![](https://3.bp.blogspot.com/-Jcpo5G8HHb0/V7K7uHZpu4I/AAAAAAAAH5I/uBTimpbb1_YxzjwVDH3ApMka-KNPy-fBwCLcB/s640/1.png)](https://3.bp.blogspot.com/-Jcpo5G8HHb0/V7K7uHZpu4I/AAAAAAAAH5I/uBTimpbb1_YxzjwVDH3ApMka-KNPy-fBwCLcB/s1600/1.png) [![](https://2.bp.blogspot.com/-e3WLuMtpxh4/V7K7kaOISdI/AAAAAAAAH5E/ZLhqJrVmBcMxApVZcO82qEAbAGXsNTcaACLcB/s640/1.png)](https://2.bp.blogspot.com/-e3WLuMtpxh4/V7K7kaOISdI/AAAAAAAAH5E/ZLhqJrVmBcMxApVZcO82qEAbAGXsNTcaACLcB/s1600/1.png) 將兩個類別都實作了ISupplierRepository介面後，來修改**Service層**，讓它能面對抽象而非直接面對實體 Service層首先先運用簡單工廠模式，請它來幫我們建造SupplierRepository的實體[![](https://2.bp.blogspot.com/-sUw1JL2z37U/V7K9OulK-EI/AAAAAAAAH5Y/VeGijYdLK7ElsbQb0Cie22U4PnGOex-BwCLcB/s1600/1.png)](https://2.bp.blogspot.com/-sUw1JL2z37U/V7K9OulK-EI/AAAAAAAAH5Y/VeGijYdLK7ElsbQb0Cie22U4PnGOex-BwCLcB/s1600/1.png) ```csharp public class SupplierFactory { public static ISupplierRepository Generate(SupplierEnum supplierType) { //因為A跟B的SupplierRepository都有實做ISupplierRepository //所以這邊可以直接回傳介面，也間接地規範以後新增SupplierRepository都要實作ISupplierRepository介面 switch (supplierType) { case SupplierEnum.A: return new ASupplierRepository(); case SupplierEnum.B: return new BSupplierRepository(); } return null; } } ``` 修改原本的POIService，讓它透過工廠來取得Repository，而不是直接去New實體 [![](https://1.bp.blogspot.com/-yqxvmh12FqM/V7K97eMgJOI/AAAAAAAAH5c/jeYldicOfYYSTvZJeGJRKOkPtJ7OETKXwCLcB/s640/1.png)](https://1.bp.blogspot.com/-yqxvmh12FqM/V7K97eMgJOI/AAAAAAAAH5c/jeYldicOfYYSTvZJeGJRKOkPtJ7OETKXwCLcB/s1600/1.png) 瞬間乾淨很多，而且POIService不再直接對ASupplierRepository&nbsp;,&nbsp;BSupplierRepository，而是面對ISupplierRepository，達成了所謂的面對抽象。 這時候思考一下，以後新增供應商的Repository時POIService都不用改動了，只要Repository層新增好後，將Factory改一下即可，但是否又跳出另一個問題了。這樣Repository層更動時還不是要打開Service層去做修改。 因此在這我會將Factory搬Repository層去封裝起來 將SupplierFactory搬到Repository層，並將實體Repository改成Internal封裝起來[![](https://2.bp.blogspot.com/-WrLZP8-uAWU/V7LAj2T_ieI/AAAAAAAAH5s/uZ2PH9JQGX4X1aOwYavGDKaCHKfXC95MQCLcB/s1600/1.png)](https://2.bp.blogspot.com/-WrLZP8-uAWU/V7LAj2T_ieI/AAAAAAAAH5s/uZ2PH9JQGX4X1aOwYavGDKaCHKfXC95MQCLcB/s1600/1.png) [![](https://2.bp.blogspot.com/-6shnp4lJN7Q/V7LA6VF0OmI/AAAAAAAAH5w/7eVfEwIFG38IGqtWYLxr-QDBdIAHtw1_wCLcB/s400/1.png)](https://2.bp.blogspot.com/-6shnp4lJN7Q/V7LA6VF0OmI/AAAAAAAAH5w/7eVfEwIFG38IGqtWYLxr-QDBdIAHtw1_wCLcB/s1600/1.png) [![](https://2.bp.blogspot.com/-OMNNg00W0qE/V7LBG6V83fI/AAAAAAAAH50/1stqCDyKtRMLmxt-QBvl3vXZ9khxZOFpACLcB/s400/1.png)](https://2.bp.blogspot.com/-OMNNg00W0qE/V7LBG6V83fI/AAAAAAAAH50/1stqCDyKtRMLmxt-QBvl3vXZ9khxZOFpACLcB/s1600/1.png) 換句話說，因為改成Internal的關係，現在Service層也碰不到**ASupplierRepository**&nbsp;,&nbsp;**B****SupplierRepository**這兩個實體了，完全只能依賴Factory來取得介面的對應實體，未來不管怎麼新增Repository都不會再改**Service層**，到這邊就是重構並且實踐多型了 目前UML結構圖如下 [![](https://1.bp.blogspot.com/-fUMrd2aOxZs/V7LGMRcCTpI/AAAAAAAAH6I/lgwJmCO6LYse8DXoFEJKw3NqwtL7Z7f7QCLcB/s1600/1.png)](https://1.bp.blogspot.com/-fUMrd2aOxZs/V7LGMRcCTpI/AAAAAAAAH6I/lgwJmCO6LYse8DXoFEJKw3NqwtL7Z7f7QCLcB/s1600/1.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Refactor","slug":"Refactor","permalink":"https://toyo0103.github.io/tags/Refactor/"}]},{"title":"【FluentAssertions】如何驗證巢狀結構中，Double倍精準數","slug":"【FluentAssertions】如何驗證巢狀結構中，Double倍精準數","date":"2016-08-05T02:39:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2016/08/05/【FluentAssertions】如何驗證巢狀結構中，Double倍精準數/","link":"","permalink":"https://toyo0103.github.io/2016/08/05/%E3%80%90FluentAssertions%E3%80%91%E5%A6%82%E4%BD%95%E9%A9%97%E8%AD%89%E5%B7%A2%E7%8B%80%E7%B5%90%E6%A7%8B%E4%B8%AD%EF%BC%8CDouble%E5%80%8D%E7%B2%BE%E6%BA%96%E6%95%B8/","excerpt":"","text":"寫單元測試的時候常常會使用FluentAssertions這個套件來做驗證，即便兩個巢狀結構的類別透過這個套件也能輕鬆解決比對問題。 但最近碰到當重狀結構裡面有Double這類的趨近值數值時，驗證會失敗，查了一下後找到解法，所以紀錄一下 原本UnitTest程式長這樣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[TestMethod] public void Test_DoubleAssert() &#123; //arrange var stops = new List&lt;BusStopAPIResult&gt; &#123; new BusStopAPIResult &#123; StopName = new NameAPIResult &#123; Zh_tw = &quot;吊橋頭&quot;, En = &quot;deocioutao&quot; &#125;, StopUID = &quot;StopUID1&quot;, StopPosition = new BusStopAPIResult.Coordinate &#123; PositionLat = 24.853690, PositionLon = 121.354917 &#125; &#125;, new BusStopAPIResult &#123; StopName = new NameAPIResult &#123; Zh_tw = &quot;吊橋頭&quot;, En = &quot;deocioutao&quot; &#125;, StopUID = &quot;StopUID2&quot;, StopPosition = new BusStopAPIResult.Coordinate &#123; PositionLat = 24.853632, PositionLon = 121.354874 &#125; &#125; &#125;; var expected = new List&lt;BusStopClusterDTO&gt; &#123; new BusStopClusterDTO &#123; Name = &quot;吊橋頭&quot;, SourceID = &quot;StopUID1&quot;, IDs = new List&lt;string&gt; &#123; &quot;StopUID1&quot; , &quot;StopUID2&quot; &#125;, Lat = 24.853661, Lng = 121.3548955 &#125; &#125;; //act var actual = Program.ClusterSourceData(stops); //assert actual.ShouldBeEquivalentTo(expected); &#125; 執行結果如圖 [![](https://2.bp.blogspot.com/-LvpAUuEAqzk/V6P6OrTaInI/AAAAAAAAH3U/37TPKUzXfAI0KKdMpNDAJCpcvBrZXZH2gCLcB/s640/1.png)](https://2.bp.blogspot.com/-LvpAUuEAqzk/V6P6OrTaInI/AAAAAAAAH3U/37TPKUzXfAI0KKdMpNDAJCpcvBrZXZH2gCLcB/s1600/1.png) [![](https://2.bp.blogspot.com/-xi043e38HW0/V6P6m4ED9_I/AAAAAAAAH3Y/T29FHNHT7h4Y51M1RTmwb1dnZJm-wMLMQCLcB/s320/1.png)](https://2.bp.blogspot.com/-xi043e38HW0/V6P6m4ED9_I/AAAAAAAAH3Y/T29FHNHT7h4Y51M1RTmwb1dnZJm-wMLMQCLcB/s1600/1.png) 因為數值是經緯度，經過計算後不需要驗證精確到小數點這麼多位數，所以可以改用以下方法去驗證 1234567actual.ShouldBeEquivalentTo( expected, //當欄位型別為Double時，相差到0.000001之內都是OK的 option =&gt; option.Using&lt;double&gt;( ctx =&gt; ctx.Subject.Should().BeApproximately(ctx.Expectation, 0.000001)) .WhenTypeIs&lt;double&gt;()); 這樣驗證就會過關了!!","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"},{"name":"FluentAssertions","slug":"FluentAssertions","permalink":"https://toyo0103.github.io/tags/FluentAssertions/"}]},{"title":"快速搜尋可視範圍的座標點。 透過四元樹演算法","slug":"快速搜尋可視範圍的座標點。-透過四元樹演算法","date":"2016-08-04T09:32:00.000Z","updated":"2022-08-09T13:36:17.098Z","comments":true,"path":"2016/08/04/快速搜尋可視範圍的座標點。-透過四元樹演算法/","link":"","permalink":"https://toyo0103.github.io/2016/08/04/%E5%BF%AB%E9%80%9F%E6%90%9C%E5%B0%8B%E5%8F%AF%E8%A6%96%E7%AF%84%E5%9C%8D%E7%9A%84%E5%BA%A7%E6%A8%99%E9%BB%9E%E3%80%82-%E9%80%8F%E9%81%8E%E5%9B%9B%E5%85%83%E6%A8%B9%E6%BC%94%E7%AE%97%E6%B3%95/","excerpt":"","text":"接到一個任務，要把全國的公車資料座標訊息爬回來，並且做整理歸納。研究了一下交通部的公共運輸整合資訊平台的內容，資訊相當完整，API也寫得很彈性。 唯獨公車站牌的部分，是以公車路線為出發點思考，每條路線雖然會經過同一個站牌，站牌的ID都會視為不同，不同ID的站牌，經緯度可能相同。 例如 :富陽街口的公車站牌資料 [![](https://1.bp.blogspot.com/-rsJGRd8q0Yk/V6LuwauETRI/AAAAAAAAH2I/MXCywQPawicA3nbmx9j-D6608XWt5RxXQCLcB/s640/13765731_1287175481295263_7952967575366659415_o.jpg)](https://1.bp.blogspot.com/-rsJGRd8q0Yk/V6LuwauETRI/AAAAAAAAH2I/MXCywQPawicA3nbmx9j-D6608XWt5RxXQCLcB/s1600/13765731_1287175481295263_7952967575366659415_o.jpg) 富陽街口去程回程的公車，透過GoogleMap算大概有8支站牌，但透過API去撈會發現有17支ID皆為不同的資料。 任務目標 :將所有站牌資料爬回來，相同的站名距離20公尺內的站牌要能自動聚合在一起，成為一支站牌。 原本思考是全部爬回來後用站名做整合，但發現一個問題是宜蘭與桃園都有相同站名的站牌”吊橋頭”，而距離相差十萬八千里，所以站名不可行。會加上20公尺的條件是因為像是台北火車站他的腹地很大，公車站牌可能很多相距很遠， 或是有些捷運站出口在兩條路口的轉角都有公車站牌，且站名相同，如果單純把這些點整合在一起放回地圖上，會發現公車站牌少了許多，失真。 歸納以上的條件，我們會有一大批公車站牌的資料(118728筆資料)，如果把每個站牌用同名稱的逐筆下去比對各自的距離，顯然掃到天荒地老也跑不完，顯然浪費效能且不切實際。 看了一篇文章後得到非常大的啟發，該方法是透過四元樹演算法將大批座標快速塞選出範圍內的點，並且做出聚合。參考 &nbsp;: &nbsp;How To Efficiently Display Large Amounts of Data on iOS Maps四元樹演算法 : Wiki 節錄Wiki對四元樹的解說:「假如四元樹區塊被用來表達一組點資料(諸如一組城市的經緯度)，區塊就進行次分割直到每個葉節點包含最多一個單點。」 用圖片來表示就像這樣 [![](https://4.bp.blogspot.com/-waUqxqrmcf8/V6L7oy8YO-I/AAAAAAAAH2Y/kMcCy8J_kGw45_XPYsvcsqONAuQa767qgCLcB/s320/quadTreeInsert.gif)](https://4.bp.blogspot.com/-waUqxqrmcf8/V6L7oy8YO-I/AAAAAAAAH2Y/kMcCy8J_kGw45_XPYsvcsqONAuQa767qgCLcB/s1600/quadTreeInsert.gif)**Source &nbsp;: &nbsp;https://robots.thoughtbot.com/how-to-handle-large-amounts-of-data-on-maps** 四元樹包含幾個概念 1.每個節點最多只能包含一個座標 2.當節點的座標滿了，會分裂出四個象限 根據以上概念寫出以下Class 12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt; /// 四元樹節點 /// &lt;/summary&gt; public class QuadTreeNode &#123; //四個象限 public QuadTreeNode NorthWest &#123; get; set; &#125; public QuadTreeNode NorthEast &#123; get; set; &#125; public QuadTreeNode SouthWest &#123; get; set; &#125; public QuadTreeNode SouthEast &#123; get; set; &#125; /// &lt;summary&gt; /// 邊界 /// &lt;/summary&gt; public BoundingBoxDTO BoundingBox &#123; get; set; &#125; /// &lt;summary&gt; /// 節點數量 /// &lt;/summary&gt; public int BucketCapacity &#123; get; set; &#125; /// &lt;summary&gt; /// 座標資料 /// &lt;/summary&gt; public List&lt;Data&gt; Points &#123; get; set; &#125; public QuadTreeNode(BoundingBoxDTO boundingBox , int capacity) &#123; BoundingBox = boundingBox; BucketCapacity = capacity; Points = new List&lt;BusStopAPIResult&gt;(); &#125; &#125; 那座標插入四元樹節點時如何運作? 123456789101112131415161718192021222324252627282930313233public bool Insert(QuadTreeNode node, Data point) &#123; // 確定這個座標符合四元樹的框框範圍 if (!CheckBoundingBoxContainData(node.BoundingBox, point)) &#123; return false; &#125; // 如果這個座標符合框框範圍，檢查這個節點是否已經超過座標存放上限 // 如果沒有，那就座標放入回傳True if ((node.Points.Count +1) &lt;= node.BucketCapacity) &#123; node.Points.Add(data); return true; &#125; // 會走到這一步，表示這個座標在這個四元樹的框框範圍內 // 但是能存放的座標已經滿了，判斷這個四元樹節點是否有四個象限 // 如果沒有，進行分裂 if (node.NorthWest == null) &#123; Subdivide(node); &#125; // 將座標丟到新分裂出來的四個四元樹象限，符合座標坐落的位置，存放好回傳True if (Insert(node.NorthWest, data)) return true; if (Insert(node.NorthEast, data)) return true; if (Insert(node.SouthWest, data)) return true; if (Insert(node.SouthEast, data)) return true; return false; &#125; 四元樹分裂的程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/// &lt;summary&gt; /// 四元樹分裂 /// &lt;/summary&gt; /// &lt;param name=&quot;node&quot;&gt;四元樹節點&lt;/param&gt; void Subdivide(QuadTreeNode node) &#123; var box = node.BoundingBox; //找出要分裂的四元樹中心點 double LatMid = (box.LeftTop.Latitude + box.RightBottom.Latitude) / 2.0; double LngMid = (box.LeftTop.Longitude + box.RightBottom.Longitude) / 2.0; //算出西北象限的左上右下座標點 var NorthWest = new BoundingBoxDTO &#123; LeftTop = new CoordinateDTO &#123; Latitude = box.LeftTop.Latitude, Longitude = box.LeftTop.Longitude &#125;, RightBottom = new CoordinateDTO &#123; Latitude = LatMid, Longitude = LngMid &#125; &#125;; node.NorthWest = new QuadTreeNode(NorthWest, node.BucketCapacity); //算出東北象限的左上右下座標點 var NorthEast = new BoundingBoxDTO &#123; LeftTop = new CoordinateDTO &#123; Latitude = box.LeftTop.Latitude, Longitude = LngMid &#125;, RightBottom = new CoordinateDTO &#123; Latitude = LatMid, Longitude = box.RightBottom.Longitude &#125; &#125;; node.NorthEast = new QuadTreeNode(NorthEast, node.BucketCapacity); //算出西南象限的左上右下座標點 var SouthWest = new BoundingBoxDTO &#123; LeftTop = new CoordinateDTO &#123; Latitude = LatMid, Longitude = box.LeftTop.Longitude &#125;, RightBottom = new CoordinateDTO &#123; Latitude = box.RightBottom.Latitude, Longitude = LngMid &#125; &#125;; node.SouthWest = new QuadTreeNode(SouthWest, node.BucketCapacity); //算出東南象限的左上右下座標點 var SouthEast = new BoundingBoxDTO &#123; LeftTop = new CoordinateDTO &#123; Latitude = LatMid, Longitude = LngMid &#125;, RightBottom = new CoordinateDTO &#123; Latitude = box.RightBottom.Latitude, Longitude = box.RightBottom.Longitude &#125; &#125;; node.SouthEast = new QuadTreeNode(SouthEast, node.BucketCapacity); &#125; 看到這邊可能會有個疑問，那就是雖然知道四元樹就像是遞迴的概念，將地圖分裂成很多塊，每個大區塊可能又被分裂成若干的小區塊，一層一層的往下長 [![](https://1.bp.blogspot.com/-m_rkkVB1hxw/V6MCmq-X0gI/AAAAAAAAH2o/FHOE9VcWAvkLDp8BWJvjYnWvP9-NlbGfgCLcB/s320/500px-Point_quadtree.svg.png)](https://1.bp.blogspot.com/-m_rkkVB1hxw/V6MCmq-X0gI/AAAAAAAAH2o/FHOE9VcWAvkLDp8BWJvjYnWvP9-NlbGfgCLcB/s1600/500px-Point_quadtree.svg.png)**Source &nbsp;: &nbsp;https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%8F%89%E6%A0%91** 但為何會讓搜尋速度加快呢? 原因是他從上層開始看是否有重疊到要搜尋的區塊，如果有就往該節點的四象限遞迴繼續往下找重疊，如果在大區塊的節點就已經沒有包含重疊區域，那他無限往下延伸的子節點也就不會被搜尋了。引用原作者的圖片就一目了然 [![](https://3.bp.blogspot.com/-FXlbFONjFzI/V6MEINzRBHI/AAAAAAAAH20/gXhavItzQ_o3GgeyMPRgBGAxhJ9U6MuVwCLcB/s400/quadTreeQuery.gif)](https://3.bp.blogspot.com/-FXlbFONjFzI/V6MEINzRBHI/AAAAAAAAH20/gXhavItzQ_o3GgeyMPRgBGAxhJ9U6MuVwCLcB/s1600/quadTreeQuery.gif)**Source &nbsp;: &nbsp;https://robots.thoughtbot.com/how-to-handle-large-amounts-of-data-on-maps** 搜尋程式碼如下如何透過座標判斷地理位置有無交集，請參考上一篇文章:&nbsp;【地理位置】透過座標框出地理位置，與判斷地理位置是否重疊 123456789101112131415161718192021222324252627282930313233public void SearchDataInRange(QuadTreeNode node, BoundingBoxDTO range, ref List&lt;Data&gt; datas) &#123; // 確認要搜尋的區塊是否與四元樹節點所涵蓋的區塊有重疊到，如果沒有就直接跳掉 if (!CheckIntersectionBoundingBox(node.BoundingBox, range)) &#123; return; &#125; //如果有，將這個區塊的節點拿出來比對是否在要搜尋的範圍中 //因為雖然範圍有重疊到，但不代表裡面的所有節點都落在重疊的範圍 //如果落在重疊的範圍，儲存起來，之後回傳 foreach (var item in node.Points) &#123; // Gather points contained in range if (CheckBoundingBoxContainData(range, item)) &#123; datas.Add(item); &#125; &#125; //確認這個節點是否有分裂過 if (node.NorthWest == null) &#123; return; &#125; //如果有分裂成四個象限，繼續遞迴往下找 SearchDataInRange(node.NorthWest, range, ref datas); SearchDataInRange(node.NorthEast, range, ref datas); SearchDataInRange(node.SouthWest, range, ref datas); SearchDataInRange(node.SouthEast, range, ref datas); &#125; 說了這麼多，我們如何將上述的四元樹理論運用在我們的目標上呢? 首先我們把一堆的公車站牌資料抓回來後，依據名稱先進行第一次分類，把每個名稱相同的依據上面的方式做成四元樹節點，但這邊有個前面提到的問題，如果是同個站名但其實是不同的站點呢? 這邊我用的方法是將同名稱的公車站牌，找出兩個離最遠的站牌算距離，如果超過1公里合理懷疑這是兩個不同的站點，只是碰巧相同名稱。台灣應該沒有差了一公里遠但是是同一個站的吧……(有的話請跟我說XD)。 將這群同站名但其實不同地方的站牌，依據一公里為單位分組，這樣就能有效地將這類同名的站牌做更細部的歸類。 計算兩點座標距離的程式 12345678910111213141516171819202122232425262728private const double EARTH_RADIUS = 6378.137; //地球半? /// &lt;summary&gt; /// 計算距離(返回公尺) /// &lt;/summary&gt; /// &lt;param name=&quot;lat1&quot;&gt;點1經&lt;/param&gt; /// &lt;param name=&quot;lng1&quot;&gt;點1緯&lt;/param&gt; /// &lt;param name=&quot;lat2&quot;&gt;點2經&lt;/param&gt; /// &lt;param name=&quot;lng2&quot;&gt;點2緯&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static double GetDistance(double lat1, double lng1, double lat2, double lng2) &#123; double radLat1 = rad(lat1); double radLat2 = rad(lat2); double a = radLat1 - radLat2; double b = rad(lng1) - rad(lng2); double s = 2 * Math.Asin(Math.Sqrt(Math.Pow(Math.Sin(a / 2), 2) + Math.Cos(radLat1) * Math.Cos(radLat2) * Math.Pow(Math.Sin(b / 2), 2))); s = s * EARTH_RADIUS; s = Math.Round(s * 10000) / 10; return s; &#125; private static double rad(double d) &#123; return d * Math.PI / 180.0; &#125; 上面的問題皆排除並分類後，依據同名的站牌，算出這群站牌座標的中心點，並用離中心最遠的座標距離做為範圍，依照每小格20公尺的矩形進行四元樹搜尋，在同一格內的整合成一個站牌，記錄下來 概念圖 [![](https://2.bp.blogspot.com/-C9CqLPtlx7Q/V6MKsEK1vTI/AAAAAAAAH3E/KDH_KTeXYQQnoFWCQdLL7mvIihxNMh7KgCLcB/s640/1.png)](https://2.bp.blogspot.com/-C9CqLPtlx7Q/V6MKsEK1vTI/AAAAAAAAH3E/KDH_KTeXYQQnoFWCQdLL7mvIihxNMh7KgCLcB/s1600/1.png) 1.這些點只是亂標的，但假設真的有個同名站牌坐落在這些位置，找到中心點後，藍色線為中心點與最遠座標的直線距離，依據這個距離做為矩形二分之一寬。 2.有了距離後就能求出左上跟右下角的點，透過DbGeography這個來取得地理面積的物件3.從左上開始，橘色的每小格為長寬各20公尺的矩形，透過四元樹下去搜尋，被同一格橘色小框框到的座標收納成同一個點，記錄下來 經過實測，如果只是雙北市的公車站點，只要4分鐘就能全部歸類掃描完畢，全國的話大概4個小時能算完，以上是這次任務的小筆記 測試環境 :CPU &nbsp;: &nbsp;I7 &nbsp;4核 (實際在跑的時候控制大概在3核左右)RAM : 16G","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【地理位置】透過座標框出地理位置，與判斷地理位置是否重疊","slug":"【地理位置】透過座標框出地理位置，與判斷地理位置是否重疊","date":"2016-08-04T07:01:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2016/08/04/【地理位置】透過座標框出地理位置，與判斷地理位置是否重疊/","link":"","permalink":"https://toyo0103.github.io/2016/08/04/%E3%80%90%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E3%80%91%E9%80%8F%E9%81%8E%E5%BA%A7%E6%A8%99%E6%A1%86%E5%87%BA%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%8C%E8%88%87%E5%88%A4%E6%96%B7%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E9%87%8D%E7%96%8A/","excerpt":"","text":"如果取得西北與東南的兩點座標透過DbGeography這個類別能夠框出地理面積，程式碼如下 123456DbGeography.FromText(string.Format(&quot;POLYGON((&#123;0&#125; &#123;1&#125;, &#123;0&#125; &#123;2&#125;, &#123;3&#125; &#123;2&#125;, &#123;3&#125; &#123;1&#125;, &#123;0&#125; &#123;1&#125;))&quot;, 西北座標點的經度, 西北座標點的緯度, 東南座標點的緯度, 東南座標點的經度), 4326); 這樣能取回DbGeography的地理面積的類別，透過這個類別的Intersects這個Method能判斷兩個面積，或是座標點是否有交集。參考MSDN 範例 : 用Google地圖來取得兩個座標點，框出地理位置****座標點1 :&nbsp;25.029768, 121.546829 [![](https://1.bp.blogspot.com/-2gYLmcT7YnE/V6Lj8q2dPzI/AAAAAAAAH1I/paibCBIx16cafBaBrvhNCJkrFTcVrYS0gCLcB/s400/1.png)](https://1.bp.blogspot.com/-2gYLmcT7YnE/V6Lj8q2dPzI/AAAAAAAAH1I/paibCBIx16cafBaBrvhNCJkrFTcVrYS0gCLcB/s1600/1.png) 座標點2 :&nbsp;25.028854, 121.548417 [![](https://2.bp.blogspot.com/-U3tLa6GFY3U/V6LkMN-HODI/AAAAAAAAH1M/9FhZt1GbnlQPi29X-gO8YKwhuiZbLUBvACLcB/s400/1.png)](https://2.bp.blogspot.com/-U3tLa6GFY3U/V6LkMN-HODI/AAAAAAAAH1M/9FhZt1GbnlQPi29X-gO8YKwhuiZbLUBvACLcB/s1600/1.png) 所以透過剛剛的程式我們可以框出這塊地理面積 [![](https://2.bp.blogspot.com/-vt2mdO_TXx0/V6LlFRP_RrI/AAAAAAAAH1U/iyilo98OOwsCNtTPvlcvN9Hs-LAiD0uAwCLcB/s320/1.png)](https://2.bp.blogspot.com/-vt2mdO_TXx0/V6LlFRP_RrI/AAAAAAAAH1U/iyilo98OOwsCNtTPvlcvN9Hs-LAiD0uAwCLcB/s1600/1.png) 依樣畫葫蘆，在選兩個點去框出下個面積座標點1 :&nbsp;25.029541, 121.547474**座標點2 :&nbsp;**25.028199, 121.549636 [![](https://1.bp.blogspot.com/-uv7-0y_8x2I/V6LlwFgayyI/AAAAAAAAH1k/4lmNDDpGBmMhF0xtmFJjIuAtlQKfqw_mwCLcB/s320/1.png)](https://1.bp.blogspot.com/-uv7-0y_8x2I/V6LlwFgayyI/AAAAAAAAH1k/4lmNDDpGBmMhF0xtmFJjIuAtlQKfqw_mwCLcB/s1600/1.png) 從兩張圖可以看到在四維路那邊有重疊的部分，用程式碼來跑跑看 [![](https://1.bp.blogspot.com/-1wdcHZ4VBEU/V6LmrE_EI7I/AAAAAAAAH1s/4_wwJ8SwkEw-neIcwpAeeaoTfrcJ544JgCLcB/s640/1.png)](https://1.bp.blogspot.com/-1wdcHZ4VBEU/V6LmrE_EI7I/AAAAAAAAH1s/4_wwJ8SwkEw-neIcwpAeeaoTfrcJ544JgCLcB/s1600/1.png) 為了驗證不重疊會回傳False,我們將Area2的西北座標往右下角移動，讓面積縮小不會跟Area1重疊，再次實驗看看Area2&nbsp;座標點1 :&nbsp;25.029541, 121.547474 &gt;&gt;&nbsp;25.029123, 121.548772 &nbsp;(改到敦化南路二段上)**座標點2 :&nbsp;**25.028199, 121.549636 [![](https://4.bp.blogspot.com/-EYzYtuHuPs0/V6Lnj8MSgYI/AAAAAAAAH14/cDU5K1uKDQUlQbYYNdFEt_h_sJySf0ZmACLcB/s1600/1.png)](https://4.bp.blogspot.com/-EYzYtuHuPs0/V6Lnj8MSgYI/AAAAAAAAH14/cDU5K1uKDQUlQbYYNdFEt_h_sJySf0ZmACLcB/s1600/1.png) 補充:上面介紹的是兩點框出面積，如果要判斷一個座標點有無落在一個面積裡面，用法也相同，只是建立DbGeography座標點的方法略有不同，如下 12var point = DbGeography.PointFromText(string.Format(&quot;POINT(&#123;0&#125; &#123;1&#125;)&quot;, 經度, 緯度), 4326); 一樣帶到Intersects就可以得到答案了!! 以上","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【Unit Test】針對Repository做單元測試 (二)","slug":"【Unit-Test】針對Repository做單元測試-二","date":"2016-07-29T10:28:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2016/07/29/【Unit-Test】針對Repository做單元測試-二/","link":"","permalink":"https://toyo0103.github.io/2016/07/29/%E3%80%90Unit-Test%E3%80%91%E9%87%9D%E5%B0%8DRepository%E5%81%9A%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-%E4%BA%8C/","excerpt":"","text":"曾上一篇，開始在我們的Production專案寫一段跟DB要資料的程式吧。(註 : 這邊不考慮分層與物件導向問題，一切專注在單元測試上) 首先先在專案中加入EntityFramework，並把Northwind的Employees Table加進來 [![](https://4.bp.blogspot.com/-rgwWYtv-ueQ/V5rwi6Q1TII/AAAAAAAAHyQ/uRS4J_82bxsDX5wZNtqjqoA8hjVtRUjcQCLcB/s640/1.png)](https://4.bp.blogspot.com/-rgwWYtv-ueQ/V5rwi6Q1TII/AAAAAAAAHyQ/uRS4J_82bxsDX5wZNtqjqoA8hjVtRUjcQCLcB/s1600/1.png) [![](https://2.bp.blogspot.com/-yQ-t7YWi-qI/V5rwi006AII/AAAAAAAAHyY/1ftZ1r6NWgQVEmiKy4uhK84XBGa4le3TQCLcB/s1600/2.png)](https://2.bp.blogspot.com/-yQ-t7YWi-qI/V5rwi006AII/AAAAAAAAHyY/1ftZ1r6NWgQVEmiKy4uhK84XBGa4le3TQCLcB/s1600/2.png) [![](https://2.bp.blogspot.com/-eUqI2lewHEY/V5rwi_fRLXI/AAAAAAAAHyU/D-s4l_BrxWE2XOmsvflt-8s-Uo2arn95gCLcB/s640/3.png)](https://2.bp.blogspot.com/-eUqI2lewHEY/V5rwi_fRLXI/AAAAAAAAHyU/D-s4l_BrxWE2XOmsvflt-8s-Uo2arn95gCLcB/s1600/3.png) [![](https://2.bp.blogspot.com/-dbz2xrn6Veo/V5rwjJrehdI/AAAAAAAAHyc/zTVkWvQnVoMUaEVjPiL9TwqtZhTwYxeyQCLcB/s1600/4.png)](https://2.bp.blogspot.com/-dbz2xrn6Veo/V5rwjJrehdI/AAAAAAAAHyc/zTVkWvQnVoMUaEVjPiL9TwqtZhTwYxeyQCLcB/s1600/4.png)[![](https://3.bp.blogspot.com/-gY9k8ego5EE/V5rwjPDRHwI/AAAAAAAAHyg/7ICoznJNU74dBS7VPVp56-He_BOoF6HxwCLcB/s1600/5.png)](https://3.bp.blogspot.com/-gY9k8ego5EE/V5rwjPDRHwI/AAAAAAAAHyg/7ICoznJNU74dBS7VPVp56-He_BOoF6HxwCLcB/s1600/5.png)[![](https://2.bp.blogspot.com/-4HqmVn15BgY/V5rw-Q4Ow3I/AAAAAAAAHyk/kQKue8geuyUfymRmy-mPAhsTIKt_-iPSwCLcB/s1600/6.png)](https://2.bp.blogspot.com/-4HqmVn15BgY/V5rw-Q4Ow3I/AAAAAAAAHyk/kQKue8geuyUfymRmy-mPAhsTIKt_-iPSwCLcB/s1600/6.png) [![](https://3.bp.blogspot.com/-xa7G6erk2fM/V5rxkJIbLSI/AAAAAAAAHys/sTsfBXgEjCAPXHa1C4YXqdZ4VZLEHeSIgCLcB/s1600/1.png)](https://3.bp.blogspot.com/-xa7G6erk2fM/V5rxkJIbLSI/AAAAAAAAHys/sTsfBXgEjCAPXHa1C4YXqdZ4VZLEHeSIgCLcB/s1600/1.png) 接著寫一段程式，讓我們帶入ID能順利取回該筆員工資料[![](https://2.bp.blogspot.com/-iG0Vl0uUc0I/V5ryyt4eQoI/AAAAAAAAHy8/DsdR1LF6JycomPbTS1zop1NvFhb1C8olwCLcB/s1600/1.png)](https://2.bp.blogspot.com/-iG0Vl0uUc0I/V5ryyt4eQoI/AAAAAAAAHy8/DsdR1LF6JycomPbTS1zop1NvFhb1C8olwCLcB/s1600/1.png) 123456789101112131415161718192021222324252627282930313233public class EmployeesRepository :IDisposable &#123; NorthwindEntities DBContext; bool disposedValue; public EmployeesRepository() &#123; DBContext = new NorthwindEntities(); disposedValue = false; &#125; public Employees Get(int id) &#123; return DBContext.Employees.FirstOrDefault(x =&gt; x.EmployeeID == id); &#125; protected virtual void Dispose(bool disposing) &#123; if (!disposedValue) &#123; if (DBContext != null) DBContext.Dispose(); disposedValue = true; &#125; &#125; public void Dispose() &#123; Dispose(disposedValue); GC.SuppressFinalize(this); &#125; &#125; 改寫HomeController的Index Action，依據帶入的ID取回員工，並顯示於葉面上 [![](https://3.bp.blogspot.com/-nqGw1xVRRX0/V5r20E6fPAI/AAAAAAAAHzc/qRcvr7Lr_Os9IrcMr_1XqYnNJYTxKfVsgCLcB/s640/1.png)](https://3.bp.blogspot.com/-nqGw1xVRRX0/V5r20E6fPAI/AAAAAAAAHzc/qRcvr7Lr_Os9IrcMr_1XqYnNJYTxKfVsgCLcB/s1600/1.png) View的部分(一切從簡 XDD) [![](https://4.bp.blogspot.com/-Z3oYtUvXjqo/V5r3L10zYiI/AAAAAAAAHzg/RH5ZJQSpyHk5X8NVMhOpk7JA0rJT95nkQCLcB/s640/1.png)](https://4.bp.blogspot.com/-Z3oYtUvXjqo/V5r3L10zYiI/AAAAAAAAHzg/RH5ZJQSpyHk5X8NVMhOpk7JA0rJT95nkQCLcB/s1600/1.png) 來執行看看這段Code有沒有用!!! [![](https://1.bp.blogspot.com/-6bOfbEOFZ_M/V5r3beLjkWI/AAAAAAAAHzo/Q1YmS32wgeMfNPkUeJqFVVQDjRRmu-iKQCLcB/s640/1.png)](https://1.bp.blogspot.com/-6bOfbEOFZ_M/V5r3beLjkWI/AAAAAAAAHzo/Q1YmS32wgeMfNPkUeJqFVVQDjRRmu-iKQCLcB/s1600/1.png) [![](https://3.bp.blogspot.com/-NfsCSeUstAo/V5r3ooighWI/AAAAAAAAHzs/R94VplAsQn8XeC3QaeL9euzBNLf8NvPjACLcB/s1600/1.png)](https://3.bp.blogspot.com/-NfsCSeUstAo/V5r3ooighWI/AAAAAAAAHzs/R94VplAsQn8XeC3QaeL9euzBNLf8NvPjACLcB/s1600/1.png) 所以這段Code的確可以正常運作，確定之後我們來寫單元測試驗證這件事情。 首先在單元測試專案建立EmployeesRepositoryTests [![](https://3.bp.blogspot.com/-LVviiAdNxxs/V5r4xF2a5NI/AAAAAAAAHz8/8H5uWifglgYlr2hqA9WDZ5aageApPJrYACLcB/s1600/1.png)](https://3.bp.blogspot.com/-LVviiAdNxxs/V5r4xF2a5NI/AAAAAAAAHz8/8H5uWifglgYlr2hqA9WDZ5aageApPJrYACLcB/s1600/1.png) 上一篇有提到，這邊做的單元測試是每個測試前將準備好的CSV資料匯入LocalDB，做完測試後把資料全部砍掉，所以我們得先寫一段TestInitial讓每次測試之前先跑匯入資料的部分，先在單元測試專把CSVHelper安裝起來。 [![](https://2.bp.blogspot.com/--r9VuX4WFbQ/V5r5fTcTc_I/AAAAAAAAH0E/to6r2WGGomsVjlG3sQhFFworO3dAasVqgCLcB/s640/1.png)](https://2.bp.blogspot.com/--r9VuX4WFbQ/V5r5fTcTc_I/AAAAAAAAH0E/to6r2WGGomsVjlG3sQhFFworO3dAasVqgCLcB/s1600/1.png) 接著寫程式把資料從CSV讀出來，並寫入LocalDB，但首先先將測試專案安裝EntityFramwork套件 [![](https://4.bp.blogspot.com/-CbTTIt0AEHI/V5scdqAt-FI/AAAAAAAAH0U/ZiSP3YNeYMwuoUwkZ8dC6iTIq7EMZ8mkACLcB/s640/1.png)](https://4.bp.blogspot.com/-CbTTIt0AEHI/V5scdqAt-FI/AAAAAAAAH0U/ZiSP3YNeYMwuoUwkZ8dC6iTIq7EMZ8mkACLcB/s1600/1.png) 然後記得把連線字串加到單元測試的專案之中 1234&lt;connectionStrings&gt; &lt;add name=&quot;NorthwindEntities&quot; connectionString=&quot;metadata=res://*/Models.Northwind.csdl|res://*/Models.Northwind.ssdl|res://*/Models.Northwind.msl;provider=System.Data.SqlClient;provider connection string=&amp;quot;data source=(LocalDB)\\MSSQLLocalDB;attachdbfilename=|DataDirectory|\\TestDB.mdf;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework&amp;quot;&quot; providerName=&quot;System.Data.EntityClient&quot; /&gt;&lt;/connectionStrings&gt; 寫以下程式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System.Text;using Microsoft.VisualStudio.TestTools.UnitTesting;using WebApplication4.Models;using System.IO;using CsvHelper;using System.Linq;using System.Reflection;using System.Linq;namespace WebApplication4.Tests&#123; [TestClass] public class EmployeesRepositoryTests &#123; [TestInitialize] public void Initial() &#123; //讀取檔案 using (StreamReader reader = new StreamReader( string.Concat(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), @&quot;\\CSVs\\Employees.csv&quot;), new UTF8Encoding())) using (var csvReader = new CsvReader(reader)) &#123; csvReader.Configuration.WillThrowOnMissingField = false; var Employees = csvReader.GetRecords&lt;Employees&gt;().ToList(); //將資料寫入DB var DBContext = new NorthwindEntities(); DBContext.Employees.AddRange(Employees); DBContext.SaveChanges(); &#125; &#125; [TestMethod] public void Get_帶入ID_應取回該ID的Employee() &#123; //arrange var ID = 0; var Sut = new EmployeesRepository(); var Expected = &quot;Nancy&quot;; //act var actual = Sut.Get(ID); //assert Assert.AreEqual(Expected, actual.FirstName); &#125; &#125;&#125; 執行看看會發現爆掉了!!!!!! 果然事情不是憨人我想的那麼簡單 [![](https://1.bp.blogspot.com/--GWQvH-BzPo/V5srR-gwv8I/AAAAAAAAH0k/P2uj3DhlLwI1Q5ZTEPa0_E7CdwyQvMNngCLcB/s640/1.png)](https://1.bp.blogspot.com/--GWQvH-BzPo/V5srR-gwv8I/AAAAAAAAH0k/P2uj3DhlLwI1Q5ZTEPa0_E7CdwyQvMNngCLcB/s1600/1.png) 原因出在於Employee這個Table的ID欄位為流水自動編號，透過EF是無法寫入的，這時候只好透過Dapper下指令解決了，先安裝Dapper [![](https://3.bp.blogspot.com/-pST5pb51uh0/V5srvCR_TVI/AAAAAAAAH0o/rH5mdCRr574aqTB8_sQIQ6S2clZ4bcU1QCLcB/s640/1.png)](https://3.bp.blogspot.com/-pST5pb51uh0/V5srvCR_TVI/AAAAAAAAH0o/rH5mdCRr574aqTB8_sQIQ6S2clZ4bcU1QCLcB/s1600/1.png) 將剛剛從CSVHelper的資料用Dapper塞進去，而且要將Identity Insert打開，先補上要給Dapper用的連線字串 12&lt;add name=&quot;NorthwindString&quot; connectionString=&quot;Data Source=(LocalDB)\\MSSQLLocalDB;attachdbfilename=|DataDirectory|\\TestDB.mdf;Persist Security Info=True;&quot; providerName=&quot;System.Data.SqlClient&quot; /&gt; 把程式改成如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System.Text;using Microsoft.VisualStudio.TestTools.UnitTesting;using WebApplication4.Models;using System.IO;using CsvHelper;using System.Linq;using System.Reflection;using System.Data.SqlClient;using Dapper;namespace WebApplication4.Tests&#123; [TestClass] public class EmployeesRepositoryTests &#123; [TestInitialize] public void Initial() &#123; //讀取檔案 using (StreamReader reader = new StreamReader( string.Concat(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), @&quot;\\CSVs\\Employees.csv&quot;), new UTF8Encoding())) using (var csvReader = new CsvReader(reader)) &#123; csvReader.Configuration.WillThrowOnMissingField = false; var Employees = csvReader.GetRecords&lt;Employees&gt;().ToList(); //將資料寫入DB //var DBContext = new NorthwindEntities(); //DBContext.Employees.AddRange(Employees); //DBContext.SaveChanges(); using (var cn = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings[&quot;NorthwindString&quot;].ConnectionString)) &#123; cn.Execute(@&quot;SET IDENTITY_INSERT Employees ON INSERT INTO Employees (EmployeeID,LastName,FirstName,Title,TitleOfCourtesy,BirthDate,HireDate,Address,City,Region,PostalCode,Country,HomePhone,Extension,Notes,ReportsTo,PhotoPath) VALUES (@EmployeeID,@LastName,@FirstName,@Title,@TitleOfCourtesy,@BirthDate,@HireDate,@Address,@City,@Region,@PostalCode,@Country,@HomePhone,@Extension,@Notes,@ReportsTo,@PhotoPath) SET IDENTITY_INSERT Employees OFF&quot;, Employees); &#125; &#125; &#125; [TestMethod] public void Get_帶入ID_應取回該ID的Employee() &#123; //arrange var ID = 1; var Sut = new EmployeesRepository(); var Expected = &quot;Nancy&quot;; //act var actual = Sut.Get(ID); //assert Assert.AreEqual(Expected, actual.FirstName); &#125; &#125;&#125; 執行看看，就會發現終於成功了……. [![](https://1.bp.blogspot.com/-XvPJF-Zf0u8/V5su65wLx5I/AAAAAAAAH04/D4u0LHDen-EHvjOweb7yfV2r9aLUehYmACLcB/s320/1.png)](https://1.bp.blogspot.com/-XvPJF-Zf0u8/V5su65wLx5I/AAAAAAAAH04/D4u0LHDen-EHvjOweb7yfV2r9aLUehYmACLcB/s1600/1.png) 最後別忘了前面提到的，每個單元測試應該都是獨立的，所以既然每次都會寫資料進去，當然每次測試完也都要把資料砍掉啦 所以在單元測試的最後補上這個Method，讓他每個單元測試執行完畢後都會清掉資料```csharp [TestCleanup] public void CleanUp() { using (var cn = new SqlConnection(System.Configuration.ConfigurationManager.ConnectionStrings[\"NorthwindString\"].ConnectionString)) { cn.Execute(@\"Delete Employees\"); } } ``` 這樣就大功告成了!!!!","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】針對Repository做單元測試 (一)","slug":"【Unit-Test】針對Repository做單元測試-一","date":"2016-07-29T03:46:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2016/07/29/【Unit-Test】針對Repository做單元測試-一/","link":"","permalink":"https://toyo0103.github.io/2016/07/29/%E3%80%90Unit-Test%E3%80%91%E9%87%9D%E5%B0%8DRepository%E5%81%9A%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6-%E4%B8%80/","excerpt":"","text":"大部分的專案都會需要跟資料庫溝通，存取資料。雖然說開發的時候往往都有測試資料庫，但測試機料庫也可能因為很多人都在開發存取，導致資料可能會時常受到異動。單元測試的一大重點就是不管任何人、時、地，都要能測試成功，如果今天用來測試的資料庫可能面臨資料在不確定何時何人會異動的情境下，這可能會讓我們的單元測試雖然邏輯正確，但最後驗證失敗。例如:原本預期A會員權限有效，但因為測試資料庫別人也在使用開發，所以被改成失效，這時候你如果去跑單元測試就會亮起紅燈失敗，直到你去查了後才發現原來是源頭資料被改動了。為了解決這樣的問題，我們最好能創造一個資料庫只給單元測試使用，且能跟著專案走的(不然別人從Git把專案抓下來，沒有資料庫的情況下單元測試全掛掉…..這該如何是好)，所以LocalDB就是一個很好的選擇。第一篇就紀錄一下我如何建立LocalDB、並準備測試資料，這邊大部分都參考MRKT大師 : 測試專案使用 LocalDB - 使用 Entity Framework 的情境&nbsp;MRKT大師 :&nbsp;Dapper - 使用 LINQPad 快速產生相對映 SQL Command 查詢結果的類別，以及一些公司同事提供的方便小工具，非自己原創XD 第一步、建立專案來擺放LocalDB建立一般的Library Project [![](https://4.bp.blogspot.com/-QN2Lgo0WWLM/V5nWU8uV4rI/AAAAAAAAHwg/AjshLUxypfUm3whgktw12ZXq7ApXm3FGgCLcB/s640/1.png)](https://4.bp.blogspot.com/-QN2Lgo0WWLM/V5nWU8uV4rI/AAAAAAAAHwg/AjshLUxypfUm3whgktw12ZXq7ApXm3FGgCLcB/s1600/1.png) 接下在專案底下新增LocalDB [![](https://2.bp.blogspot.com/-8T2Ln5dZrpo/V5nWwfdpzFI/AAAAAAAAHwk/vk4Ujt5NUeMltYoBoSBlZnMSmv-HD27twCLcB/s640/1.png)](https://2.bp.blogspot.com/-8T2Ln5dZrpo/V5nWwfdpzFI/AAAAAAAAHwk/vk4Ujt5NUeMltYoBoSBlZnMSmv-HD27twCLcB/s1600/1.png) [![](https://4.bp.blogspot.com/-sfnO0MbA31s/V5rEVI9uucI/AAAAAAAAHw4/dHkcoCnpGTc_4O7I_BY0NKphzT2uP03vACLcB/s1600/1.png)](https://4.bp.blogspot.com/-sfnO0MbA31s/V5rEVI9uucI/AAAAAAAAHw4/dHkcoCnpGTc_4O7I_BY0NKphzT2uP03vACLcB/s1600/1.png) 第二步、幫LocalDB建立Schema (已NorthWind資料庫為例)基本上SSMS操作差不多，在資料表右鍵 &gt; 新增查詢，然後把Create Employees Table的Script貼過去執行 [![](https://2.bp.blogspot.com/-5ji6J1LhAWQ/V5rJYfKcExI/AAAAAAAAHxI/IFxpZPmJ5skP5CFyB11VLs-iKe0DLSnLACLcB/s1600/1.png)](https://2.bp.blogspot.com/-5ji6J1LhAWQ/V5rJYfKcExI/AAAAAAAAHxI/IFxpZPmJ5skP5CFyB11VLs-iKe0DLSnLACLcB/s1600/1.png) [![](https://3.bp.blogspot.com/-nqLVzU-QAqQ/V5rJolPPJII/AAAAAAAAHxM/Z99R12JALYgIIAq12h6mZGB4JdVBQl0HQCLcB/s640/1.png)](https://3.bp.blogspot.com/-nqLVzU-QAqQ/V5rJolPPJII/AAAAAAAAHxM/Z99R12JALYgIIAq12h6mZGB4JdVBQl0HQCLcB/s1600/1.png) 第三步、準備測試資料因為每個測試之間應該都是獨立的，為了避免互相干擾，所以資料通常不會預先倒到LocalDB裡面去，而是在執行每次測試時，動態的將準備好的資料寫進去，每個測試完畢後砍掉資料，這樣不停的重複著。 而一個Table的資料可能會很多很多，如果用手寫成SQL Script應該寫完專案DeadLine也過了，所以這邊打算將資料匯出到CSV檔案中，然後透過CSVHelper讀出來倒進DB，做法如下: 已下搭配LinqPad使用 ```csharp void Main() { // 這邊修改為你要執行的 SQL Command var sqlCommand = @\"select top 1 * from Employees\"; // 第一個參數填入 SQL Command, 第二個參數輸入要產生的 Class 名稱 this.Connection.DumpClass(sql: sqlCommand.ToString(), className: \"Employees\").Dump(); } public static class LINQPadExtensions { private static readonly Dictionary TypeAliases = new Dictionary { { typeof(int), \"int\" }, { typeof(short), \"short\" }, { typeof(byte), \"byte\" }, { typeof(byte[]), \"byte[]\" }, { typeof(long), \"long\" }, { typeof(double), \"double\" }, { typeof(decimal), \"decimal\" }, { typeof(float), \"float\" }, { typeof(bool), \"bool\" }, { typeof(string), \"string\" } }; private static readonly HashSet NullableTypes = new HashSet { typeof(int), typeof(short), typeof(long), typeof(double), typeof(decimal), typeof(float), typeof(bool), typeof(DateTime) }; public static string DumpClass(this IDbConnection connection, string sql, string className = \"Info\") { if (connection.State != ConnectionState.Open) { connection.Open(); } var cmd = connection.CreateCommand(); cmd.CommandText = sql; var reader = cmd.ExecuteReader(); var builder = new StringBuilder(); do { if (reader.FieldCount","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"[Config] 幫自訂的Config新增Release與Debug版本","slug":"Config-幫自訂的Config新增Release與Debug版本","date":"2016-07-06T04:05:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2016/07/06/Config-幫自訂的Config新增Release與Debug版本/","link":"","permalink":"https://toyo0103.github.io/2016/07/06/Config-%E5%B9%AB%E8%87%AA%E8%A8%82%E7%9A%84Config%E6%96%B0%E5%A2%9ERelease%E8%88%87Debug%E7%89%88%E6%9C%AC/","excerpt":"","text":"一般開發的時候通常會有測試機、正式機、或是Release前的機器…等，而在發佈到每台機器都要去做調整Config確實是很惱人的事情，感覺一個分神可能就會把測試機的連線貼到正式機之類的，這可能就是一場大災難。還好Visual Studio很貼心的為WebConfig分出了Release版本跟Debug版本，並依據發佈時你所選擇的組態檔，去做對應的修改。(註:如果需要更多版本，請到建置&nbsp;&gt;&nbsp;組態管理員去新增)。 [![](https://1.bp.blogspot.com/-bTABzkFPg84/V3yBI-o1a3I/AAAAAAAAHwE/Acz2x_EWkJMhQ6HTDpAVi3SuhLeuPiVCACLcB/s320/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://1.bp.blogspot.com/-bTABzkFPg84/V3yBI-o1a3I/AAAAAAAAHwE/Acz2x_EWkJMhQ6HTDpAVi3SuhLeuPiVCACLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)Release版本跟Debug版本 之前有寫篇文章[【擴充WebConfig】](http://toyo0103.blogspot.tw/2013/09/webconfigwebconfig.html)有提到如何在專案中加掛Config檔案，讓設定檔能做簡單的歸類整理。 原本以為Visual Studio應該會有相關的功能，可以對這類自訂的Config分割出對應版本，結果東找西找都找不到方法去做對應，原來VS似乎沒有提供這個功能(?) 還好在網路上找到了解決的套件跟方法 [How to add config transformations for a custom config file in Visual Studio?](http://stackoverflow.com/questions/34735132/how-to-add-config-transformations-for-a-custom-config-file-in-visual-studio) 簡單說就是先去下載VS擴充套件(註:目前似乎只支援到VS 2013)SlowCheetah - XML Transforms 安裝完後，用VS 2013開啟專案，並且對著想要分割版本的Config檔案按右鍵，選擇Add Transfom即可 [![](https://4.bp.blogspot.com/-rH4cnE-93Gc/V3yDHDPxl2I/AAAAAAAAHwQ/RtNpbTiBOKYsVad-Vjb_McHswPnPJy_pwCLcB/s320/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png)](https://4.bp.blogspot.com/-rH4cnE-93Gc/V3yDHDPxl2I/AAAAAAAAHwQ/RtNpbTiBOKYsVad-Vjb_McHswPnPJy_pwCLcB/s1600/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D.png) 搞定!!!! 之後再來寫篇如何透過Release Config檔在發佈時置換屬性值好了~","categories":[],"tags":[{"name":"Config","slug":"Config","permalink":"https://toyo0103.github.io/tags/Config/"},{"name":"webconfig","slug":"webconfig","permalink":"https://toyo0103.github.io/tags/webconfig/"}]},{"title":"【SQL】Group by and Top 1 (用Linq實做)","slug":"【SQL】Group-by-and-Top-1-用Linq實做","date":"2016-06-04T09:25:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2016/06/04/【SQL】Group-by-and-Top-1-用Linq實做/","link":"","permalink":"https://toyo0103.github.io/2016/06/04/%E3%80%90SQL%E3%80%91Group-by-and-Top-1-%E7%94%A8Linq%E5%AF%A6%E5%81%9A/","excerpt":"","text":"【SQL】Group by and Top 1之前有寫一篇是如何將資料歸類完後，取得各個分類第一筆的文章，歲月如梭竟然已經是2013年的文章了。 最近碰到相同的問題，卻需要用Linq來解決，研究了一下後來把他順便筆記下來，狀況全部呈第一篇文章的資料結構 12345var WhatAreYouDoing = from t in this.timeline group t by new &#123;t.location, t.who &#125; into Group select Group.OrderByDescending(x=&gt;x.time).Take(1); 這樣就能達到一樣的效果了(騙文章數來著?)","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"},{"name":"LINQ","slug":"LINQ","permalink":"https://toyo0103.github.io/tags/LINQ/"},{"name":"LINQ TO SQL","slug":"LINQ-TO-SQL","permalink":"https://toyo0103.github.io/tags/LINQ-TO-SQL/"}]},{"title":"【SQL】PIVOT 讓搜尋結果橫式表現","slug":"【SQL】PIVOT-讓搜尋結果橫式表現","date":"2016-03-08T01:49:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2016/03/08/【SQL】PIVOT-讓搜尋結果橫式表現/","link":"","permalink":"https://toyo0103.github.io/2016/03/08/%E3%80%90SQL%E3%80%91PIVOT-%E8%AE%93%E6%90%9C%E5%B0%8B%E7%B5%90%E6%9E%9C%E6%A9%AB%E5%BC%8F%E8%A1%A8%E7%8F%BE/","excerpt":"","text":"有時候SQL搜尋出來的資料是直式的，但偏偏PM們常常想看的卻是橫式報表，狀況模擬如下 1234567891011121314151617181920DECLARE @Report TABLE (CompanyName varchar(8),[Year] int,[Month] int,Revenue int)insert @Report values(&#x27;A公司&#x27;,2016,1,100)insert @Report values(&#x27;A公司&#x27;,2016,2,100)insert @Report values(&#x27;A公司&#x27;,2016,3,100)insert @Report values(&#x27;B公司&#x27;,2016,1,200)insert @Report values(&#x27;B公司&#x27;,2016,2,200)insert @Report values(&#x27;B公司&#x27;,2016,3,200)insert @Report values(&#x27;總公司&#x27;,2016,1,300)insert @Report values(&#x27;總公司&#x27;,2016,2,300)insert @Report values(&#x27;總公司&#x27;,2016,3,300)select * from @Report [![](https://3.bp.blogspot.com/-qirx6weBsrU/Vt4qvqqJUMI/AAAAAAAAHus/HnoX8Epl2xY/s320/1.png)](https://3.bp.blogspot.com/-qirx6weBsrU/Vt4qvqqJUMI/AAAAAAAAHus/HnoX8Epl2xY/s1600/1.png)這是資料在資料庫裡面的記錄方式 [![](https://4.bp.blogspot.com/-u18YG_Pkcro/Vt4rc9-XmnI/AAAAAAAAHuw/R12QCiukmio/s1600/1.png)](https://4.bp.blogspot.com/-u18YG_Pkcro/Vt4rc9-XmnI/AAAAAAAAHuw/R12QCiukmio/s1600/1.png)PM想看到的 還好MS SQL 2005之後提供PIVOT來解決這種問題，實際SQL如下 1234567891011121314151617select [date] as &#x27;年/月份&#x27;,[A公司] as &#x27;A公司&#x27; ,[B公司] as &#x27;B公司&#x27; ,([A公司] + [B公司] + [總公司]) as &#x27;總公司&#x27;from( select CompanyName, cast([Year] as char(4)) + &#x27;/&#x27; + cast([Month] as char(2)) as [date], Revenue from @Report group by CompanyName,[Year],[Month],Revenue) as TempReportTablePIVOT( sum(Revenue) for CompanyName in ([A公司] ,[B公司] ,[總公司]))as PivotTable [![](https://3.bp.blogspot.com/-iPNlxbN3F60/Vt4vAwWbJbI/AAAAAAAAHu8/UEDA-UufY6M/s320/1.png)](https://3.bp.blogspot.com/-iPNlxbN3F60/Vt4vAwWbJbI/AAAAAAAAHu8/UEDA-UufY6M/s1600/1.png)算出結果","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【Unit Test】重構 (二) 單元測試的可讀性","slug":"【Unit-Test】重構-二-單元測試的可讀性","date":"2016-03-07T02:03:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2016/03/07/【Unit-Test】重構-二-單元測試的可讀性/","link":"","permalink":"https://toyo0103.github.io/2016/03/07/%E3%80%90Unit-Test%E3%80%91%E9%87%8D%E6%A7%8B-%E4%BA%8C-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E7%9A%84%E5%8F%AF%E8%AE%80%E6%80%A7/","excerpt":"","text":"方法命名 &nbsp;: &nbsp;受測的方法名稱Test_動作_預期結果這樣可以看標題名稱，馬上就能大略的明白此單元測試的受測者與目標是什麼，對於之後如果改版發生單元錯誤時，也才能明白該如何修復 [![](https://3.bp.blogspot.com/-CaS4BNBA6a4/VtzcFkfagkI/AAAAAAAAHuQ/2mAf5riuHfk/s1600/1.png)](https://3.bp.blogspot.com/-CaS4BNBA6a4/VtzcFkfagkI/AAAAAAAAHuQ/2mAf5riuHfk/s1600/1.png)錯誤寫法&nbsp; &nbsp;哪天因為改版造成這個單元測試錯誤了，要修復時非得看完全部的Code才能明白何謂\"正確的狀況\"，對於維護來說是不利的 [![](https://2.bp.blogspot.com/-B7ro_7k5cAo/VtzauPAEglI/AAAAAAAAHuE/KnntqnWuvpQ/s640/1.png)](https://2.bp.blogspot.com/-B7ro_7k5cAo/VtzauPAEglI/AAAAAAAAHuE/KnntqnWuvpQ/s1600/1.png)建議寫法 共用的參數應該有個父類別來管理有時候我們會為了測試某些情境，對於public static的東西進行設定，但也因為這是public static的變數，為了避免與其它單元測試交互影響，所以我們會在TestCleanUp的方法中做清除的動作 [![](https://1.bp.blogspot.com/-t9BldDR6eJU/VtzepBta3lI/AAAAAAAAHug/Uv5g94SdikU/s640/1.png)](https://1.bp.blogspot.com/-t9BldDR6eJU/VtzepBta3lI/AAAAAAAAHug/Uv5g94SdikU/s1600/1.png) 但這種寫法如果散落在各個單元測試的Class之中，對於維護也是一大挑戰，所以建議建立一個TestBase之類的父類別，讓所有單元測試的類別繼承它，並統一管理。總結，單元測試是為了讓程式更有品質，且在一些保護的基礎上進行改版，但如果單元測試的撰寫沒有一些有效的管理，對於後續的維護成本可能會比沒單元測試來的更高更難維護，如果單元測試寫的不清不楚，誰會知道這個測試到底要保護什麼呢?","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"【Unit Test】重構 (一) 透過繼承解耦","slug":"【Unit-Test】重構-一-透過繼承解耦","date":"2016-03-02T07:46:00.000Z","updated":"2022-08-09T13:36:17.094Z","comments":true,"path":"2016/03/02/【Unit-Test】重構-一-透過繼承解耦/","link":"","permalink":"https://toyo0103.github.io/2016/03/02/%E3%80%90Unit-Test%E3%80%91%E9%87%8D%E6%A7%8B-%E4%B8%80-%E9%80%8F%E9%81%8E%E7%B9%BC%E6%89%BF%E8%A7%A3%E8%80%A6/","excerpt":"","text":"將一個本來沒有單元測試的專案，改成能測試的狀態，通常第一個遇到的問題就是耦合太深，導致無法切開來模擬外部對象，大幅度改動又可能牽扯很多Method與Class，在沒有測試保護下，怕改到壞掉而不自知。 以下記錄第一種重構方式，讓測試能在安全的重構之下進行 範例Code:原本的Legacy Code&nbsp;```csharp public class UnitTestSampleBase { public UnitTestSampleBase() { } public int WantUnitTestMethod() &#123; //直接引用,導致無法隔離測試 ThirdPartyObject tpObj = new ThirdPartyObject(); int value = tpObj.GetValue(); return value + 1; &#125; &#125; 123456789101112131415161718192021222324251. 分離耦合的部分 &#96;&#96;&#96;csharppublic class UnitTestSampleBase &#123; public UnitTestSampleBase() &#123; &#125; protected virtual int GetValue() &#123; &#x2F;&#x2F;開一個virtual的Method，將外部引用隔離出來 ThirdPartyObject tpobj &#x3D; new ThirdPartyObject(); return tpobj.GetValue(); &#125; public int WantUnitTestMethod() &#123; &#x2F;&#x2F;避免直接引用 int value &#x3D; GetValue(); return value + 1; &#125; &#125; 做一個Fake的受測對象，並繼承受測得目標，並改寫取得外部資源的結果的Method,讓它回傳我們寫死的固定值 ```csharppublic class UnitTestSampleFake : UnitTestSampleBase { protected override int GetValue() &#123; return 1; &#125; } 123456789101112131415161718193. 進行測試 &#96;&#96;&#96;csharp[TestClass] public class UnitTestSampleFakeTest &#123; [TestMethod] public void WantUnitTestMethod_Call_ShouldRetuen2() &#123; &#x2F;&#x2F;arrange var sut &#x3D; new UnitTestSampleFake(); &#x2F;&#x2F;act var actual &#x3D; sut.WantUnitTestMethod(); &#x2F;&#x2F;assert &#x2F;&#x2F;1+1 &#x3D; 2 Assert.AreEqual(actual, 2); &#125; &#125; 測試通過 這樣對於外部使用你的Mthod的人來說，他Code都不用改(因為你還是保有原本的MethodWantUnitTestMethod，且不需要額外的外部注入或參數注入)，但你的Code已經做了初步的分離跟測試，之後就可以慢慢在這個測試保護的基礎之上，繼續後續的開發了!!","categories":[],"tags":[{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"}]},{"title":"Regular Expression 苦手筆記","slug":"Regular-Expression-苦手筆記","date":"2016-03-01T06:30:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2016/03/01/Regular-Expression-苦手筆記/","link":"","permalink":"https://toyo0103.github.io/2016/03/01/Regular-Expression-%E8%8B%A6%E6%89%8B%E7%AD%86%E8%A8%98/","excerpt":"","text":"Regular Expression(後面簡稱RE)真的是一個非常難以閱讀的語言，從大學時期初次碰到，到現在當工程師已經5年多，常常碰到都還是要翻找書籍和嘗試很久才能寫出自己想要的東西，這邊就做點簡單的筆記避免之後又忘記了。 範例:如果今天我有一段Log如下 =================================================2016-02-25 00:05:50.9017 | INFO | TID:9 | Request:Method: GET, RequestUri: ‘http://regularexpression.com.tw/v1/1456329948291/500‘, Version: 1.1, Content: System.Web.Http.WebHost.HttpControllerHandler+LazyStreamContent, Headers:{&nbsp; Connection: keep-alive&nbsp; Accept-Encoding: gzip&nbsp; Host:&nbsp;regularexpression.com.tw&nbsp; X-YC-IM-Device-OS: 2&nbsp; X-YC-IM-Token: Token&nbsp; X-Forwarded-For: xx.xxx.xxx.xxx&nbsp; X-Forwarded-Port: 443&nbsp; X-Forwarded-Proto: https&nbsp; Process-Start-Time: Time: 2016-02-25 00:05:50.183&nbsp; Process–End–Time: Time: 2016-02-25 00:05:50.901&nbsp; Process-Time-Count: Ticks: 7141131, 714 ms&nbsp; Content-Length: 0}================================================= 我想節錄出紅字的部分，我自己解法如下 首先因為RE具有將斷行視為一個完整句子的特性，所以要跨行搜尋變的很困難，所以我先會將斷行符號換成自己定義的連結符號，好讓整段Log可以變成一個連貫的字串 ```csharpcontent.Replace(Environment.NewLine,”&lt;^^&gt;”);12345678910111213141516171819202122232425262728293031322. 接著RE Pattern如下**&#123;% note info %&#125;&#x2F;Method:\\s(?&lt;mehtod&gt;[^,]*),\\sRequestUri:\\s&#39;(?&lt;uri&gt;[^&#39;]*)&#39;,.*?X-YC-IM-Token:\\s(?&lt;token&gt;[^&lt;]*)&lt;\\^\\^&gt;.*?Process-Time-Count:\\sTicks:\\s[0-9]+,\\s(?&lt;processTime&gt;[^&lt;]*)&lt;\\^\\^&gt;&#x2F;&#123;% endnote %&#125;** **@解析**Method:\\s(?&lt;mehtod&gt;**&lt;span style&#x3D;&quot;color: red;&quot;&gt;[^,]&lt;&#x2F;span&gt;***),****\\s為空白字元，所以等於從Method: 開始到下一個不是**&lt;span style&#x3D;&quot;color: red;&quot;&gt;逗號&lt;&#x2F;span&gt;**的字元抓出來儲存到method這個參數之中@**解析**\\sRequestUri:\\s&#39;(?&lt;uri&gt;**&lt;span style&#x3D;&quot;color: red;&quot;&gt;[^&#39;]&lt;&#x2F;span&gt;***)&#39;,從 RequestUri: &#39;開始到下一個不是&amp;nbsp;&lt;span style&#x3D;&quot;color: red;&quot;&gt;&#39;&amp;nbsp;&lt;&#x2F;span&gt;的字元抓出來儲存到uri這個參數之中@**解析.*?X-YC-IM-Token:\\s(?&lt;token&gt;&lt;span style&#x3D;&quot;color: red;&quot;&gt;[^&lt;]&lt;&#x2F;span&gt;*)&lt;\\^\\^&gt;**之後接著N個字元直到出現**X-YC-IM-Token: **將**&amp;nbsp;之後抓取N個字元直到出現****&lt;span style&#x3D;&quot;color: red;&quot;&gt;&lt;&lt;&#x2F;span&gt;為止，**儲存到token。這邊特別提一下這段最前面的.*?，如果我們的Log只有這麼一段沒有太大問題，如果我們的Log是重複上面的格式出現很多串，如果單純只下**.*X-YC-IM-Token也就是少了**&lt;span style&#x3D;&quot;color: red;&quot;&gt;問號&lt;&#x2F;span&gt;，那他就會一直抓且跨很多段Log直到最後一個**X-YC-IM-Token**出現為止。 ?號有與沒有差別在於貪婪搜尋，有問號表示非貪婪模式，搜尋到第一個符合的即停3. 後面的符號都出現過也一直重複，所以就不另外說明，在.NET中要取出剛剛用RE儲存的參數寫法如下&#96;&#96;&#96;csharpcontent &#x3D; content.Replace(Environment.NewLine,&quot;&lt;^^&gt;&quot;);string pattern &#x3D; @&quot;Method:\\s(?&lt;mehtod&gt;[^,]*),\\sRequestUri:\\s&#39;(?&lt;uri&gt;[^&#39;]*)&#39;,.*?X-YC-IM-Token:\\s(?&lt;token&gt;[^&lt;]*)&lt;\\^\\^&gt;.*?Process-Time-Count:\\sTicks:\\s[0-9]+,\\s(?&lt;processTime&gt;[^&lt;]*)&lt;\\^\\^&gt;&quot;; Regex reg &#x3D; new Regex(pattern, RegexOptions.IgnoreCase); MatchCollection matches &#x3D; reg.Matches(content);foreach (Match match in matches)&#123;Console.WriteLine(match.Groups[&quot;mehtod&quot;].Value);Console.WriteLine(match.Groups[&quot;uri&quot;].Value);Console.WriteLine(match.Groups[&quot;token&quot;].Value);Console.WriteLine(match.Groups[&quot;processTime&quot;].Value);&#125; 以下附錄來源 : 就是愛程式 -&nbsp;正規表示式 Regular Expression 正規表示式說明及範例比對不成立之字串/a/含字母 “a” 的字串，例如 “ab”, “bac”, “cba”“xyz”/a./含字母 “a” 以及其後任一個字元的字串，例如 “ab”, “bac”（若要比對.，請使用 \\.）“a”, “ba”/^xy/以 “xy” 開始的字串，例如 “xyz”, “xyab”（若要比對 ^，請使用 \\^）“axy”, “bxy”/xy$/以 “xy” 結尾的字串，例如 “axy”, “abxy”以 “xy” 結尾的字串，例如 “axy”, “abxy” （若要比對 $，請使用 \\$）“xya”, “xyb”[13579]包含 “1” 或 “3” 或 “5” 或 “7” 或 “9” 的字串，例如：”a3b”, “1xy”“y2k”[0-9]含數字之字串不含數字之字串[a-z0-9]含數字或小寫字母之字串不含數字及小寫字母之字串[a-zA-Z0-9]含數字或字母之字串不含數字及字母之字串b[aeiou]t“bat”, “bet”, “bit”, “bot”, “but”“bxt”, “bzt”[^0-9]不含數字之字串（若要比對 ^，請使用 \\^）含數字之字串[^aeiouAEIOU]不含母音之字串（若要比對 ^，請使用 \\^）含母音之字串[^\\^]不含 “^” 之字串，例如 “xyz”, “abc”“xy^”, “a^bc”.正規表示式的特定字元說明等效的正規表示式\\d數字[0-9]\\D非數字[^0-9]\\w數字、字母、底線[a-zA-Z0-9_]\\W非 \\w[^a-zA-Z0-9_]\\s空白字元[ \\r\\t\\n\\f]\\S非空白字元[^ \\r\\t\\n\\f].正規表示式說明/a?/零或一個 a（若要比對? 字元，請使用 \\?）/a+/一或多個 a（若要比對+ 字元，請使用 \\+）/a*/零或多個 a（若要比對* 字元，請使用 \\*）/a{4}/四個 a/a{5,10}/五至十個 a/a{5,}/至少五個 a/a{,3}/至多三個 a/a.{5}b/a 和 b中間夾五個（非換行）字元.字元說明簡單範例\\避開特殊字元/A\\*/ 可用於比對 “A*”，其中 * 是一個特殊字元，為避開其特殊意義，所以必須加上 “\\”^比對輸入列的啟始位置/^A/ 可比對 “Abcd” 中的 “A”，但不可比對 “aAb”$比對輸入列的結束位置/A$/ 可比對 “bcdA” 中的 “A”，但不可比對 “aAb”*比對前一個字元零次或更多次/bo*/ 可比對 “Good boook” 中的 “booo”，亦可比對 “Good bk” 中的 “b”+比對前一個字元一次或更多次，等效於 {1,}/a+/ 可比對 “caaandy” 中的 “aaa”，但不可比對 “cndy”?比對前一個字元零次或一次/e?l/ 可比對 “angel” 中的 “el”，也可以比對 “angle” 中的 “l”.比對任何一個字元（但換行符號不算）/.n/ 可比對 “nay, an apple is on the tree” 中的 “an” 和 “on”，但不可比對 “nay”(x)比對 x 並將符合的部分存入一個變數/(a*) and (b*)/ 可比對 “aaa and bb” 中的 “aaa” 和 “bb”，並將這兩個比對得到的字串設定至變數 RegExp.$1 和 RegExp.$2。xy比對 x 或 y/a*b*/g 可比對 “aaa and bb” 中的 “aaa” 和 “bb”{n}比對前一個字元 n 次，n 為一個正整數/a{3}/ 可比對 “lllaaalaa” 其中的 “aaa”，但不可比對 “aa”{n,}比對前一個字元至少 n 次，n 為一個正整數/a{3,}/ 可比對 “aa aaa aaaa” 其中的 “aaa” 及 “aaaa”，但不可比對 “aa”{n,m}比對前一個字元至少 n 次，至多 m 次，m、n 均為正整數/a{3,4}/ 可比對 “aa aaa aaaa aaaaa” 其中的 “aaa” 及 “aaaa”，但不可比對 “aa” 及 “aaaaa”[xyz]比對中括弧內的任一個字元/[ecm]/ 可比對 “welcome” 中的 “e” 或 “c” 或 “m”[^xyz]比對不在中括弧內出現的任一個字元/[^ecm]/ 可比對 “welcome” 中的 “w”、”l”、”o”，可見出其與 [xyz] 功能相反。（同時請注意 /^/ 與 [^] 之間功能的不同。）[\\b]比對退位字元（Backspace character）可以比對一個 backspace ，也請注意 [\\b] 與 \\b 之間的差別\\b比對英文字的邊界，例如空格例如 /\\bn\\w/ 可以比對 “noonday” 中的 ‘no’ ; /\\wy\\b/ 可比對 “possibly yesterday.” 中的 ‘ly’\\B比對非「英文字的邊界」例如, /\\w\\Bn/ 可以比對 “noonday” 中的 ‘on’ , 另外 /y\\B\\w/ 可以比對 “possibly yesterday.” 中的 ‘ye’\\cX比對控制字元（Control character），其中 X 是一個控制字元/\\cM/ 可以比對 一個字串中的 control-M\\d比對任一個數字，等效於 [0-9]/[\\d]/ 可比對 由 “0” 至 “9” 的任一數字 但其餘如字母等就不可比對\\D比對任一個非數字，等效於 [^0-9]/[\\D]/ 可比對 “w” “a”… 但不可比對如 “7” “1” 等數字\\f比對 form-feed若是在文字中有發生 “換頁” 的行為 則可以比對成功\\n比對換行符號若是在文字中有發生 “換行” 的行為 則可以比對成功\\r比對 carriage return\\s比對任一個空白字元（White space character），等效於 [ \\f\\n\\r\\t\\v]/\\s\\w*/ 可比對 “A b” 中的 “b”\\S比對任一個非空白字元，等效於 [^ \\f\\n\\r\\t\\v]/\\S/\\w* 可比對 “A b” 中的 “A”\\t比對定位字元（Tab）\\v比對垂直定位字元（Vertical tab）\\w比對數字字母字元（Alphanumerical characters）或底線字母（”_”），等效於 [A-Za-z0-9_]/\\w/ 可比對 “.A _!9” 中的 “A”、”_”、”9〃。\\W比對非「數字字母字元或底線字母」，等效於 [^A-Za-z0-9_]/\\W/ 可比對 “.A _!9” 中的 “.”、” “、”!”，可見其功能與 /\\w/ 恰好相反。\\o_octal_比對八進位，其中_octal是八進位數目_/\\oocetal123/ 可比對 與 八進位的ASCII中 “123” 所相對應的字元值。\\x_hex_比對十六進位，其中_hex是十六進位數目_/\\xhex38/ 可比對 與 16進位的ASCII中 “38” 所相對應的字元。 好用的Regular expression測試網站 : &nbsp;http://www.rubular.com/延伸閱讀 : 貪婪與非貪婪效能問題","categories":[],"tags":[{"name":"Regular Expression","slug":"Regular-Expression","permalink":"https://toyo0103.github.io/tags/Regular-Expression/"}]},{"title":"Async Await DeadLock問題","slug":"Async-Await-DeadLock問題","date":"2016-01-20T06:52:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2016/01/20/Async-Await-DeadLock問題/","link":"","permalink":"https://toyo0103.github.io/2016/01/20/Async-Await-DeadLock%E5%95%8F%E9%A1%8C/","excerpt":"","text":"之前寫了一個簡單上傳圖片的功能，碰到用await跟async非同執行的問題，本來在本機Visual Studio偵錯執行Run都好好的，但是放到線上後就永遠得不到回應TimeOut 隱隱約約記得之前黑大寫過類似的文章，當時看過沒啥特別感覺，翻回來看後在實際操作後終於弄懂了(果然寫程式很多地方一知半解會GG的)，關於Async、Await這些推薦可以看這兩篇文章 Huan-Lin 學習筆記-async 與 await黑暗執行緒-&nbsp;await與Task.Result/Task.Wait()的Deadlock問題 兩位前輩大大已經寫的很完整詳盡了，在這邊就不獻醜了，只簡單提供個範例給有興趣的人玩玩 12345678910111213141516171819202122232425262728293031323334353637383940public class DeadLockController : ApiController &#123; [HttpGet] [Route(&quot;api/DeadLock/Index&quot;)] public HttpResponseMessage Index() &#123; Task&lt;int&gt; mytask = Go(); mytask.Wait(); return Request.CreateResponse(mytask.Result); &#125; [HttpGet] [Route(&quot;api/DeadLock&quot;)] public HttpResponseMessage DeadLock() &#123; var result = Go().Result; return Request.CreateResponse(result); &#125; [HttpGet] [Route(&quot;api/DeadLock/NoDeadLock&quot;)] public async Task&lt;HttpResponseMessage&gt; NoDeadLock() &#123; var result = await Go(); return Request.CreateResponse(result); &#125; private async Task&lt;int&gt; Go() &#123; int res = 0; await Task.Run(() =&gt; &#123; //假裝執行某個耗時程序後取得結果 Task.Delay(1000); res = 32767; &#125;); return res; &#125; &#125; 這邊只有NoDeadLock那個Action的寫法才不會DeadLock,其餘兩個永遠都不會得到回應，原因簡單的說就是在Web中**(特別強調在Web中，因為Console並不會)**，.Result 與 Wait()的方法都會鎖定目前的Thread等待結果回應再繼續執行，而上面的範例GO()這個Method在Web中會記住是哪個Thread來呼叫他的，以便他執行完後回應該Thread結果繼續執行。 這時候就會發生DeadLock了，因為外面用Wait() or .Result鎖住當前Thread，GO()這個Method又在等待他被釋放好跟他回應結果，互相等待也就DeadLock了。 前面兩篇文章很久以前就看過了，只是當時沒有特別放在心上，直到被這個簡單到只有5行Code的東西困擾了3~4天，才終於想到有這件事情，現在不懂沒關係，等到被鎖一次就懂了(吶喊!!)","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"},{"name":"Async","slug":"Async","permalink":"https://toyo0103.github.io/tags/Async/"},{"name":"WebAPI","slug":"WebAPI","permalink":"https://toyo0103.github.io/tags/WebAPI/"}]},{"title":"[Linq]動態組合Linq條件","slug":"Linq-動態組合Linq條件","date":"2016-01-11T07:11:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2016/01/11/Linq-動態組合Linq條件/","link":"","permalink":"https://toyo0103.github.io/2016/01/11/Linq-%E5%8B%95%E6%85%8B%E7%B5%84%E5%90%88Linq%E6%A2%9D%E4%BB%B6/","excerpt":"","text":"以前寫Linq的時候常常碰到一個問題,就是判斷一個條件是否達成來決定Linq的Where條件該如何組合,例如: 12345678910111213141516171819202122232425262728293031323334353637383940414243void Main()&#123; bool Flag = true; List&lt;DealDataForGov&gt; SourceData = new List&lt;DealDataForGov&gt; &#123; new DealDataForGov &#123; Address = &quot;台北市xxxx&quot;, HouseKind = &quot;a1&quot;, Year = 2015 &#125;, new DealDataForGov &#123; Address = &quot;高雄市xxxx&quot;, HouseKind = &quot;a1&quot;, Year = 2016 &#125;, new DealDataForGov &#123; Address = &quot;台中市xxxx&quot;, HouseKind = &quot;c1&quot;, Year = 2014 &#125; &#125; if (Flag) &#123; SourceData.Where((x) =&gt; x.HouseKind == &quot;a1&quot;); &#125; else &#123; //因為某個條件,新增新的搜尋條件 SourceData.Where((x) =&gt; x.HouseKind ==&quot;a1&quot; &amp;&amp; x.Year &gt;= 2015 ); &#125;&#125;public class DealDataForGov&#123; public string Address &#123; get; set; &#125; public string HouseKind &#123; get; set; &#125; public int Year &#123;get;set;&#125;&#125; 條件少還算好寫，一旦條件落落長的時候就會貼的到處都是，不僅彈性降低也讓維護增加困難度，還好在黑大那邊看到LINQKIT這個好東西黑暗執行緒-組裝動態LINQ條件的利器－LINQKit 以下簡短介紹一下這個LINQKit的套件，有了他之後感覺Code都活過來了XD範例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void Main()&#123; List&lt;TargetModel&gt; SourceData = new List&lt;TargetModel&gt; &#123; new TargetModel &#123; Address = &quot;台北市xxxx&quot;, HouseKind = &quot;a1&quot;, Year = 2015 &#125;, new TargetModel &#123; Address = &quot;高雄市xxxx&quot;, HouseKind = &quot;a1&quot;, Year = 2016 &#125;, new TargetModel &#123; Address = &quot;台中市xxxx&quot;, HouseKind = &quot;c1&quot;, Year = 2014 &#125; &#125;; var expression = GetWhereExpression(); //SourceData.Where((x) =&gt; x.HouseKind == &quot;a1&quot;); var e1 = SourceData.Where(expression.Compile()); e1.Dump(); //SourceData.Where((x) =&gt; x.HouseKind ==&quot;a1&quot; &amp;&amp; x.Year &gt; 2015 ); var e2 = SourceData.Where(expression.And(x =&gt; x.Year &gt; 2015).Compile()); e2.Dump(); //SourceData.Where((x) =&gt; x.HouseKind ==&quot;a1&quot; || x.Year &gt;=2014 ); var e3 = SourceData.Where(expression.Or(x =&gt; x.Year &gt;= 2014).Compile()); e3.Dump();&#125;public Expression&lt;Func&lt;TargetModel, bool&gt;&gt; GetWhereExpression()&#123; var pred = PredicateBuilder.True&lt;TargetModel&gt;(); pred = pred.And(x=&gt; x.HouseKind ==&quot;a1&quot;); return pred;&#125;public class TargetModel&#123; public string Address &#123; get; set; &#125; public string HouseKind &#123; get; set; &#125; public int Year &#123;get;set;&#125;&#125; 上面有三個範例分別是替代掉註解的寫法,如果有碰到很多條件會動態產生的結果,用LinqKit可以大幅度省掉很多Code以及維護上的複雜度。算是非常好用的小物，推薦給大家","categories":[],"tags":[{"name":"LINQ","slug":"LINQ","permalink":"https://toyo0103.github.io/tags/LINQ/"}]},{"title":"【SQL】遞迴","slug":"【SQL】遞迴","date":"2015-12-14T02:08:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2015/12/14/【SQL】遞迴/","link":"","permalink":"https://toyo0103.github.io/2015/12/14/%E3%80%90SQL%E3%80%91%E9%81%9E%E8%BF%B4/","excerpt":"","text":"有張表格如下，Parent欄位代表他的父層的RegionID，所以裡面包含所有縣市、行政區、鄉里等資料，那要如何用SQL遞迴的方式把台北市用階層的方式表列出來呢?台北市 &gt; 信義區、大安區、中正區…. &gt;&nbsp;港華里、老泉里….. 用CTE的寫法可以解決，把台北市當做茅點，然後Join自己即可達到遞迴的效果 12345678910111213with 遞迴 as(------茅點 start-------SELECT RegionID , NameFROM Region aWHERE RegionID = 1 --台北市------茅點 end ---------union allselect b.RegionID , b.namefrom Region bjoin 遞迴 on b.Parent = 遞迴.RegionID)select * from 遞迴 搜尋出來的結果","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【WebAPI】Custom ActionFilter Order","slug":"【WebAPI】Custom-ActionFilter-Order","date":"2015-12-14T02:08:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2015/12/14/【WebAPI】Custom-ActionFilter-Order/","link":"","permalink":"https://toyo0103.github.io/2015/12/14/%E3%80%90WebAPI%E3%80%91Custom-ActionFilter-Order/","excerpt":"","text":"ActionAttribute 環境 : WebAPI 2.2 詳細 在WebAPI中，通常都繪有需要客製化ActionFilter的情況發生 執行順序不固定ActionFilter的執行順序並非在上面的就優先執行，Filter有個FilterScope來表示他屬於何種層級的ActionFilter，執行順序依次是 Global , Controller , Action 。但如果是在同一層級的ActionFilter順序則未必按照固定。 ] 測試 裡面全部都一樣繼承ActionFilterAttribute即可 1public class FourAttribute :ActionFilterAttribute&#123; &#125; 註冊OneAttribute到Global 將其它Attribute分別註冊到Controller與Action 在Get中補上以下程式然後執行看看 12345678910111213141516171819[HttpGet][Three][Four]public IEnumerable&lt;Tuple&lt;string,string&gt;&gt; Get()&#123; IHttpActionSelector actionSelector = this.Configuration.Services.GetActionSelector(); HttpActionDescriptor actionDescriptor = actionSelector.SelectAction(this.ControllerContext); foreach (FilterInfo filterInfo in actionDescriptor.GetFilterPipeline()) &#123; yield return new Tuple&lt;string, string&gt;( filterInfo.Instance.GetType().Name, filterInfo.Scope.ToString() ); &#125;&#125; 測試結果 排序依據所對應的層級，雖然這邊排序與我們在程式上的排序相同。但實際上順序同層級的順序未必是由上而下，為了避免這樣的問題，最好的方法就是在ActionFilter加上排序的屬性來解決。 實作Order屬性定義IOrderAttribute123456789public interface IOrderAttribute&#123; int Order &#123; get; set; &#125;&#125;public class FourAttribute : ActionFilterAttribute, IOrderAttribute&#123; public int Order &#123; get; set; &#125;&#125; 實做IComparable介面123456789101112131415161718192021222324252627282930313233public class CustomFilterInfo : IComparable &#123; public IFilter Instance &#123; get; set; &#125; public FilterScope Scope &#123; get; set; &#125; //FilterInfo public CustomFilterInfo(IFilter instance, FilterScope scope) &#123; this.Instance = instance; this.Scope = scope; &#125; public int CompareTo(object obj) &#123; if (obj is CustomFilterInfo) &#123; var item = obj as CustomFilterInfo; if (item.Instance is IAttribute) &#123; var attr = item.Instance as IAttribute; return (this.Instance as IAttribute).Order.CompareTo(attr.Order); &#125; &#125; return 0; &#125; public FilterInfo ConvertToFilterInfo() &#123; return new FilterInfo(this.Instance, this.Scope); &#125; &#125; 實做IFilterProvider介面123456789101112131415161718192021public class CustomFilterProvider : IFilterProvider&#123; public IEnumerable&lt;FilterInfo&gt; GetFilters( HttpConfiguration configuration, HttpActionDescriptor actionDescriptor) &#123; IEnumerable&lt;CustomFilterInfo&gt; customActionFilters = actionDescriptor.GetFilters() .Select(i =&gt; new CustomFilterInfo(i, FilterScope.Controller)); IEnumerable&lt;CustomFilterInfo&gt; customControllerFilters = actionDescriptor.ControllerDescriptor .GetFilters() .Select(i =&gt; new CustomFilterInfo(i, FilterScope.Controller)); return customControllerFilters.Concat(customActionFilters) .OrderBy(i =&gt; i) .Select(i =&gt; i.ConvertToFilterInfo()); &#125;&#125; Global註冊1234567891011121314151617181920212223protected void Application_Start()&#123; AreaRegistration.RegisterAllAreas(); GlobalConfiguration.Configure(WebApiConfig.Register); FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters); GlobalConfiguration.Configuration.Formatters.XmlFormatter.SupportedMediaTypes.Clear(); //註冊Global Attribute GlobalConfiguration.Configuration.Filters.Add(new OneAttribute()); //新增CustomFilterProvider GlobalConfiguration.Configuration.Services.Add( typeof(System.Web.Http.Filters.IFilterProvider), new CustomFilterProvider()); var providers = GlobalConfiguration.Configuration.Services.GetFilterProviders(); var defaultprovider = providers.First(i =&gt; i is ActionDescriptorFilterProvider); //移除DefaultProvider GlobalConfiguration.Configuration.Services.Remove( typeof(System.Web.Http.Filters.IFilterProvider), defaultprovider);&#125; 測試將Attibute補上Order再執行看看得到的順序 可以看到Four排在Three的前面了","categories":[],"tags":[{"name":"WebAPI","slug":"WebAPI","permalink":"https://toyo0103.github.io/tags/WebAPI/"}]},{"title":"AutoMapper與Json.NET JObject對應問題","slug":"AutoMapper與Json-NET-JObject對應問題","date":"2015-12-08T08:42:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2015/12/08/AutoMapper與Json-NET-JObject對應問題/","link":"","permalink":"https://toyo0103.github.io/2015/12/08/AutoMapper%E8%88%87Json-NET-JObject%E5%B0%8D%E6%87%89%E5%95%8F%E9%A1%8C/","excerpt":"","text":"使用套件:Json.NET 7.0.1 :&nbsp;https://www.nuget.org/packages/Newtonsoft.Json/7.0.1AutoMapper 4.04 :&nbsp;https://www.nuget.org/packages/AutoMapper/4.0.4 今天碰到一個問題，就是有個API回傳值的欄位是不固定無法掌握的，所以只好在轉型成強型別時以object當做該屬性的類別，但JsonConvert碰到類別為Object的東西就會轉成JObject ,而AutoMapper對應JObject會炸掉。以下是簡單時間的範例Code 12345678910111213141516171819202122232425262728void Main()&#123; Mapper.CreateMap&lt;source, destination&gt;() .ForMember(d =&gt; d.d_name, o =&gt; o.MapFrom(s =&gt; s.name)) .ForMember(d =&gt; d.d_obj, o =&gt; o.MapFrom(s =&gt; s.obj)); source test = new source &#123; name = &quot;test&quot;, obj = new &#123;code = 100&#125;, &#125;; var result = Mapper.Map&lt;destination&gt;(test); result.Dump();&#125;public class source&#123; public string name &#123; get; set; &#125; public object obj &#123; get; set; &#125;&#125;public class destination&#123; public string d_name &#123; get; set; &#125; public object d_obj &#123; get; set; &#125;&#125; Source與Destination都有個property為object的類別屬性，在Main()裡面也想好兩個類別的對應關係，並且先準備好Source 然後透過AutoMapper轉出Result,在以上的範例執行正確沒問題 換個寫法 1234567891011121314151617181920212223void Main()&#123; Mapper.CreateMap&lt;source, destination&gt;() .ForMember(d =&gt; d.d_name, o =&gt; o.MapFrom(s =&gt; s.name)) .ForMember(d =&gt; d.d_obj, o =&gt; o.MapFrom(s =&gt; s.obj)); source test = JsonConvert.DeserializeObject&lt;source&gt;(&quot;&#123;\\&quot;name\\&quot;:\\&quot;test\\&quot;,\\&quot;obj\\&quot; : &#123;\\&quot;code\\&quot;:100&#125;&#125;&quot;); var result = Mapper.Map&lt;destination&gt;(test); result.Dump();&#125;public class source&#123; public string name &#123; get; set; &#125; public object obj &#123; get; set; &#125;&#125;public class destination&#123; public string d_name &#123; get; set; &#125; public object d_obj &#123; get; set; &#125;&#125; 差別只在於原本Source改成透過Json.Net由字串轉回來而已，這時候只要執行到AutoMapper那一行就會爆炸，錯誤訊息如下 AutoMapperMappingException: Mapping types:JObject -&gt; JObjectNewtonsoft.Json.Linq.JObject -&gt; Newtonsoft.Json.Linq.JObjectDestination path:destination.d_obj.d_objSource value:{ “code”: 100} JsonConvert碰到目標為Object型別的欄位，會轉成JObject塞進去，AutoMapper用它來對應，所以如果要解決這個問題需要做一些處理 12345678910111213//將Mapper改成如下 Mapper.CreateMap&lt;source, destination&gt;() .ForMember(d =&gt; d.d_name, o =&gt; o.MapFrom(s =&gt; s.name)) .ForMember(d =&gt; d.d_obj, o =&gt; o.ResolveUsing(s =&gt; &#123; if (s.obj is JObject) &#123; var temp = s.obj as JObject; return temp.ToObject&lt;Dictionary&lt;string, object&gt;&gt;(); &#125; return s.obj; &#125;)); 這樣就可以正確地取出了","categories":[],"tags":[{"name":"AutoMapper","slug":"AutoMapper","permalink":"https://toyo0103.github.io/tags/AutoMapper/"},{"name":"JSON","slug":"JSON","permalink":"https://toyo0103.github.io/tags/JSON/"}]},{"title":"【MVC】EditorTemplate (二) 動態新增欄位","slug":"【MVC】EditorTemplate-二-動態新增欄位","date":"2015-12-03T09:08:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2015/12/03/【MVC】EditorTemplate-二-動態新增欄位/","link":"","permalink":"https://toyo0103.github.io/2015/12/03/%E3%80%90MVC%E3%80%91EditorTemplate-%E4%BA%8C-%E5%8B%95%E6%85%8B%E6%96%B0%E5%A2%9E%E6%AC%84%E4%BD%8D/","excerpt":"","text":"此篇範例程式 :&nbsp;下載&nbsp; (此範例在DynamicController之中) 呈上一篇，EditorTemplate (一)&nbsp;我們可以來看到產生的原始碼如下 Name的部分是由 productList[index].屬性名組成，換句話說，如果今天要由前端動態新增一筆書籍資料，則必須按照這個規則編排下去，後端才能透過ViewModel的方式取得書籍資料 看起來一切美好圓滿，但如果今天的列表是可以新增之外，還要能動態刪除呢?是不是我的[index]就要一直重新計算，不然送到後端就會不見了 *如果今天有4個textbox但是name分別是productList[0].idproductList[1].idproductList[2].idproductList[5].id這樣後端只會拿到0~2的ID,不按照順序編排的就會消失 還好.NET其實提供另外一種方式來繫結ViewModel 123&lt;input type=&quot;hidden&quot; name=&quot;productList.Index&quot; value=&quot;0072b890-0e1a-4c93-a5a7-9cafe84b65f8&quot; /&gt; &lt;input id=&quot;productList_0072b890-0e1a-4c93-a5a7-9cafe84b65f8__id&quot; name=&quot;productList[0072b890-0e1a-4c93-a5a7-9cafe84b65f8].id&quot; type=&quot;text&quot; &gt; 這樣的話就可以不用管排序，自由的新增刪除List的項目，但EditorTemplate也需要改一改，不然EditTemplate產出的是[0]這種格是,但是前端產出的格是是[Guid],這樣會有問題。 所以EditTemplate改成用這個方法產出*以下程式碼轉載自: &nbsp;搞搞就懂 - 點部落 :[ASP Net MVC] 如何綁定可動態新增或移除之資料集合(EditorTemplate) 新增一組HtmlHelper ```csharppublic static MvcHtmlString EditorForMany&lt;TModel, TValue&gt;( this HtmlHelper&lt;TModel&gt; html, Expression&lt;Func&lt;TModel, IEnumerable&lt;TValue&gt;&gt;&gt; expression, string htmlFieldName = null) where TModel : class &#123; var items = expression.Compile()(html.ViewData.Model); var sb = new StringBuilder(); var hasPrefix = false; if (String.IsNullOrEmpty(htmlFieldName)) &#123; var prefix = html.ViewContext.ViewData.TemplateInfo.HtmlFieldPrefix; hasPrefix = !String.IsNullOrEmpty(prefix); htmlFieldName = (prefix.Length &gt; 0 ? (prefix + &quot;.&quot;) : String.Empty) + ExpressionHelper.GetExpressionText(expression); &#125; if (items != null) &#123; foreach (var item in items) &#123; var dummy = new &#123; Item = item &#125;; var guid = Guid.NewGuid().ToString(); var memberExp = Expression.MakeMemberAccess(Expression.Constant(dummy), dummy.GetType().GetProperty(&quot;Item&quot;)); var singleItemExp = Expression.Lambda&lt;Func&lt;TModel, TValue&gt;&gt;(memberExp, expression.Parameters); sb.Append(String.Format(@&quot;&lt;input type=&quot;&quot;hidden&quot;&quot; name=&quot;&quot;&#123;0&#125;.Index&quot;&quot; value=&quot;&quot;&#123;1&#125;&quot;&quot; /&gt;&quot;, htmlFieldName, guid)); sb.Append(html.EditorFor(singleItemExp, null, String.Format(&quot;&#123;0&#125;[&#123;1&#125;]&quot;, hasPrefix ? ExpressionHelper.GetExpressionText(expression) : htmlFieldName, guid))); &#125; &#125; return new MvcHtmlString(sb.ToString()); &#125; } 12345* 原本EditorFor改成自訂的EditorForMany &#96;&#96;&#96;html@Html.EditorFor(x &#x3D;&gt; x.productList)@Html.EditorForMany(x &#x3D;&gt; x.productList) 這樣產出來的格式就會是帶Guid的方式了，可以正常跟前端結合了","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【MVC】EditorTemplate (一)","slug":"【MVC】EditorTemplate-一","date":"2015-11-25T01:43:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2015/11/25/【MVC】EditorTemplate-一/","link":"","permalink":"https://toyo0103.github.io/2015/11/25/%E3%80%90MVC%E3%80%91EditorTemplate-%E4%B8%80/","excerpt":"","text":"Git範例檔下載位置 : https://github.com/toyo0103/Demo_EditTemplate_1 MVC在View的部分要呈現資料，通常是用ViewModel的方式來傳遞。當碰到List或是Array這種重複多筆的情況時，常常就會用迴圈的方式去跑 例如: 假設有個類別CategoryViewModel 12345678910111213public class CategoryViewModel&#123; public Guid id &#123; get; set; &#125; public string name &#123; get; set; &#125; public List&lt;product&gt; productList &#123;get;set;&#125;&#125;public class product &#123; public Guid id &#123; get; set; &#125; public string name &#123;get;set;&#125;&#125; 在View上要呈現CategoryViewModel.productList就可能用跑回圈的方式去組成 12345678910@model CategoryViewModel@Html.TextBoxFor(x =&gt; x.id)@Html.TextBoxFor(x =&gt; x.name)//ProductList@for(int i = 0; i &lt; Model.productList.Count; i++)&#123; @Html.TextBoxFor(x =&gt; Model.productList[i].id) @Html.TextBoxFor(x =&gt; Model.productList[i].name)&#125; 這樣寫起View來有種又臭又長的感覺，所以可以使用MVC提供的EditorTemplate來解決，使用方法如下: 在Views &gt; Shared &gt; 新增一個EditorTemplates資料*注意 這邊資料夾名稱一定要對[![](http://2.bp.blogspot.com/-rtO8iQJhVEE/VlUQCtIp2YI/AAAAAAAAHo8/kz86QML4Yn8/s1600/1.png)](http://2.bp.blogspot.com/-rtO8iQJhVEE/VlUQCtIp2YI/AAAAAAAAHo8/kz86QML4Yn8/s1600/1.png) 接著在裡面新增一個product.cshtml，這邊一樣檔案名稱必須跟Class名稱相符才行 然後開始編輯product.cshtml1234@model product@Html.TextBoxFor(x =&gt; x.id)@Html.TextBoxFor(x =&gt; x.name) 接著回到CategoryViewModel那邊迴圈的地方，把迴圈改成這一行即可 ```csharp@Html.EditorFor(x=&gt;x.productList)","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"AutoMapper運用 (二)","slug":"AutoMapper運用-二","date":"2015-10-23T06:49:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2015/10/23/AutoMapper運用-二/","link":"","permalink":"https://toyo0103.github.io/2015/10/23/AutoMapper%E9%81%8B%E7%94%A8-%E4%BA%8C/","excerpt":"","text":"如果是複雜Class要Mapper時 12345678910111213public class Category &#123; public int id &#123; get; set; &#125; public List&lt;product&gt; products &#123;get;set;&#125;&#125;public class Product &#123; public int id &#123; get; set; &#125; public string name &#123; get; set; &#125; public int qantity &#123;get;set;&#125;&#125; Category要Mapping到CategoryViewModel 12345678910111213public class CategoryViewModel &#123; public int id &#123; get; set; &#125; public List&lt;Book&gt; books &#123;get;set;&#125;&#125;public class Book &#123; public string title &#123;get;set;&#125; public int number&#123;get;set;&#125;&#125; 有兩種做法,結果都會是一樣的 ```csharpCategory category = new Category(){id = 1,products = new List(){new Product(){ id = 1, name = “西遊戲”, qantity =10,},new Product(){ id = 2, name = “三國志”, qantity =30,},new Product(){ id = 3, name = “鹿鼎記”, qantity =50,}}}; Mapper.CreateMap&lt;Category, CategoryViewModel&gt;().ForMember(d =&gt; d.id, o =&gt; o.MapFrom(s =&gt; s.id)).ForMember(d =&gt; d.books, o =&gt; o.MapFrom(s =&gt; s.products)); Mapper.CreateMap&lt;Product, Book&gt;().ForMember(d =&gt; d.title, o =&gt; o.MapFrom(s =&gt; s.name)).ForMember(d =&gt; d.number, o =&gt; o.MapFrom(s =&gt; s.qantity)); var viewModel = Mapper.Map(category); viewModel.Dump(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152532. &#96;&#96;&#96;csharpvoid Main()&#123; Category category &#x3D; new Category() &#123; id &#x3D; 1, products &#x3D; new List&lt;Product&gt;() &#123; new Product() &#123; id &#x3D; 1, name &#x3D; &quot;西遊戲&quot;, qantity &#x3D;10, &#125;, new Product() &#123; id &#x3D; 2, name &#x3D; &quot;三國志&quot;, qantity &#x3D;30, &#125;, new Product() &#123; id &#x3D; 3, name &#x3D; &quot;鹿鼎記&quot;, qantity &#x3D;50, &#125; &#125; &#125;; Mapper.CreateMap&lt;Category, CategoryViewModel&gt;() .ForMember(d &#x3D;&gt; d.id, o &#x3D;&gt; o.MapFrom(s &#x3D;&gt; s.id)) .ForMember(d &#x3D;&gt; d.books, o &#x3D;&gt; o.ResolveUsing&lt;BookResolve&gt;().FromMember(s &#x3D;&gt; s.products)); var viewModel &#x3D; Mapper.Map&lt;CategoryViewModel&gt;(category); viewModel.Dump();&#125; public class BookResolve : ValueResolver&lt;IList&lt;Product&gt;, IList&lt;Book&gt;&gt;&#123; protected override IList&lt;Book&gt; ResolveCore(IList&lt;Product&gt; source) &#123; List&lt;Book&gt; books &#x3D; new List&lt;Book&gt;(); foreach (var item in source) &#123; var book &#x3D; new Book() &#123; number &#x3D; item.qantity, title &#x3D; item.name &#125;; books.Add(book); &#125; return books; &#125;&#125;","categories":[],"tags":[{"name":"AutoMapper","slug":"AutoMapper","permalink":"https://toyo0103.github.io/tags/AutoMapper/"},{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"AutoMapper運用","slug":"AutoMapper運用","date":"2015-10-23T04:00:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2015/10/23/AutoMapper運用/","link":"","permalink":"https://toyo0103.github.io/2015/10/23/AutoMapper%E9%81%8B%E7%94%A8/","excerpt":"","text":"寫網站常常會遇到從ViewModel對應到應用程式的DTO，或是DB的物件問題，以前自己的做法都是 ```csharp public bool Login(LoginViewModel model) { Account account = new Account() { Account = model.Account, Password = model.Password } var Result = _AccountService.Loign(account ); return Result; } public class LoginViewModel{ public string Account{get;set;} public string Password{get;set;}} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162等到內部運作完畢的時候可能又要把對應的DTO處理成ViewModel在拋回頁面，這種反覆一直寫的動作其實真的很煩人，直到最近同事介紹了[AutoMapper](https:&#x2F;&#x2F;www.nuget.org&#x2F;packages&#x2F;AutoMapper&#x2F;)給我們之後，整個流程得到了大幅度的改善。* AutoMapper的基本運用 當兩個物件的屬性都一樣時，AutoMapper會自動去對應並且轉出[![](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-j6G1kaI6BXw&#x2F;VimtMro_B9I&#x2F;AAAAAAAAHgY&#x2F;qZYVfNriOm0&#x2F;s1600&#x2F;1.png)](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-j6G1kaI6BXw&#x2F;VimtMro_B9I&#x2F;AAAAAAAAHgY&#x2F;qZYVfNriOm0&#x2F;s1600&#x2F;1.png) 如果兩個物件的屬性對應略有不同，也可以加上規則 [![](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-n04XweFHx5w&#x2F;VimuRLyJtGI&#x2F;AAAAAAAAHgg&#x2F;H0pNXYnW11w&#x2F;s1600&#x2F;1.png)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-n04XweFHx5w&#x2F;VimuRLyJtGI&#x2F;AAAAAAAAHgg&#x2F;H0pNXYnW11w&#x2F;s1600&#x2F;1.png)* 如果兩的類別對應到同一個物件的情況 &#96;&#96;&#96;csharpvoid Main()&#123; AccountViewModel model &#x3D; new AccountViewModel() &#123; Account &#x3D; &quot;toyo&quot;, Password &#x3D; &quot;pwd&quot;, City &#x3D; &quot;Taipei&quot;, District &#x3D; &quot;大安&quot; &#125;; var Group &#x3D; new Group() &#123; ID &#x3D; 1, Name &#x3D; &quot;客戶群組&quot; &#125;; Mapper.CreateMap&lt;AccountViewModel,AccountDTO&gt;() .ForMember(d&#x3D;&gt; d.Address , o&#x3D;&gt;o.MapFrom(s&#x3D;&gt;string.Concat(s.City,s.District))); var account &#x3D; Mapper.Map&lt;AccountDTO&gt;(model); &#x2F;&#x2F;這邊用上面已經轉好的account,來接續Mapper Mapper.CreateMap&lt;Group, AccountDTO&gt;() .ForMember(d &#x3D;&gt; d.Account, o &#x3D;&gt; o.Ignore()) .ForMember(d &#x3D;&gt; d.Password, o &#x3D;&gt; o.Ignore()) .ForMember(d &#x3D;&gt; d.Address, o &#x3D;&gt; o.Ignore()) .ForMember(d &#x3D;&gt; d.GroupName, o &#x3D;&gt; o.MapFrom(s&#x3D;&gt;s.Name)); &#x2F;&#x2F;注意 account &#x3D; Mapper.Map&lt;Group,AccountDTO&gt;(Group,account); account.Dump();&#125; public class AccountViewModel&#123; public string Account &#123; get; set; &#125; public string Password &#123; get; set; &#125; public string City &#123; get; set; &#125; public string District &#123;get;set;&#125;&#125; public class AccountDTO&#123; public string Account &#123; get; set; &#125; public string Password &#123; get; set; &#125; public string Address &#123; get; set; &#125; public string GroupName &#123;get;set;&#125;&#125; public class Group&#123; public int ID &#123; get; set; &#125; public string Name &#123;get;set;&#125;&#125; 結果 最後,在MVC的網站裡面使用AutoMapper可以在把所有規則都先寫在ProFile裡面，然後在Global一次註冊，之後在程式裡面用到就不用每次再寫CreateMap的部分 **Profile : ** 1234567891011121314151617181920212223public class ControllerMappingProfile : Profile&#123; public override string ProfileName &#123; get &#123; return &quot;ControllerMappingProfile&quot;; &#125; &#125; protected override void Configure() &#123; Mapper.CreateMap&lt;AccountViewModel, AccountDTO&gt;() .ForMember(d =&gt; d.Address, o =&gt; o.MapFrom(s =&gt; string.Concat(s.City, s.District))); Mapper.CreateMap&lt;Group, AccountDTO&gt;() .ForMember(d =&gt; d.Account, o =&gt; o.Ignore()) .ForMember(d =&gt; d.Password, o =&gt; o.Ignore()) .ForMember(d =&gt; d.Address, o =&gt; o.Ignore()) .ForMember(d =&gt; d.GroupName, o =&gt; o.MapFrom(s =&gt; s.Name)); &#125;&#125; **AutoMapperConfig : ** 1234567891011public class AutoMapperConfig &#123; public static void Configure() &#123; Mapper.Initialize(x =&gt; &#123; x.AddProfile&lt;ControllerMappingProfile&gt;(); &#125;); &#125; &#125; 最後在Global Application_Start註冊即可 ```csharpprotected void Application_Start(){ AutoMapperConfig.Configure();}","categories":[],"tags":[{"name":"AutoMapper","slug":"AutoMapper","permalink":"https://toyo0103.github.io/tags/AutoMapper/"},{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"LinqToSql ExcuteQuery回傳Binary的問題","slug":"LinqToSql-ExcuteQuery回傳Binary的問題","date":"2015-10-22T06:13:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2015/10/22/LinqToSql-ExcuteQuery回傳Binary的問題/","link":"","permalink":"https://toyo0103.github.io/2015/10/22/LinqToSql-ExcuteQuery%E5%9B%9E%E5%82%B3Binary%E7%9A%84%E5%95%8F%E9%A1%8C/","excerpt":"","text":"最近發現用LinqToSQL的物件模型,使用ExecuteQuery&lt;Binary&gt;的方式執行SQL會回傳型別’System.Data.Linq.Binary’ 必須宣告預設(無參數)建構涵式,才能在對應時加以建構,的問題 實際案例如下: 先在DB裡建立一個Function ```sqlcreate function [dbo].[fb_CreatePWD](@Param1 varchar(150))RETURNS varbinary (150)ASBEGINDECLARE @ResultVar varbinary(150)select @ResultVar = pwdencrypt(@Param1) RETURN @ResultVar END 1234567&#96;&#96;&#96;sql&lt;&#x2F;pre&gt;* 接著在MSSMS上測試是可以正常的[![](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-9so5HU0Hkr0&#x2F;Vih51QjzYZI&#x2F;AAAAAAAAHe8&#x2F;mIYlcdaDToA&#x2F;s1600&#x2F;1.png)](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-9so5HU0Hkr0&#x2F;Vih51QjzYZI&#x2F;AAAAAAAAHe8&#x2F;mIYlcdaDToA&#x2F;s1600&#x2F;1.png)* 然後移到LinqToSql的DataContext試試看&#96;&#96;&#96;csharpvar result &#x3D; this.ExecuteQuery&lt;binary&gt;(&quot;select dbo.fn_CreatePWD(&#123;0&#125;)&quot;,&quot;ok&quot;).FirstOrDefault();&lt;&#x2F;binary&gt; 得到以下錯誤訊息型別 ‘System.Data.Linq.Binary’ 必須宣告預設 (無參數) 建構函式，才能在對應時加以建構 網路上找到有人說用byte[]接可以,所以立馬做一下測試 ```csharp 12&lt;pre class&#x3D;&quot;brush:csharp&quot;&gt;var result &#x3D; this.ExecuteQuery&lt;binary&gt;(&quot;select dbo.fn_CreatePWD(&#123;0&#125;)&quot;,&quot;ok&quot;).FirstOrDefault();&lt;&#x2F;binary&gt; 結果一樣GG, 型別 ‘System.Byte[]’ 必須宣告預設 (無參數) 建構函式，才能在對應時加以建構。 接著改用Entity Framework 6.0來試試看* 一樣不行 換成Byte[]就可以了！！！所以還是趕快放棄LinqToSql這個被放棄掉的產品,投入Entity Framwork的懷抱吧XD *這邊特別備註一下,如果今天是直接用物件模型將function拉進來,並且直接對xxxDataContext.fn_CreatePWD()操作是可以運作沒問題. 但因為我今天的狀況是在Repository Pattern的情況下,並不會真的對實體做操作,而是全部都對基底類別DataContext做執行,所以沒有這個Method可以使用 我想以上狀況應該是LinqToSql的Bug吧!!網路上也查了滿久的資料,好像沒有人對這塊有比較好的處理方式,如果有再補充上來～","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://toyo0103.github.io/tags/Entity-Framework/"},{"name":"LINQ TO SQL","slug":"LINQ-TO-SQL","permalink":"https://toyo0103.github.io/tags/LINQ-TO-SQL/"}]},{"title":"[Android] Use Post To Call API","slug":"Android-Use-Post-To-Call-API","date":"2015-06-09T02:31:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2015/06/09/Android-Use-Post-To-Call-API/","link":"","permalink":"https://toyo0103.github.io/2015/06/09/Android-Use-Post-To-Call-API/","excerpt":"","text":"開發Android時,如何用Post的方式 Call API來取得值 首先 ```csharpString UrlLocation = 你的API位置; //API位置 String PostData = 要傳遞的資料(字串); //EX: ID=Toyo&amp;Name=Steven HttpURLConnection conn = null; StringBuilder sb = new StringBuilder(); try &#123; URL Url = new URL(UrlLocation); conn = (HttpURLConnection)Url.openConnection(); conn.setRequestMethod(&quot;POST&quot;); //要呼意的方式 Get Or Post conn.setDoInput(true); conn.setDoOutput(true); conn.connect(); //開始傳輸資料過去給API OutputStream Output = conn.getOutputStream(); BufferedWriter writer = new BufferedWriter( new OutputStreamWriter(Output, &quot;UTF-8&quot;)); writer.write(PostData); writer.flush(); writer.close(); Output.close(); //讀取API回傳的值 BufferedReader br = new BufferedReader(new InputStreamReader( conn.getInputStream(),&quot;utf-8&quot;)); String line; while ((line=br.readLine())!=null) &#123; sb.append(line); &#125; &#125; catch(Exception ex) &#123; Log.e(&quot;API_Post&quot;,ex.getMessage()); &#125; finally &#123; if (conn != null) conn.disconnect(); &#125; return sb.toString(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869* 目前測試的結果是,如果不把呼叫API用執行緒AsyncTask的方式處理,在conn.connect()這邊會跳出Http...InMainThread的Exception,原因是Andorid預設呼叫外部處理5秒沒有回應就會跳Exception,所以預設不管這支API反應速度快不快,他都要你把上面那段做成切執行緒的方式處理,當然網路上還是有舊的方式可以用,但既然這是官方目前推薦的做法就照做吧 &#96;&#96;&#96;csharp&#x2F;&#x2F;這邊有三個參數&#x2F;&#x2F;第一個參數String : 呼叫這個方法時要帶入的參數型態,這邊就是可以帶入String,&#x2F;&#x2F;第二個參數Void : 處理時會回報狀態跟進度,這邊寫Void表示不回傳目前處理狀態&#x2F;&#x2F;第三個參數String : 處理完成時回傳的值private class Post extends AsyncTask&lt;String,Void,String&gt; &#123; &#x2F;&#x2F;事件處理順序onPreExecute , doInBackground ,onPostExecute @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected String doInBackground(String ... params) &#123; &#x2F;&#x2F;改寫這邊,呼叫方法時可以傳進多個String,所以這邊改抓params String UrlLocation &#x3D; params[0]; &#x2F;&#x2F;API位置 String PostData &#x3D; params[1]; &#x2F;&#x2F;要傳資料 HttpURLConnection conn &#x3D; null; StringBuilder sb &#x3D; new StringBuilder(); try &#123; URL Url &#x3D; new URL(UrlLocation); conn &#x3D; (HttpURLConnection)Url.openConnection(); conn.setRequestMethod(&quot;POST&quot;); &#x2F;&#x2F;要呼意的方式 Get Or Post conn.setDoInput(true); conn.setDoOutput(true); conn.connect(); &#x2F;&#x2F;開始傳輸資料過去給API OutputStream Output &#x3D; conn.getOutputStream(); BufferedWriter writer &#x3D; new BufferedWriter( new OutputStreamWriter(Output, &quot;UTF-8&quot;)); writer.write(PostData); writer.flush(); writer.close(); Output.close(); &#x2F;&#x2F;讀取API回傳的值 BufferedReader br &#x3D; new BufferedReader(new InputStreamReader( conn.getInputStream(),&quot;utf-8&quot;)); String line; while ((line&#x3D;br.readLine())!&#x3D;null) &#123; sb.append(line); &#125; &#125; catch(Exception ex) &#123; Log.e(&quot;API_Post&quot;,ex.getMessage()); &#125; finally &#123; if (conn !&#x3D; null) conn.disconnect(); &#125; return sb.toString(); &#125; @Override protected void onPostExecute(String Result) &#123; super.onPostExecute(Result); &#125; &#125; 最後,因為在Debug模式AsyncTask並不會進入,所以要在doInBackground的事件裡面加上這行,但因為非Debug模式下這行會造成Android沒有回應, 所以記得在部署時把這行拿掉！！ ```csharpandroid.os.Debug.waitForDebugger(); 123456* 全部完成後,呼叫方式如下 &#96;&#96;&#96;csharpString Url &#x3D; &quot;http:&#x2F;&#x2F;www.api.com.tw&quot;;String PostData &#x3D; &quot;id&#x3D;toyo&amp;name&#x3D;steven&quot;;String Response &#x3D; new Post().execute(Url,PostData).get();","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://toyo0103.github.io/tags/Android/"}]},{"title":"[swift]  CoreData (2) 新增,刪除CoreData資料","slug":"swift-CoreData-2-新增-刪除CoreData資料","date":"2015-03-13T10:20:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2015/03/13/swift-CoreData-2-新增-刪除CoreData資料/","link":"","permalink":"https://toyo0103.github.io/2015/03/13/swift-CoreData-2-%E6%96%B0%E5%A2%9E-%E5%88%AA%E9%99%A4CoreData%E8%B3%87%E6%96%99/","excerpt":"","text":"這邊做個簡單的介面,讓TableView的資料來自資料庫,並能把資料存到資料庫裡面 首先先把TableView的資料來源設定成來自資料庫,完整程式碼如下,這樣就已經把Table的datasource friends來源改成SQLite了 ```swiftimport UIKitimport CoreDataclass ViewController: UIViewController , UITableViewDelegate , UITableViewDataSource, NSFetchedResultsControllerDelegate{ @IBOutlet weak var tableview: UITableView! var friends : [Friend] = [] var fetchRequestController:NSFetchedResultsController! override func viewDidLoad() { super.viewDidLoad() //讀取Friend的Entity var fetchRequest = NSFetchRequest(entityName: &quot;Friend&quot;) //排序方式用name這個欄位 let sortDescriptor = NSSortDescriptor(key: &quot;name&quot;, ascending: true) fetchRequest.sortDescriptors = [sortDescriptor] if let managedObjectContext = (UIApplication.sharedApplication().delegate as AppDelegate).managedObjectContext&#123; fetchRequestController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: managedObjectContext, sectionNameKeyPath: nil, cacheName: nil) //delegate設定為自己時,當新增修改刪除SQLite的資料時會呼叫以下事件 //controllerWillChangeContent() //controller(_:didChangeObject:atIndexPath:forChangeType:newIndexPath:) //controllerDidChangeContent(_:) fetchRequestController.delegate = self var e:NSError? var result = fetchRequestController.performFetch(&amp;e) friends = fetchRequestController.fetchedObjects as [Friend] if result != true&#123; println(e?.localizedDescription) &#125; &#125; } override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;cell&quot; var cell = tableView.dequeueReusableCellWithIdentifier(identifier) as customCell cell.nameLabel.text = friends[indexPath.row].name cell.telLabel.text = friends[indexPath.row].tel.stringValue cell.picImageView.image = UIImage(data: friends[indexPath.row].picture) cell.marryLabel.text = friends[indexPath.row].marry.boolValue ? &quot;YES&quot; : &quot;NO&quot; return cell } func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return friends.count }} 123456789101112* 接著寫按下save後的事件將檔案能寫到資料庫中,在這之前先處理Yes and no的按鈕和載入圖片按鈕Yes and No按鈕 &#96;&#96;&#96;swift@IBOutlet weak var YesButton: UIButton! @IBOutlet weak var NoButton: UIButton! @IBAction func MarryButtonClick(sender: AnyObject) &#123; YesButton.backgroundColor &#x3D; (sender as UIButton &#x3D;&#x3D; YesButton) ? UIColor.redColor() : UIColor.lightGrayColor() NoButton.backgroundColor &#x3D; (sender as UIButton &#x3D;&#x3D; NoButton) ? UIColor.redColor() : UIColor.lightGrayColor() &#125; 實作載入圖片的按鈕,需要讓viewController實作UIImagePickerControllerDelegate和UINavigationControllerDelegate 12345class ViewController: UIViewController , UITableViewDelegate , UITableViewDataSource, NSFetchedResultsControllerDelegate , UIImagePickerControllerDelegate,UINavigationControllerDelegate&#123; &#125; selectPicture的按鈕 ```swift@IBAction func SelectPictureClick(sender: AnyObject) { let imagePicker = UIImagePickerController() imagePicker.allowsEditing = false imagePicker.sourceType = UIImagePickerControllerSourceType.PhotoLibrary imagePicker.delegate = self //顯示挑選圖片的視窗 self.presentViewController(imagePicker, animated: true, completion: nil) } func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]) { PicImageView.image = info[UIImagePickerControllerOriginalImage] as? UIImage PicImageView.contentMode = UIViewContentMode.ScaleAspectFill PicImageView.clipsToBounds = true //關閉挑選圖片的視窗 dismissViewControllerAnimated(true, completion: nil) } 1234567891011121314151617接著執行看看應該結果[![](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-2NW3TefbDxE&#x2F;VQK1HNE_8rI&#x2F;AAAAAAAAEkw&#x2F;l2v6Div6BYA&#x2F;s400&#x2F;test.gif)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-2NW3TefbDxE&#x2F;VQK1HNE_8rI&#x2F;AAAAAAAAEkw&#x2F;l2v6Div6BYA&#x2F;s1600&#x2F;test.gif)* 接著把Save按鈕按下後存到SQLite的事件寫好 &#96;&#96;&#96;swift@IBAction func SaveClick(sender: AnyObject) &#123; if let manageObjectContext &#x3D; (UIApplication.sharedApplication().delegate as AppDelegate).managedObjectContext&#123; var friend &#x3D; NSEntityDescription.insertNewObjectForEntityForName(&quot;Friend&quot;, inManagedObjectContext: manageObjectContext) as Friend friend.name &#x3D; NameTextField.text friend.tel &#x3D; TelTextField.text.toInt() friend.marry &#x3D; (YesButton.backgroundColor &#x3D;&#x3D; UIColor.redColor()) ? true : false friend.picture &#x3D; UIImagePNGRepresentation(PicImageView.image) var e:NSError? if manageObjectContext.save(&amp;e) !&#x3D; true&#123; println(&quot;error: \\(e?.localizedDescription)&quot;) return &#125; &#125; &#125; 接著執行看看會發現按了儲存按鈕後雖然存進資料庫了,但沒有讓TableView馬上連動顯示,必須重新開APP才會顯示在table上* 還記得之前有繼承NSFetchedResultsControllerDelegate嗎?這時候派上用場了,補上幾個事件讓他可以跟TableView連動吧 ```swift//資料庫準備更新了 func controllerWillChangeContent(controller: NSFetchedResultsController) { tableview.beginUpdates() } func controller(controller: NSFetchedResultsController, didChangeObject anObject: AnyObject, atIndexPath indexPath: NSIndexPath?, forChangeType type: NSFetchedResultsChangeType, newIndexPath: NSIndexPath?) { switch type{ case .Insert: tableview.insertRowsAtIndexPaths([newIndexPath!], withRowAnimation: UITableViewRowAnimation.Fade) case .Delete: tableview.deleteRowsAtIndexPaths([indexPath!], withRowAnimation: UITableViewRowAnimation.Fade) case .Update: tableview.reloadRowsAtIndexPaths([indexPath!], withRowAnimation: UITableViewRowAnimation.Fade) default: tableview.reloadData() } friends = controller.fetchedObjects as [Friend] } func controllerDidChangeContent(controller: NSFetchedResultsController) { tableview.endUpdates() } 1234567891011121314接著再執行看看應該就可以看到他會馬上顯示了* 最後來個刪除吧！！這邊只舉例刪除該如何做,就不加到例子當中了 &#96;&#96;&#96;swiftif let manageObjectContext &#x3D; (UIApplication.sharedApplication().delegate as AppDelegate).managedObjectContext&#123; &#x2F;&#x2F;簡單說就是挑出那個想刪除的物件 var friendToDelete &#x3D; self.fetchRequestController.objectAtIndexPath(NSIndexPath(index: 0)) as Friend &#x2F;&#x2F;呼叫刪除方法把它丟進去 manageObjectContext.deleteObject(friendToDelete) var e:NSError? &#x2F;&#x2F;儲存 if manageObjectContext.save(&amp;e) !&#x3D; true&#123; println(&quot;error: \\(e?.localizedDescription)&quot;) &#125; &#125; 基本上有操作過.NET Entity物件的話,這邊的概念幾乎都雷同,最後補上完整的程式碼 ```swiftimport UIKitimport CoreDataclass ViewController: UIViewController , UITableViewDelegate , UITableViewDataSource, UINavigationControllerDelegate ,NSFetchedResultsControllerDelegate , UIImagePickerControllerDelegate{ @IBOutlet weak var tableview: UITableView! var friends : [Friend] = [] var fetchRequestController:NSFetchedResultsController! @IBOutlet weak var NameTextField: UITextField! @IBOutlet weak var TelTextField: UITextField! @IBOutlet weak var PicImageView: UIImageView! @IBOutlet weak var YesButton: UIButton! @IBOutlet weak var NoButton: UIButton! override func viewDidLoad() { super.viewDidLoad() //讀取Friend的Entity var fetchRequest = NSFetchRequest(entityName: &quot;Friend&quot;) //排序方式用name這個欄位 let sortDescriptor = NSSortDescriptor(key: &quot;name&quot;, ascending: true) fetchRequest.sortDescriptors = [sortDescriptor] if let managedObjectContext = (UIApplication.sharedApplication().delegate as AppDelegate).managedObjectContext&#123; fetchRequestController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: managedObjectContext, sectionNameKeyPath: nil, cacheName: nil) //delegate設定為自己時,當新增修改刪除SQLite的資料時會呼叫以下事件 //controllerWillChangeContent() //controller(_:didChangeObject:atIndexPath:forChangeType:newIndexPath:) //controllerDidChangeContent(_:) fetchRequestController.delegate = self var e:NSError? var result = fetchRequestController.performFetch(&amp;e) friends = fetchRequestController.fetchedObjects as [Friend] if result != true&#123; println(e?.localizedDescription) &#125; &#125; } override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;cell&quot; var cell = tableView.dequeueReusableCellWithIdentifier(identifier) as customCell cell.nameLabel.text = friends[indexPath.row].name cell.telLabel.text = friends[indexPath.row].tel.stringValue cell.picImageView.image = UIImage(data: friends[indexPath.row].picture) cell.marryLabel.text = friends[indexPath.row].marry.boolValue ? &quot;YES&quot; : &quot;NO&quot; return cell } func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return friends.count } @IBAction func MarryButtonClick(sender: AnyObject) { YesButton.backgroundColor = (sender as UIButton == YesButton) ? UIColor.redColor() : UIColor.lightGrayColor() NoButton.backgroundColor = (sender as UIButton == NoButton) ? UIColor.redColor() : UIColor.lightGrayColor() } @IBAction func SelectPictureClick(sender: AnyObject) { let imagePicker = UIImagePickerController() imagePicker.allowsEditing = false imagePicker.sourceType = UIImagePickerControllerSourceType.PhotoLibrary imagePicker.delegate = self //顯示挑選圖片的視窗 self.presentViewController(imagePicker, animated: true, completion: nil) } func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]) { PicImageView.image = info[UIImagePickerControllerOriginalImage] as? UIImage PicImageView.contentMode = UIViewContentMode.ScaleAspectFill PicImageView.clipsToBounds = true //關閉挑選圖片的視窗 dismissViewControllerAnimated(true, completion: nil) } @IBAction func SaveClick(sender: AnyObject) { if let manageObjectContext = (UIApplication.sharedApplication().delegate as AppDelegate).managedObjectContext&#123; var friend = NSEntityDescription.insertNewObjectForEntityForName(&quot;Friend&quot;, inManagedObjectContext: manageObjectContext) as Friend friend.name = NameTextField.text friend.tel = TelTextField.text.toInt() friend.marry = (YesButton.backgroundColor == UIColor.redColor()) ? true : false friend.picture = UIImagePNGRepresentation(PicImageView.image) var e:NSError? if manageObjectContext.save(&amp;e) != true&#123; println(&quot;error: \\(e?.localizedDescription)&quot;) return &#125; &#125; } //資料庫準備更新了 func controllerWillChangeContent(controller: NSFetchedResultsController) { tableview.beginUpdates() } func controller(controller: NSFetchedResultsController, didChangeObject anObject: AnyObject, atIndexPath indexPath: NSIndexPath?, forChangeType type: NSFetchedResultsChangeType, newIndexPath: NSIndexPath?) { switch type&#123; case .Insert: tableview.insertRowsAtIndexPaths([newIndexPath!], withRowAnimation: UITableViewRowAnimation.Fade) case .Delete: tableview.deleteRowsAtIndexPaths([indexPath!], withRowAnimation: UITableViewRowAnimation.Fade) case .Update: tableview.reloadRowsAtIndexPaths([indexPath!], withRowAnimation: UITableViewRowAnimation.Fade) default: tableview.reloadData() &#125; friends = controller.fetchedObjects as [Friend] } func controllerDidChangeContent(controller: NSFetchedResultsController) { tableview.endUpdates() }}","categories":[],"tags":[]},{"title":"[swift]  CoreData (1) 建立CoreData","slug":"swift-CoreData-1-建立CoreData","date":"2015-03-13T02:44:00.000Z","updated":"2022-08-09T13:36:17.081Z","comments":true,"path":"2015/03/13/swift-CoreData-1-建立CoreData/","link":"","permalink":"https://toyo0103.github.io/2015/03/13/swift-CoreData-1-%E5%BB%BA%E7%AB%8BCoreData/","excerpt":"","text":"CoreData是是一種以物件導向方式讓開發者與跟資料庫互動的框架,好處是你不需要懂SQL也能對SQLite做操作 [![](https://1.bp.blogspot.com/-cLEXYUQDTJA/VQJMODzIHuI/AAAAAAAAEjg/uDb2WQBOTmA/s1600/S__23961604.jpg)](http://1.bp.blogspot.com/-cLEXYUQDTJA/VQJMODzIHuI/AAAAAAAAEjg/uDb2WQBOTmA/s1600/S__23961604.jpg)[ ](http://1.bp.blogspot.com/-cLEXYUQDTJA/VQJMODzIHuI/AAAAAAAAEjg/uDb2WQBOTmA/s1600/S__23961604.jpg) 接著來筆記如何實作CoreData,首先先建立一個專案並把Use Core Data勾選起來 接著打開AppDelegate最下面可以看到多了一大堆程式碼 ```js// MARK: - Core Data stack lazy var applicationDocumentsDirectory: NSURL = &#123; // The directory the application uses to store the Core Data store file. This code uses a directory named &quot;tw.com.xxx.Coredata&quot; in the application&#39;s documents Application Support directory. let urls = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) return urls[urls.count-1] as NSURL }() lazy var managedObjectModel: NSManagedObjectModel = &#123; // The managed object model for the application. This property is not optional. It is a fatal error for the application not to be able to find and load its model. let modelURL = NSBundle.mainBundle().URLForResource(&quot;Coredata&quot;, withExtension: &quot;momd&quot;)! return NSManagedObjectModel(contentsOfURL: modelURL)! }() lazy var persistentStoreCoordinator: NSPersistentStoreCoordinator? = &#123; // The persistent store coordinator for the application. This implementation creates and return a coordinator, having added the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail. // Create the coordinator and store var coordinator: NSPersistentStoreCoordinator? = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel) let url = self.applicationDocumentsDirectory.URLByAppendingPathComponent(&quot;Coredata.sqlite&quot;) var error: NSError? = nil var failureReason = &quot;There was an error creating or loading the application&#39;s saved data.&quot; if coordinator!.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: url, options: nil, error: &amp;error) == nil &#123; coordinator = nil // Report any error we got. let dict = NSMutableDictionary() dict[NSLocalizedDescriptionKey] = &quot;Failed to initialize the application&#39;s saved data&quot; dict[NSLocalizedFailureReasonErrorKey] = failureReason dict[NSUnderlyingErrorKey] = error error = NSError(domain: &quot;YOUR_ERROR_DOMAIN&quot;, code: 9999, userInfo: dict) // Replace this with code to handle the error appropriately. // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. NSLog(&quot;Unresolved error \\(error), \\(error!.userInfo)&quot;) abort() &#125; return coordinator }() lazy var managedObjectContext: NSManagedObjectContext? = &#123; // Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.) This property is optional since there are legitimate error conditions that could cause the creation of the context to fail. let coordinator = self.persistentStoreCoordinator if coordinator == nil &#123; return nil &#125; var managedObjectContext = NSManagedObjectContext() managedObjectContext.persistentStoreCoordinator = coordinator return managedObjectContext }() // MARK: - Core Data Saving support func saveContext () &#123; if let moc = self.managedObjectContext &#123; var error: NSError? = nil if moc.hasChanges &amp;&amp; !moc.save(&amp;error) &#123; // Replace this implementation with code to handle the error appropriately. // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. NSLog(&quot;Unresolved error \\(error), \\(error!.userInfo)&quot;) abort() &#125; &#125; } 12345678910111213141516* 接著建立物件託管模型[![](https:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-KK3Tu_Vazbk&#x2F;VQJTyV8AxfI&#x2F;AAAAAAAAEj8&#x2F;YqCpExRBFF0&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-13%2B%E4%B8%8A%E5%8D%8811.02.54.png)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-KK3Tu_Vazbk&#x2F;VQJTyV8AxfI&#x2F;AAAAAAAAEj8&#x2F;YqCpExRBFF0&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-13%2B%E4%B8%8A%E5%8D%8811.02.54.png)* 接著建立Entities[![](https:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-D2JtYHHTBxI&#x2F;VQJUguKuVhI&#x2F;AAAAAAAAEkE&#x2F;2vxmi1ktG4U&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-13%2B%E4%B8%8A%E5%8D%8811.07.18.png)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-D2JtYHHTBxI&#x2F;VQJUguKuVhI&#x2F;AAAAAAAAEkE&#x2F;2vxmi1ktG4U&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-13%2B%E4%B8%8A%E5%8D%8811.07.18.png)＊**&lt;span style&#x3D;&quot;color: blue;&quot;&gt;圖片需要用Binary Data來儲存 &lt;&#x2F;span&gt;*** 接著建立Class來對應Entity &#96;&#96;&#96;jsimport Foundationimport CoreDataclass Friend:NSManagedObject &#123; @NSManaged var name:String! @NSManaged var tel:NSNumber! @NSManaged var picture:NSData! @NSManaged var marry:NSNumber!&#125; ＊對應Entity中的Boolean, Integer, Float and Double attributes,都是用NSNumber 接著設定Entity與Class的對應關係,如圖：這樣託管物件的建立就已經完成了,下一篇介紹如何叫用","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift]  IOS地圖運用 (6) 透過CLGeocoder轉換經緯度與地址","slug":"swift-IOS地圖運用-6-透過CLGeocoder轉換經緯度與地址","date":"2015-03-12T03:03:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/12/swift-IOS地圖運用-6-透過CLGeocoder轉換經緯度與地址/","link":"","permalink":"https://toyo0103.github.io/2015/03/12/swift-IOS%E5%9C%B0%E5%9C%96%E9%81%8B%E7%94%A8-6-%E9%80%8F%E9%81%8ECLGeocoder%E8%BD%89%E6%8F%9B%E7%B6%93%E7%B7%AF%E5%BA%A6%E8%88%87%E5%9C%B0%E5%9D%80/","excerpt":"","text":"IOS提供CLGeocoder將地址轉成經緯度,或是把經緯度轉換成地址,詳細語法如下 記得先Import MapKit 地址轉經緯度(geocodeAddressString) ```swiftlet geoCoder = CLGeocoder()geoCoder.geocodeAddressString(“這邊帶入地址”, completionHandler: { (placemarks:[AnyObject]!,error:NSError!) -&gt; Void in if error != nil{println(error) return } if placemarks != nil &amp;&amp; placemarks.count &gt; 0{let placemark = placemarks[0] as CLPlacemark //placemark.location.coordinate 取得經緯度的參數 &#125; }) 12345678910111213141516171819202122232425* 經緯度轉地址的方法 &#96;&#96;&#96;swiftlet geoCoder &#x3D; CLGeocoder()geoCoder.reverseGeocodeLocation(CLLocation(latitude: 25.024839 , longitude: 121.549170), completionHandler: &#123; (placemarks:[AnyObject]!,error:NSError!) -&gt; Void in if error !&#x3D; nil&#123; println(error) return &#125; &#x2F;&#x2F;name 街道地址 &#x2F;&#x2F;country 國家 &#x2F;&#x2F;province 省 &#x2F;&#x2F;locality 市 &#x2F;&#x2F;sublocality 縣.區 &#x2F;&#x2F;route 街道、路 &#x2F;&#x2F;streetNumber 門牌號碼 &#x2F;&#x2F;postalCode 郵遞區號 if placemarks !&#x3D; nil &amp;&amp; placemarks.count &gt; 0&#123; let placemark &#x3D; placemarks[0] as CLPlacemark &#x2F;&#x2F;這邊拼湊轉回來的地址 &#x2F;&#x2F;placemark.name &#125;&#125;)","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 製作動畫","slug":"swift-製作動畫","date":"2015-03-11T09:33:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2015/03/11/swift-製作動畫/","link":"","permalink":"https://toyo0103.github.io/2015/03/11/swift-%E8%A3%BD%E4%BD%9C%E5%8B%95%E7%95%AB/","excerpt":"","text":"目標結果如圖 首先先把最後所有按鈕要放的位置擺好 把每個按鈕跟ViewController做對應 ```swift@IBOutlet weak var backgroundImageView: UIImageView! @IBOutlet weak var fbButton: UIButton! @IBOutlet weak var twitterButton: UIButton! @IBOutlet weak var messageButton: UIButton! @IBOutlet weak var mailButton: UIButton! 1234567891011* 接著用CGAffineTransformMakeTranslation的方式將所有按鈕移到動畫的起始位置,這邊解釋一下程式中那些數字怎麼決定的,CGAffineTransformMakeTranslation需要給定x y值,如果(0, -300)表示x軸不動,Y軸比原本你在StoryBoard放的位置還要**&lt;span style&#x3D;&quot;color: red;&quot;&gt;往上&lt;&#x2F;span&gt;**移300個點的位置,反之(0, 300)則表示比原本擺放的位置**&lt;span style&#x3D;&quot;color: red;&quot;&gt;往下&lt;&#x2F;span&gt;**移動300點 &#96;&#96;&#96;swiftoverride func viewDidLoad() &#123; super.viewDidLoad() self.fbButton.transform &#x3D; CGAffineTransformMakeTranslation(0, -300) self.messageButton.transform &#x3D; CGAffineTransformMakeTranslation(0, -364) self.mailButton.transform &#x3D; CGAffineTransformMakeTranslation(0, 300) self.twitterButton.transform &#x3D; CGAffineTransformMakeTranslation(0, 364) &#125; 接著大家測試一下程式,應該會發現東西的確是跑出螢幕了,接著在viewDidAppear補上以下程式碼就大功告成了！！ ```swiftoverride func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) //動畫,分成兩個區塊是因為有快有慢,差別在於delay多久再發動,usingSpringWithDamping是彈跳的反作用力,越小越劇烈 UIView.animateWithDuration(0.9, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: nil, animations: &#123; //跑回原來的點 let translate = CGAffineTransformMakeTranslation(0, 0) self.messageButton.transform = translate self.twitterButton.transform = translate &#125;, completion: nil) UIView.animateWithDuration(0.9, delay: 0.1, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: nil, animations: &#123; let translate = CGAffineTransformMakeTranslation(0, 0) self.fbButton.transform = translate self.mailButton.transform = translate &#125;, completion: nil) }","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 將圖片做出霧化效果","slug":"swift-將圖片做出霧化效果","date":"2015-03-11T03:18:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/11/swift-將圖片做出霧化效果/","link":"","permalink":"https://toyo0103.github.io/2015/03/11/swift-%E5%B0%87%E5%9C%96%E7%89%87%E5%81%9A%E5%87%BA%E9%9C%A7%E5%8C%96%E6%95%88%E6%9E%9C/","excerpt":"","text":"以下範例是參考做成的筆記:養成iOS8 App程式設計實力的25堂課：最新Swift開發教學 IOS8有提供將圖片霧化的效果,如果我們將一張圖片擺進都不調整的情況下看到的結果如下 如果我們想把它變成這樣呢? [![](http://4.bp.blogspot.com/-qGCntfEZsMQ/VP-ziaQFhLI/AAAAAAAAEig/GI3S3yTBTK0/s320/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-11%2B%E4%B8%8A%E5%8D%8811.16.07.png)](http://4.bp.blogspot.com/-qGCntfEZsMQ/VP-ziaQFhLI/AAAAAAAAEig/GI3S3yTBTK0/s1600/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-11%2B%E4%B8%8A%E5%8D%8811.16.07.png)[![](http://1.bp.blogspot.com/-inhOmUeMfVU/VP-ztGG_pxI/AAAAAAAAEio/djWTqz97y0I/s320/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-11%2B%E4%B8%8A%E5%8D%8811.16.51.png)](http://1.bp.blogspot.com/-inhOmUeMfVU/VP-ztGG_pxI/AAAAAAAAEio/djWTqz97y0I/s1600/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-11%2B%E4%B8%8A%E5%8D%8811.16.51.png)[![](http://3.bp.blogspot.com/-NJzO9xqbdbg/VP-z3nspMII/AAAAAAAAEiw/Ud6fxww0IgI/s320/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-11%2B%E4%B8%8A%E5%8D%8811.17.30.png)](http://3.bp.blogspot.com/-NJzO9xqbdbg/VP-z3nspMII/AAAAAAAAEiw/Ud6fxww0IgI/s1600/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-11%2B%E4%B8%8A%E5%8D%8811.17.30.png) 程式碼撰寫如下: ```swift @IBOutlet weak var backgroundImageView: UIImageView!//背景圖 override func viewDidLoad() { super.viewDidLoad() //.Dark等於圖1 //.ExtraLight等於圖2 //.Light等於圖3 var blurEffect = UIBlurEffect(style: UIBlurEffectStyle.Light) var blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.frame = view.bounds backgroundImageView.addSubview(blurEffectView) }","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 製作IOS Table (5) UITableViewRowAction","slug":"swift-製作IOS-Table-5-UITableViewRowAction","date":"2015-03-10T06:33:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2015/03/10/swift-製作IOS-Table-5-UITableViewRowAction/","link":"","permalink":"https://toyo0103.github.io/2015/03/10/swift-%E8%A3%BD%E4%BD%9CIOS-Table-5-UITableViewRowAction/","excerpt":"","text":"開始之前想推薦這本書:養成iOS8 App程式設計實力的25堂課：最新Swift開發教學,只能說看了對於初學者的我來說受益良多,而且對於IOS很多觀念也更加清楚了 這邊要實作的功能如下圖 IOS8的TableView當中,有個可以往左滑可以選擇更多動作的功能,Apple官方有提供相對應的事件可以實作它 首先先Override TableView commitEditingStyle這個事件,什麼都先不要做就執行看看 ```swiftfunc tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {} 123456789101112立馬預設的Delete按鈕就跑出來了[![](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-maAldiH9hOE&#x2F;VP6RASa2iQI&#x2F;AAAAAAAAEiE&#x2F;3px4PGz4sWU&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-10%2B%E4%B8%8B%E5%8D%882.36.30.png)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-maAldiH9hOE&#x2F;VP6RASa2iQI&#x2F;AAAAAAAAEiE&#x2F;3px4PGz4sWU&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-10%2B%E4%B8%8B%E5%8D%882.36.30.png)* 接著補上以下code,再實際執行看看就可以發現該列可以刪除了 &#96;&#96;&#96;swiftfunc tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) &#123; if editingStyle &#x3D;&#x3D; UITableViewCellEditingStyle.Delete&#123; &#x2F;&#x2F;將TableView的DataSource刪除 self.restaurantArray.removeAtIndex(indexPath.row) &#x2F;&#x2F;將TableView該列刪除 tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Fade) &#125; &#125; 但如果要客製更多按鈕呢？接下來改寫 editActionsForRowAtIndexPath這個事件,但需要特別注意的是如果我們新增了editActionsForRowAtIndexPath這個事件,則IOS就不會預設幫我們增加Delete的按鈕,所以Delete的按鈕也得自己做瞜～ 先把commitEditingStyle恢復成空值,只讓IOS知道我們要左滑出現功能列就好 ```swiftfunc tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { //把剛剛寫的都刪光光 } 123456789101112接著改寫editActionsForRowAtIndexPath &#96;&#96;&#96;swiftfunc tableView(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath) -&gt; [AnyObject]? &#123; var shareAction &#x3D; UITableViewRowAction(style: UITableViewRowActionStyle.Default, title: &quot;Share&quot;, handler: nil) &#x2F;&#x2F;delete按鈕自己做 var deleteAction &#x3D; UITableViewRowAction(style: UITableViewRowActionStyle.Default, title: &quot;Delete&quot;, handler: &#123; (action:UITableViewRowAction! , indexPath:NSIndexPath!) -&gt; Void in self.restaurantArray.removeAtIndex(indexPath.row) self.restaurantTable.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Fade) &#125;) return [deleteAction,shareAction] &#125; 執行看看就可以看到多出了一過按鈕了,如果想改變按鈕的顏色可以這樣寫 ```swiftshareAction.backgroundColor = UIColor(red: 255/255, green: 166/255, blue: 51/255, alpha: 1) ``` 最後就可以得出圖1的結果啦!!!!","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] UIAlertController","slug":"swift-UIAlertController","date":"2015-03-09T07:44:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/09/swift-UIAlertController/","link":"","permalink":"https://toyo0103.github.io/2015/03/09/swift-UIAlertController/","excerpt":"","text":"APP常常有一種狀況是當使用者按下某個選項時,從下面滑出更多的選項讓它做進一步動作,例如在iphone的照片點選垃圾桶時 在IOS 8中多了一個UIAlertController的類別來取代UIAlerView,實際作法如下首先將程式碼加到viewDidAppear,否則無法顯示效果,原因請看IOS生命週期的說明點我 ```swiftoverride func viewDidAppear(animated: Bool) { //建立UIAlertController let quetion = UIAlertController(title: nil, message: &quot;What Do u want?&quot;, preferredStyle: .ActionSheet); //新增選項 let callaction = UIAlertAction(title: &quot;call xxx&quot;, style: .Default , handler:nil); //把選項加到UIAlertController quetion.addAction(callaction); //Show self.presentViewController(quetion, animated: true, completion: nil); } 12345執行看到的結果如下圖[![](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-FSopEARqG_0&#x2F;VP1Oau8suBI&#x2F;AAAAAAAAEhc&#x2F;v6cpxkt6bWc&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-09%2B%E4%B8%8B%E5%8D%883.39.39.png)](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-FSopEARqG_0&#x2F;VP1Oau8suBI&#x2F;AAAAAAAAEhc&#x2F;v6cpxkt6bWc&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-09%2B%E4%B8%8B%E5%8D%883.39.39.png)* 如果將ActionSheet改成Alert,則結果 &#96;&#96;&#96;swiftlet quetion &#x3D; UIAlertController(title: nil, message: &quot;What Do u want?&quot;, preferredStyle: .Alert); 如果更進階一些,在選擇選項後有些回應時我們拉一個label到ViewController裡面來,並且在按下call xxx選項時,把label的字樣給改變 ```swiftclass AlertViewController: UIViewController { @IBOutlet weak var showaction: UILabel! override func viewDidLoad() { super.viewDidLoad(); } override func viewDidAppear(animated: Bool) { let quetion = UIAlertController(title: nil, message: &quot;What Do u want?&quot;, preferredStyle: .Alert); let callaction = UIAlertAction(title: &quot;call xxx&quot;,style: .Default, handler:&#123; (action:UIAlertAction!) -&gt; Void in self.showaction.text = &quot;Do call xxx&quot;; &#125;); quetion.addAction(callaction); self.presentViewController(quetion, animated: true, completion: nil); }} ```執行看看吧！！","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] String To MD5","slug":"swift-String-To-MD5","date":"2015-03-09T02:20:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/09/swift-String-To-MD5/","link":"","permalink":"https://toyo0103.github.io/2015/03/09/swift-String-To-MD5/","excerpt":"","text":"我將這個Function寫在extension裡面,首先Swift要能用MD5的function必須先建立header檔並掛上(header檔如何建立請看這篇) ```swift#import &lt;CommonCrypto/CommonCrypto.h&gt; 1234567891011121314* 然後 &#96;&#96;&#96;swiftfunc md5() -&gt; String! &#123; let str &#x3D; self.cStringUsingEncoding(NSUTF8StringEncoding) let strLen &#x3D; CUnsignedInt(self.lengthOfBytesUsingEncoding(NSUTF8StringEncoding)) let digestLen &#x3D; Int(CC_MD5_DIGEST_LENGTH) let result &#x3D; UnsafeMutablePointer&lt;CUnsignedChar&gt;.alloc(digestLen) CC_MD5(str!, strLen, result) var hash &#x3D; NSMutableString() for i in 0..&lt;digestLen &#123; hash.appendFormat(&quot;%02x&quot;, result[i]) &#125; result.destroy() return String(format: hash)&#125;","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] Extension","slug":"swift-Extension","date":"2015-03-09T01:58:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/09/swift-Extension/","link":"","permalink":"https://toyo0103.github.io/2015/03/09/swift-Extension/","excerpt":"","text":"Swift這個語法常常會遇到參數型態間的轉換,寫慣了C#,常常遇到什麼參數轉換就會想要.toString() .toInt()阿之類的,偏偏Swift沒有這些function不打緊,還每種型態的變數互轉常常方式不一樣….搞得我每次遇到都要查一下到底這次又該用哪個function來轉換好,最後索性就把這些整理起來做成Extension,以後就跟C#一樣to啥to啥的就好. 那接下來就來介紹怎麼擴充Swift的function語法 extension是關鍵字,擴充String類別型態的function ```swiftextension String{ func toDoublue() -&gt; Double{ return (self as NSString).doubleValue; }} ``` 結果","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[SQL] 2008 R2 繁體中文版安裝問題","slug":"SQL-2008-R2-繁體中文版安裝問題","date":"2015-03-07T04:24:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2015/03/07/SQL-2008-R2-繁體中文版安裝問題/","link":"","permalink":"https://toyo0103.github.io/2015/03/07/SQL-2008-R2-%E7%B9%81%E9%AB%94%E4%B8%AD%E6%96%87%E7%89%88%E5%AE%89%E8%A3%9D%E5%95%8F%E9%A1%8C/","excerpt":"","text":"如果你作業系統是從英文版安裝與語系版本成為中文版的話,安裝SQL繁體中文版應該會遇到不明的錯誤而停止,上網找了一下資料發現這篇:解決 Windows 7 線上更新語言包後安裝 SQL Server 2008 R2 繁體中文版失敗的問題 原因是從英文版透過語系包轉成的中文版的作業系統,他是香港繁體中文版,在安裝SQL時預設會去抓3076_ZHH_LP這個資料夾,但繁體中文版的SQL Server的資料夾為1028_CHT_LP。 所以解決方法就是,把全部的光碟內容複製下來,並且將1028_CHT_LP複製一份並且改名為3076_ZHH_LP,用這個資料夾安裝就可以順利完成了 [![](http://1.bp.blogspot.com/-ygIcfJtBNic/VPp9GMAHE0I/AAAAAAAAEgk/oi6kUT_rkfc/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)](http://1.bp.blogspot.com/-ygIcfJtBNic/VPp9GMAHE0I/AAAAAAAAEgk/oi6kUT_rkfc/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"[swift] NetWork (4) 解析Json","slug":"swift-NetWork-4-解析Json","date":"2015-03-05T08:15:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/05/swift-NetWork-4-解析Json/","link":"","permalink":"https://toyo0103.github.io/2015/03/05/swift-NetWork-4-%E8%A7%A3%E6%9E%90Json/","excerpt":"","text":"先做一個json檔案來模擬接到時怎麼解析 ```csharp{“組織名稱”:”普攏拱團隊”,“組織成員”:[ {“姓名”:”科科人”,”年齡”:11}, {“姓名”:”可可狗”,”年齡”:120}]} 1234567891011121314151617* 在viewDidLoad加上,測試看看！！ &#96;&#96;&#96;swift&#x2F;&#x2F;將檔案讀出來 let path &#x3D; NSBundle.mainBundle().pathForResource(&quot;json&quot;, ofType: &quot;txt&quot;); var data:NSData &#x3D; NSData(contentsOfFile: path!)!; &#x2F;&#x2F;解析Json var jsonobj &#x3D; NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: nil) as NSDictionary; println(jsonobj[&quot;組織名稱&quot;] as String); println(&quot;組織成員&quot;); var arr &#x3D; jsonobj[&quot;組織成員&quot;] as NSArray; for i in (0...arr.count - 1)&#123; let mdic &#x3D; arr[i] as NSDictionary; println(mdic[&quot;姓名&quot;] as String); println(mdic[&quot;年齡&quot;] as Int); &#125;","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] NetWork (3) 判斷手機是否有網路連線可用","slug":"swift-NetWork-3-判斷手機是否有網路連線可用","date":"2015-03-05T03:09:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/05/swift-NetWork-3-判斷手機是否有網路連線可用/","link":"","permalink":"https://toyo0103.github.io/2015/03/05/swift-NetWork-3-%E5%88%A4%E6%96%B7%E6%89%8B%E6%A9%9F%E6%98%AF%E5%90%A6%E6%9C%89%E7%B6%B2%E8%B7%AF%E9%80%A3%E7%B7%9A%E5%8F%AF%E7%94%A8/","excerpt":"","text":"主要參考兩篇文章做修改:Detect Internet status programmatically using Swift and Object-C language[iOS] 即時判斷網路連線狀態 (Detect Network Status on Real-Time) Apple已經用Objective-C寫了判斷網路的套件給大家使用,所以接下來會解說如何用Swift專案載入Objective-C套件 先到這邊下載Reachability 接著把Reachability專案中的Reachability.m和Reachability.h抓到專案中 在專案中新增Header檔 打開Header檔,把Reachability.h掛進去,這樣以後專案中引用Reachability裡面的class都不再Import了 把Header檔加到專案的Build Setting中 打開Reachability.m找到(void)dealloc改成 ```swift (void)dealloc{ [self stopNotifier]; if (_reachabilityRef != NULL) {CFRelease(_reachabilityRef); } [super dealloc];} 12345678910111213141516171819202122232425* 到專案中的Build Phases,把Reachability.m加上-fno-objc-arc [![](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-iCs_Qc3MS_g&#x2F;VPfP4egfeoI&#x2F;AAAAAAAAEfg&#x2F;loz5m7jQjpU&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-05%2B%E4%B8%8A%E5%8D%8811.38.54.png)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-iCs_Qc3MS_g&#x2F;VPfP4egfeoI&#x2F;AAAAAAAAEfg&#x2F;loz5m7jQjpU&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-05%2B%E4%B8%8A%E5%8D%8811.38.54.png)* 以上就全部掛載完成了,接著來看看這個套件如何使用,並讓它告知我們網路狀態打開view controller,新增一個監測網路的變數,並且在viewDidLoad寫下 &#96;&#96;&#96;swiftvar internetReachability:Reachability!; &#x2F;&#x2F;網路狀態監控 override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F;在通知中心註冊事件,當網路狀態有變動的時候會觸發 NSNotificationCenter.defaultCenter().addObserverForName(kReachabilityChangedNotification, object: nil, queue: NSOperationQueue.mainQueue()) &#123; (NSNotification) -&gt; Void in let networksStatus: NetworkStatus &#x3D; self.internetReachability.currentReachabilityStatus() var status: String! if networksStatus.value &#x3D;&#x3D; 0 &#123; status &#x3D; &quot;Disconnection&quot; &#125; else if networksStatus.value &#x3D;&#x3D; 1 &#123; status &#x3D; &quot;Connection&quot; &#125; else &#123; status &#x3D; &quot;Connection&quot; &#125; UIAlertView(title: &quot;網路狀態&quot;, message: status, delegate: nil, cancelButtonTitle: &quot;OK&quot;).show(); &#125; self.internetReachability &#x3D; Reachability.reachabilityForInternetConnection(); &#x2F;&#x2F;開始監控狀況 self.internetReachability.startNotifier() &#125; 在Mac上面執行看看,測試方法就是把mac的wifi連線給關閉,就會看到App跳出提示訊息了 接下來把viewDidLoad改成如下,這段是告訴你目前使用的網路是什麼?Wifi or 3G之類的 ```swiftoverride func viewDidLoad() { super.viewDidLoad() let statusReach: Reachability = Reachability.reachabilityForInternetConnection() let networksStatus: NetworkStatus = statusReach.currentReachabilityStatus() var status: String! if networksStatus.value == 0 &#123; status = &quot;NoReachable&quot; &#125; else if networksStatus.value == 1 &#123; status = &quot;ReachableViaWiFi&quot; &#125; else &#123; status = &quot;ReachableViaWWAN&quot; &#125; UIAlertView(title: &quot;網路狀態&quot;, message: status, delegate: nil, cancelButtonTitle: &quot;OK&quot;).show(); } ```執行看看","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] NetWork (2) 非同步方式取得API資訊","slug":"swift-NetWork-2-非同步方式取得API資訊","date":"2015-03-04T07:39:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/04/swift-NetWork-2-非同步方式取得API資訊/","link":"","permalink":"https://toyo0103.github.io/2015/03/04/swift-NetWork-2-%E9%9D%9E%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E5%8F%96%E5%BE%97API%E8%B3%87%E8%A8%8A/","excerpt":"","text":"為了避免撈取API資料太久而讓整個APP卡住,所以建議撈取API資料時都另外開出一個queue來非同步執行 ```swiftvar url:NSURL = NSURL(string: “http://xxx.com.tw/api/getdata&quot;)!;let request:NSMutableURLRequest = NSMutableURLRequest(URL: url, cachePolicy: NSURLRequestCachePolicy.ReloadIgnoringLocalCacheData, timeoutInterval: 10);request.HTTPMethod = “POST”;request.HTTPBody = “yourdata”.dataUsingEncoding(NSUTF8StringEncoding); //新增一個queue來執行API,避免API撈取資料太久把整個APP卡住let queue :NSOperationQueue = NSOperationQueue();//非同步方式取得資料NSURLConnection.sendAsynchronousRequest(request, queue: queue, completionHandler:{ (response: NSURLResponse!, data: NSData!, error: NSError!) -&gt; Void in var err:String? = error?.description; if(data != nil &amp;&amp; error == nil) { let responseString = NSString(data: data, encoding: NSUTF8StringEncoding); println(“responseString = (responseString)”); }});","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] NetWork (1) 以Get 和 Post方式傳送資料","slug":"swift-NetWork-1-以Get-和-Post方式傳送資料","date":"2015-03-04T03:21:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/04/swift-NetWork-1-以Get-和-Post方式傳送資料/","link":"","permalink":"https://toyo0103.github.io/2015/03/04/swift-NetWork-1-%E4%BB%A5Get-%E5%92%8C-Post%E6%96%B9%E5%BC%8F%E5%82%B3%E9%80%81%E8%B3%87%E6%96%99/","excerpt":"","text":"用Post方式傳遞資料 123456789101112131415161718192021var url:NSURL = NSURL(string: &quot;http://xxx.com.tw/api/postdata&quot;)!; let request:NSMutableURLRequest = NSMutableURLRequest(URL: url, cachePolicy: NSURLRequestCachePolicy.ReloadIgnoringLocalCacheData, timeoutInterval: 10); request.HTTPMethod = &quot;POST&quot;; request.HTTPBody = &quot;yourPostData&quot;.dataUsingEncoding(NSUTF8StringEncoding); let task = NSURLSession.sharedSession().dataTaskWithRequest(request) &#123; data, response, error in if error != nil &#123; println(&quot;error=\\(error)&quot;) return &#125; println(&quot;response = \\(response)&quot;) //將收到的資料轉成字串print出來看看 let responseString = NSString(data: data, encoding: NSUTF8StringEncoding) println(&quot;responseString = \\(responseString)&quot;) &#125; task.resume(); 用Get方式傳遞資料 ```swiftvar url:NSURL = NSURL(string: “http://xxx.com.tw/api/getdata?id=5008&amp;id=5009&quot;)!;let request:NSURLRequest = NSURLRequest(URL: url, cachePolicy: NSURLRequestCachePolicy.ReloadIgnoringLocalCacheData, timeoutInterval: 10); let task = NSURLSession.sharedSession().dataTaskWithRequest(request) { data, response, error in if error != nil { println(“error=(error)”) return } println(“response = (response)”) let responseString = NSString(data: data, encoding: NSUTF8StringEncoding) println(“responseString = (responseString)”)}task.resume(); ``` 這邊整理一下從網路上找的NSURLRequestCachePolicy相關資訊,轉載自：iOS?存?存 ReloadIgnoringCacheData：忽略Cache數據,直接從原始網址下載。 ReloadRevalidatingCacheData：驗證本地的數據和遠端數據是否相同，如果不同則下?遠端?據，否?使用本地數據。* ReturnCacheDataDontLoad：只使用cache?據，如果不存在cache，請求失敗；用於?有建立網路連接離線模式；* ReturnCacheDataElseLoad：&nbsp;只有在cache中不存在data時才從原始地址下?。* UseProtocolCachePolicy： NSURLRequest默認的cache policy，使用Protocol協議定義。* ReloadIgnoringLocalAndRemoteCacheData：忽略本地和遠端的緩存數據，直接從原始地址下?，與ReloadIgnoringCacheData類似。","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 用Plist製作設定檔","slug":"swift-用Plist製作設定檔","date":"2015-03-04T01:50:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/04/swift-用Plist製作設定檔/","link":"","permalink":"https://toyo0103.github.io/2015/03/04/swift-%E7%94%A8Plist%E8%A3%BD%E4%BD%9C%E8%A8%AD%E5%AE%9A%E6%AA%94/","excerpt":"","text":"很多APP都會有一些各人化設定檔,方便下次打開APP可以依照個人的喜好設定做出最適合的調整,接下來就實作如何將個人的設定檔存起來並在下次打開APP時Show出來 首先先拉一個畫面,輸入框,確定按鈕,呈現文字的按鈕,我們的目標是在輸入框輸入的文字會被系統儲存起來,在下次App重開時依然顯示最後設定的文字 基本的code如下,只要在輸入框填好後按下確定按鈕就可以更改文字了,但你只要重開APP他就又會回到最原本Button的文字 ```swiftimport UIKitclass plistViewController: UIViewController { @IBOutlet weak var txtbox: UITextField! //輸入文字框 @IBOutlet weak var btnShowText: UIButton! //show文字的button @IBOutlet weak var btnSetting: UIButton! //確定按鈕 override func viewDidLoad() { super.viewDidLoad(); } @IBAction func btnSetting_click(sender: AnyObject) { //將輸入的文字設定給btnShowText btnShowText.setTitle(txtbox.text, forState: UIControlState.Normal); }} 12345678910111213141516171819202122[![](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-9CI9oydHno0&#x2F;VPWJqOmri8I&#x2F;AAAAAAAAEd4&#x2F;dbIiK5hekEI&#x2F;s400&#x2F;image.gif)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-9CI9oydHno0&#x2F;VPWJqOmri8I&#x2F;AAAAAAAAEd4&#x2F;dbIiK5hekEI&#x2F;s1600&#x2F;image.gif)* 所以我們至少應該先把按鈕的文字改成抓Plist檔的來源,然後按下確定按鈕時將文字先存到plist檔中,但這邊有個觀念需要先釐清,**&lt;span style&#x3D;&quot;color: red;&quot;&gt;基本上IOS APP是SandBox模式&lt;&#x2F;span&gt;**,所以只有特定資料夾內的檔案是可以寫入的,所以在這之前我們必須先新建一個Setting.plist檔案專門放設定值（建議不要用原本預設的info.plist,因為之後會移動這個檔案位置）,然後在APP開啟時檢查這個檔案是否在可讀寫的資料夾之中了,如果沒有則複製一份過去,步驟如下 先在Setting.plist新增儲存按鈕文字的欄位[![](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-OC9a4bKFHCA&#x2F;VPWKf_BN2oI&#x2F;AAAAAAAAEeA&#x2F;L_A21cnwvR4&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%886.17.54.png)](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-OC9a4bKFHCA&#x2F;VPWKf_BN2oI&#x2F;AAAAAAAAEeA&#x2F;L_A21cnwvR4&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%886.17.54.png) 接著在AppDelegate.swift的didFinishLaunchingWithOptions寫下 &#96;&#96;&#96;swiftfunc application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool &#123; &#x2F;&#x2F; Override point for customization after application launch. &#x2F;&#x2F;Setting Plist因為要可以讀寫,所以要移到Documents的folder底下 let path:String &#x3D; NSBundle.mainBundle().pathForResource(&quot;Setting&quot;, ofType: &quot;plist&quot;)!; let destinationPath &#x3D; String(format: &quot;%@&#x2F;Documents&#x2F;Setting.plist&quot;, arguments:[NSHomeDirectory()]); var fm: NSFileManager &#x3D; NSFileManager(); if (!fm.fileExistsAtPath(destinationPath)) &#123; &#x2F;&#x2F;如果在documents資料夾底下找不到該檔案,則複製一份過去 fm.copyItemAtPath(path, toPath: destinationPath, error: nil); &#125; return true &#125; 接下來將輸入的文字改存到plist中,然後按鈕文字的來源改成Setting.plist,全部程式碼如下 ```swiftimport UIKitclass plistViewController: UIViewController { @IBOutlet weak var txtbox: UITextField! //輸入文字框 @IBOutlet weak var btnShowText: UIButton! //show文字的button @IBOutlet weak var btnSetting: UIButton! //確定按鈕 override func viewDidLoad() { super.viewDidLoad(); loadBtnText(); } private func loadBtnText(){ //button預設的字由Setting plist來 btnShowText.setTitle(getSettingValue(), forState: UIControlState.Normal); } @IBAction func btnSetting_click(sender: AnyObject) { //將輸入的文字設定給btnShowText //btnShowText.setTitle(txtbox.text, forState: UIControlState.Normal); //修改成將輸入的文字存到Setting.plist後,在由那邊load給button Set_SettingPlist_Value(txtbox.text); loadBtnText(); } //取得Setting.plist裡btnText欄位得值 private func getSettingValue() -&gt; String{ var value:String!; //取得document folder底下的Setting.plist路徑 let SettingPath = String(format: “%@/Documents/Setting.plist”, arguments:[NSHomeDirectory()]); var dic:NSMutableDictionary? = NSMutableDictionary(contentsOfFile: SettingPath); //欄位名稱 if (dic?.objectForKey(“btnText”) != nil){ value = dic!.objectForKey(“btnText”) as String; } return value; } //把值存到Setting.plist裡面 private func Set_SettingPlist_Value(value:String){ let SettingPath = String(format: “%@/Documents/Setting.plist”, arguments:[NSHomeDirectory()]); var dic:NSMutableDictionary = NSMutableDictionary(contentsOfFile: SettingPath)!; if (dic.objectForKey(“btnText”) != nil) { dic.setValue(value, forKey: “btnText”); //true表示IOS會先將資料寫入一個輔助檔案中,然後再將這個檔案改為最後真正的目的地,避免出現錯誤 dic.writeToFile(SettingPath, atomically: true); } }} 123456789* 接下來再試試看程式,你會發現即便把APP關掉,下次進來時button的文字會被記錄下來！！但這邊必須特別注意一點,隨著App的開發可能會對plist有刪減,重新部署到模擬器上時要記得先把舊的APP刪掉,讓Xode幫你重新安裝,原因是我們在AppDelegate.swift的didFinishLaunchingWithOptions寫了 &#96;&#96;&#96;swiftif (!fm.fileExistsAtPath(destinationPath))&#123; &#x2F;&#x2F;如果在documents資料夾底下找不到該檔案,則複製一份過去 fm.copyItemAtPath(path, toPath: destinationPath, error: nil);&#125; 也就是說複製過一次後,之後的欄位有增減都無法改到Documents資料夾底下的那份plist了,所以只能刪除重裝！！","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] IOS地圖運用 (5) 計算點與點之間的距離","slug":"swift-IOS地圖運用-5-計算點與點之間的距離","date":"2015-03-03T09:02:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/03/swift-IOS地圖運用-5-計算點與點之間的距離/","link":"","permalink":"https://toyo0103.github.io/2015/03/03/swift-IOS%E5%9C%B0%E5%9C%96%E9%81%8B%E7%94%A8-5-%E8%A8%88%E7%AE%97%E9%BB%9E%E8%88%87%E9%BB%9E%E4%B9%8B%E9%96%93%E7%9A%84%E8%B7%9D%E9%9B%A2/","excerpt":"","text":"網路上有找到Google的計算公式,把它翻譯成Swift的語法後如下,回傳單位為**公里 ** 12345678910111213141516public static func GetDistance_Google(pointA:CLLocationCoordinate2D , pointB:CLLocationCoordinate2D) -&gt; Double&#123; let EARTH_RADIUS:Double = 6378.137; let radlng1:Double = pointA.longitude * M_PI / 180.0; let radlng2:Double = pointB.longitude * M_PI / 180.0; let a:Double = radlng1 - radlng2; let b:Double = (pointA.latitude - pointB.latitude) * M_PI / 180; var s:Double = 2 * asin(sqrt(pow(sin(a/2), 2) + cos(radlng1) * cos(radlng2) * pow(sin(b/2), 2))); s = s * EARTH_RADIUS; s = (round(s * 10000) / 10000); return s;&#125;","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] IOS地圖運用 (4) 如何區分是User Location與Annotation","slug":"swift-IOS地圖運用-4-如何區分是User-Location與Annotation","date":"2015-03-03T08:15:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/03/swift-IOS地圖運用-4-如何區分是User-Location與Annotation/","link":"","permalink":"https://toyo0103.github.io/2015/03/03/swift-IOS%E5%9C%B0%E5%9C%96%E9%81%8B%E7%94%A8-4-%E5%A6%82%E4%BD%95%E5%8D%80%E5%88%86%E6%98%AFUser-Location%E8%88%87Annotation/","excerpt":"","text":"接著上一篇,如果這時候我們再把mapkit view的user location打開來試試看,結果會發現user location的點被吃掉了,原因是我們改寫了viewForAnnotation,所有的點都會變成我們客製座標的樣式 所以我們在viewForAnnotation補上判斷,讓user location不會被改變樣式 ```swiftfunc mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -&gt; MKAnnotationView! { if(annotation is MKUserLocation)&#123; //return nil表示用預設值那個藍色發光圓形圖 return nil; &#125; var ann : MyAnnotation? = mapView.dequeueReusableAnnotationViewWithIdentifier(&quot;CustomerPoint&quot;) as? MyAnnotation; if(ann == nil)&#123; ann = MyAnnotation(annotation: annotation, reuseIdentifier: &quot;CustomerPoint&quot;); ann?.canShowCallout = true; &#125; ann?.DrawCustomerView(); ann?.annotation = annotation; return ann; } ```結果如下,user location又出來摟～","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] IOS地圖運用 (3) 客製Annotation View","slug":"swift-IOS地圖運用-3-客製Annotation-View","date":"2015-03-03T06:47:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/03/swift-IOS地圖運用-3-客製Annotation-View/","link":"","permalink":"https://toyo0103.github.io/2015/03/03/swift-IOS%E5%9C%B0%E5%9C%96%E9%81%8B%E7%94%A8-3-%E5%AE%A2%E8%A3%BDAnnotation-View/","excerpt":"","text":"繼續接續上一篇,我們來把大頭針改成自己想要的樣子吧,已這張圖為例 從上面那張圖可以看出來需要畫一個長方形,長方形裡面有一個title與圓形Icon,還需要一個倒三角形把它組回去,所以先來把這些元素準備一下吧首先先建立一個Class繼承MKAnnotationView ```swiftimport Foundationimport MapKitpublic class MyAnnotation : MKAnnotationView { var rectangoView:UIView!; //長方形 var lblTitle:UILabel!;//Title var lblIcon:UILabel!;//圓形icon var circleView:UIView!; //原型view var triangle:UIView!; //三角形 public override init(annotation: MKAnnotation!, reuseIdentifier: String!) { super.init(annotation: annotation, reuseIdentifier: reuseIdentifier); } public required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647* 接著把每個圖形間的關係組合起來,例如圓形跟title都在大大的長方形裡面,所以先將他們add到rectangoView裡面 &#96;&#96;&#96;swiftimport Foundationimport MapKitpublic class MyAnnotation : MKAnnotationView &#123; var rectangoView:UIView!; &#x2F;&#x2F;長方形 var lblTitle:UILabel!;&#x2F;&#x2F;Title var lblIcon:UILabel!;&#x2F;&#x2F;圓形icon var circleView:UIView!; &#x2F;&#x2F;原型view var triangle:UIView!; &#x2F;&#x2F;三角形 var DrawView:UIView!;&#x2F;&#x2F;整個客製座標的畫布 public override init!(annotation: MKAnnotation!, reuseIdentifier: String!) &#123; super.init(annotation: annotation, reuseIdentifier: reuseIdentifier); &#x2F;&#x2F;先把每個圖層間的關係建立好,例如圓形跟title都在大大的長方形裡面,所以先add進去 lblTitle &#x3D; UILabel(); lblIcon &#x3D; UILabel(); rectangoView &#x3D; UIView(); circleView &#x3D; UIView(); circleView.addSubview(lblIcon); rectangoView.addSubview(lblTitle) rectangoView.addSubview(circleView); &#x2F;&#x2F;畫出三角形遮罩 &#x2F;&#x2F;原理：將遮罩蓋到長方形上面,他會將不再這個框框範圍內的都過濾掉,就可以跑出三角形了 let path:UIBezierPath &#x3D; UIBezierPath (); path.moveToPoint(CGPoint(x: 0, y: 0)); path.addLineToPoint(CGPoint(x: 10, y: 10)); path.addLineToPoint(CGPoint(x: 20, y: 0)); path.addLineToPoint(CGPoint(x: 0, y: 0)); let masklayer:CAShapeLayer &#x3D; CAShapeLayer ();&#x2F;&#x2F;遮罩 masklayer.path &#x3D; path.CGPath; &#x2F;&#x2F;遮罩遮出三角型 triangle &#x3D; UIView(frame: CGRect(x: 22, y: 28, width: 20, height: 20)); triangle.layer.mask &#x3D; masklayer; DrawView &#x3D; UIView(); DrawView.addSubview(rectangoView); DrawView.addSubview(triangle); self.addSubview(DrawView); &#125; public required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder); &#125;&#125; 接著在MyAnnotation寫一個function來詳細畫這個View的內容 ```swiftpublic func DrawCustomerView() { //Title lblTitle.text = &quot;5200萬&quot;; lblTitle.textColor = UIColor.whiteColor(); lblTitle.font = UIFont.systemFontOfSize(12); lblTitle.sizeToFit(); //大大的長方形 rectangoView.frame = CGRect(x: 0, y: 0, width: lblTitle.frame.width + 30, height: 28);//整體 rectangoView.backgroundColor = UIColor(red: 0.208, green:0.596 , blue: 0.859, alpha: 1); rectangoView.layer.cornerRadius = 3;//設定圓角 //“icon”圓型小字 lblIcon.font = UIFont.systemFontOfSize(11); lblIcon.font = UIFont.boldSystemFontOfSize(14); lblIcon.text = &quot;成&quot;; lblIcon.textColor = rectangoView.backgroundColor; lblIcon.sizeToFit(); lblIcon.center = CGPoint (x: 10, y: 10); //圓形 circleView.frame = CGRect(x: 2, y: 4, width: 20, height: 20);//圓形標籤 circleView.backgroundColor = UIColor.whiteColor(); circleView.layer.cornerRadius = 10; circleView.alpha = 1; //畫三角形 triangle.backgroundColor = UIColor(red: 0.208, green:0.596 , blue: 0.859, alpha: 1); //rectangoView.Transform 旋轉 DrawView.frame = CGRect(x: 0, y: 0, width:triangle.frame.width,height: 48); } 12345678910111213* 接下來修改view controller的viewForAnnotation事件如下 &#96;&#96;&#96;swiftfunc mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -&gt; MKAnnotationView! &#123; var ann : MyAnnotation? &#x3D; mapView.dequeueReusableAnnotationViewWithIdentifier(&quot;CustomerPoint&quot;) as? MyAnnotation; if(ann &#x3D;&#x3D; nil)&#123; ann &#x3D; MyAnnotation(annotation: annotation, reuseIdentifier: &quot;CustomerPoint&quot;); ann?.canShowCallout &#x3D; true; &#125; ann?.DrawCustomerView(); ann?.annotation &#x3D; annotation; return ann; &#125; 立馬執行看看,你會發現發生錯誤在MyAnnotation class,而且錯誤訊息寫得不清不楚的,這是第一個地雷,雖然繼承MKAnnotationView沒有要求一定要實作init(frame: CGRect),但不做會壞掉喔,那到底幹麻不列為required阿！！！所以乖乖補上到MyAnnotation就正常摟 ```swiftoverride init(frame: CGRect) { super.init(frame: frame); } 1234567* 這時候會發現畫面長這樣...[![](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-OGPbgnJnyH0&#x2F;VPVpfcMNstI&#x2F;AAAAAAAAEcs&#x2F;NGAf74G1IoU&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%883.57.37.png)](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-OGPbgnJnyH0&#x2F;VPVpfcMNstI&#x2F;AAAAAAAAEcs&#x2F;NGAf74G1IoU&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%883.57.37.png)請在DrawCustomerView這個地方補上下面這段code,讓文字位移後執行看看會變得正常多了 &#96;&#96;&#96;swiftlblTitle.frame.origin.x &#x3D; 24;&#x2F;&#x2F;中心位移lblTitle.frame.origin.y &#x3D; 7; 接下來我們測試一下這個畫出來的點是否跟插大頭針指的位置相同,結果…..歪掉了 但我們可以看出來他是在針頭的地方開始畫,所以來做點加工吧,在DrawCustomerView()最後面加上下面的code讓整個View位移來符合需求 ```swiftself.frame = CGRect(x: 0, y: 0, width: rectangoView.frame.width, height: rectangoView.frame.height); self.centerOffset = CGPoint(x: 0, y: -21); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859我們再看看...[![](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-mPNj85zu_a8&#x2F;VPVsk5Xv-9I&#x2F;AAAAAAAAEdA&#x2F;faM54vpHC28&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%884.10.45.png)](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-mPNj85zu_a8&#x2F;VPVsk5Xv-9I&#x2F;AAAAAAAAEdA&#x2F;faM54vpHC28&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%884.10.45.png)* 看起來一切正常了,把一些測試的程式碼拿掉後完整如下view controller &#96;&#96;&#96;swiftimport UIKitimport CoreLocationimport MapKitclass MapViewController: UIViewController,CLLocationManagerDelegate , MKMapViewDelegate&#123; @IBOutlet weak var uimap: MKMapView!&#x2F;&#x2F;地圖元件 var location : CLLocationManager!; &#x2F;&#x2F;座標管理元件 override func viewDidLoad() &#123; super.viewDidLoad(); location &#x3D; CLLocationManager(); location.delegate &#x3D; self; &#x2F;&#x2F;詢問使用者是否同意給APP定位功能 location.requestWhenInUseAuthorization(); &#x2F;&#x2F;開始接收目前位置資訊 location.startUpdatingLocation(); location.distanceFilter &#x3D; CLLocationDistance(10); &#x2F;&#x2F;表示移動10公尺再更新座標資訊 uimap.delegate &#x3D; self; &#125; override func viewDidDisappear(animated: Bool) &#123; &#x2F;&#x2F;因為ＧＰＳ功能很耗電,所以被敬執行時關閉定位功能 location.stopUpdatingLocation(); &#125; func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) &#123; &#x2F;&#x2F;取得目前的座標位置 let c &#x3D; locations[0] as CLLocation; let nowLocation &#x3D; CLLocationCoordinate2D(latitude: c.coordinate.latitude, longitude: c.coordinate.longitude); &#x2F;&#x2F;將map中心點定在目前所在的位置 &#x2F;&#x2F;span是地圖zoom in, zoom out的級距 let _span:MKCoordinateSpan &#x3D; MKCoordinateSpan(latitudeDelta: 0.0005, longitudeDelta: 0.0005); self.uimap.setRegion(MKCoordinateRegion(center: nowLocation, span: _span), animated: true); &#x2F;&#x2F;加入座標 addPointAnnotation(c.coordinate.latitude, longitude: c.coordinate.longitude); &#125; &#x2F;&#x2F;新增座標 private func addPointAnnotation(latitude:CLLocationDegrees , longitude:CLLocationDegrees)&#123; &#x2F;&#x2F;大頭針 var point:MKPointAnnotation &#x3D; MKPointAnnotation(); &#x2F;&#x2F;設定大頭針的座標位置 point.coordinate &#x3D; CLLocationCoordinate2D(latitude: latitude, longitude: longitude); uimap.addAnnotation(point); &#125; func mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -&gt; MKAnnotationView! &#123; var ann : MyAnnotation? &#x3D; mapView.dequeueReusableAnnotationViewWithIdentifier(&quot;CustomerPoint&quot;) as? MyAnnotation; if(ann &#x3D;&#x3D; nil)&#123; ann &#x3D; MyAnnotation(annotation: annotation, reuseIdentifier: &quot;CustomerPoint&quot;); ann?.canShowCallout &#x3D; true; &#125; ann?.DrawCustomerView(); ann?.annotation &#x3D; annotation; return ann; &#125;&#125; MyAnnotation Class完整如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import Foundationimport MapKitpublic class MyAnnotation : MKAnnotationView &#123; var rectangoView:UIView!; //長方形 var lblTitle:UILabel!;//Title var lblIcon:UILabel!;//圓形icon var circleView:UIView!; //原型view var triangle:UIView!; //三角形 var DrawView:UIView!;//整個客製座標的畫布 override init(annotation: MKAnnotation!, reuseIdentifier: String!) &#123; super.init(annotation: annotation, reuseIdentifier: reuseIdentifier); //先把每個圖層間的關係建立好,例如圓形跟title都在大大的長方形裡面,所以先add進去 lblTitle = UILabel(); lblIcon = UILabel(); rectangoView = UIView(); circleView = UIView(); circleView.addSubview(lblIcon); rectangoView.addSubview(lblTitle) rectangoView.addSubview(circleView); //畫出三角形遮罩 //原理：將遮罩蓋到長方形上面,他會將不再這個框框範圍內的都過濾掉,就可以跑出三角形了 let path:UIBezierPath = UIBezierPath (); path.moveToPoint(CGPoint(x: 0, y: 0)); path.addLineToPoint(CGPoint(x: 10, y: 10)); path.addLineToPoint(CGPoint(x: 20, y: 0)); path.addLineToPoint(CGPoint(x: 0, y: 0)); let masklayer:CAShapeLayer = CAShapeLayer ();//遮罩 masklayer.path = path.CGPath; //遮罩遮出三角型 triangle = UIView(frame: CGRect(x: 22, y: 28, width: 20, height: 20)); triangle.layer.mask = masklayer; DrawView = UIView(); DrawView.addSubview(rectangoView); DrawView.addSubview(triangle); self.addSubview(DrawView); &#125; public required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder); &#125; override init(frame: CGRect) &#123; super.init(frame: frame); &#125; public func DrawCustomerView() &#123; //Title lblTitle.text = &quot;5200萬&quot;; lblTitle.textColor = UIColor.whiteColor(); lblTitle.font = UIFont.systemFontOfSize(12); lblTitle.frame.origin.x = 24;//中心位移 lblTitle.frame.origin.y = 7; lblTitle.sizeToFit(); //大大的長方形 rectangoView.frame = CGRect(x: 0, y: 0, width: lblTitle.frame.width + 30, height: 28);//整體 rectangoView.backgroundColor = UIColor(red: 0.208, green:0.596 , blue: 0.859, alpha: 1); rectangoView.layer.cornerRadius = 3;//設定圓角 //“icon”圓型小字 lblIcon.font = UIFont.systemFontOfSize(11); lblIcon.font = UIFont.boldSystemFontOfSize(14); lblIcon.text = &quot;成&quot;; lblIcon.textColor = rectangoView.backgroundColor; lblIcon.sizeToFit(); lblIcon.center = CGPoint (x: 10, y: 10); //圓形 circleView.frame = CGRect(x: 2, y: 4, width: 20, height: 20);//圓形標籤 circleView.backgroundColor = UIColor.whiteColor(); circleView.layer.cornerRadius = 10; circleView.alpha = 1; //畫三角形 triangle.backgroundColor = UIColor(red: 0.208, green:0.596 , blue: 0.859, alpha: 1); //rectangoView.Transform 旋轉 DrawView.frame = CGRect(x: 0, y: 0, width:triangle.frame.width,height: 48); self.frame = CGRect(x: 0, y: 0, width: rectangoView.frame.width, height: rectangoView.frame.height); self.centerOffset = CGPoint(x: 0, y: -21); &#125;&#125;","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] IOS地圖運用 (2) 在地圖釘上大頭針","slug":"swift-IOS地圖運用-2-在地圖釘上大頭針","date":"2015-03-03T03:30:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/03/swift-IOS地圖運用-2-在地圖釘上大頭針/","link":"","permalink":"https://toyo0103.github.io/2015/03/03/swift-IOS%E5%9C%B0%E5%9C%96%E9%81%8B%E7%94%A8-2-%E5%9C%A8%E5%9C%B0%E5%9C%96%E9%87%98%E4%B8%8A%E5%A4%A7%E9%A0%AD%E9%87%9D/","excerpt":"","text":"承上一篇的Code我們繼續往下延伸,如何在地圖釘上大頭針呢?首先我們把mapkit view的user location選項關閉,改成自己放上去的大頭針試試看 把程式修改如下,這邊主要著重在addPointAnnotation這個function ```swiftimport UIKitimport CoreLocationimport MapKitclass MapViewController: UIViewController,CLLocationManagerDelegate { @IBOutlet weak var uimap: MKMapView!//地圖元件 var location : CLLocationManager!; //座標管理元件 override func viewDidLoad() { super.viewDidLoad(); location = CLLocationManager(); location.delegate = self; //詢問使用者是否同意給APP定位功能 location.requestWhenInUseAuthorization(); //開始接收目前位置資訊 location.startUpdatingLocation(); location.distanceFilter = CLLocationDistance(10); //表示移動10公尺再更新座標資訊 } override func viewDidDisappear(animated: Bool) &#123; //因為ＧＰＳ功能很耗電,所以被敬執行時關閉定位功能 location.stopUpdatingLocation(); } func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) { //取得目前的座標位置 let c = locations[0] as CLLocation; let nowLocation = CLLocationCoordinate2D(latitude: c.coordinate.latitude, longitude: c.coordinate.longitude); //將map中心點定在目前所在的位置 //span是地圖zoom in, zoom out的級距 let _span:MKCoordinateSpan = MKCoordinateSpan(latitudeDelta: 0.0005, longitudeDelta: 0.0005); self.uimap.setRegion(MKCoordinateRegion(center: nowLocation, span: _span), animated: true); //加入座標 addPointAnnotation(c.coordinate.latitude, longitude: c.coordinate.longitude); } //新增座標 private func addPointAnnotation(latitude:CLLocationDegrees , longitude:CLLocationDegrees){ //大頭針 var point:MKPointAnnotation = MKPointAnnotation(); //設定大頭針的座標位置 point.coordinate = CLLocationCoordinate2D(latitude: latitude, longitude: longitude); point.title = &quot;I&#39;m here&quot;; point.subtitle = &quot;緯度：\\(latitude) 經度:\\(longitude)&quot;; uimap.addAnnotation(point); }} 123456執行看看成果,點擊大頭貼可以看到剛剛設定的title與subtitle[![](http:&#x2F;&#x2F;2.bp.blogspot.com&#x2F;-sBszQR-gCvw&#x2F;VPVRTFVx06I&#x2F;AAAAAAAAEb8&#x2F;wR8k2LQSLvI&#x2F;s400&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%882.14.19.png)](http:&#x2F;&#x2F;2.bp.blogspot.com&#x2F;-sBszQR-gCvw&#x2F;VPVRTFVx06I&#x2F;AAAAAAAAEb8&#x2F;wR8k2LQSLvI&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8B%E5%8D%882.14.19.png)* 那如果想將大頭針變色呢?首先先將view controller繼承MKMapViewDelegate,並將mapview kit delegate指定為自己這個veiew controller &#96;&#96;&#96;swiftuimap.delegate &#x3D; self; 接著override mapview的viewForAnnotation事件 ```swiftfunc mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -&gt; MKAnnotationView! { var pointView : MKPinAnnotationView? = mapView.dequeueReusableAnnotationViewWithIdentifier(“CustomerPoint”) as?MKPinAnnotationView; if(pointView == nil){pointView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: &quot;CustomerPoint&quot;); //因為已經改寫了Annotation View,所以要將canShowCallout改成true,否則點擊大頭針不會跑出來我們剛剛指定的title跟subtitle pointView?.canShowCallout = true; } pointView!.pinColor = MKPinAnnotationColor.Green; return pointView;} ``` 結果如下 這邊應該看出來整個Annotation的顯示方式都可以透過viewForAnnotation這個事件來改寫,所以下一篇就來介紹如何客製化Annotation的View","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] IOS地圖運用 (1) 取得目前座標位置","slug":"swift-IOS地圖運用-1-取得目前座標位置","date":"2015-03-03T02:23:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/03/swift-IOS地圖運用-1-取得目前座標位置/","link":"","permalink":"https://toyo0103.github.io/2015/03/03/swift-IOS%E5%9C%B0%E5%9C%96%E9%81%8B%E7%94%A8-1-%E5%8F%96%E5%BE%97%E7%9B%AE%E5%89%8D%E5%BA%A7%E6%A8%99%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"地圖資訊是手機很大量運用的資訊之一,接下來是來整理關於目前學到的MapKit View地圖的運用 首先先拉一個新的ViewController,並將MapKit View拉近去 接著在ViewController建立參數與MapKit View做對應,這邊需要注意的地方是用Map元件需要import MapKit```swiftimport UIKitimport MapKitclass MapViewController: UIViewController { @IBOutlet weak var uimap: MKMapView!//地圖元件 override func viewDidLoad() { super.viewDidLoad() } override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. }} 12345678910111213141516171819202122232425262728293031323334353637* 取得座標資訊是由一個叫要做CLLocationManager來控制的,又IOS8取得座標資訊必須先取得使用者的授權才可以,所以必須到Info.plist新增NSLocationAlwaysUsageDescription或NSLocationWhenInUseUsageDescription兩種鍵值,而前者表示不管ＡＰＰ在前景或背景執行都會持續取得座標資訊,而後者只有在需要時才會去取座標定位資訊,而這兩個鍵值分別對應到CLLocationManager的requestAlwaysAuthorization和requestWhenInUseAuthorization,這邊的範例已NSLocationWhenInUseUsageDescription為例 &#96;&#96;&#96;swiftimport UIKitimport CoreLocationimport MapKitclass MapViewController: UIViewController,CLLocationManagerDelegate &#123; @IBOutlet weak var uimap: MKMapView!&#x2F;&#x2F;地圖元件 var location : CLLocationManager!; &#x2F;&#x2F;座標管理元件 override func viewDidLoad() &#123; super.viewDidLoad(); location &#x3D; CLLocationManager(); location.delegate &#x3D; self; &#x2F;&#x2F;詢問使用者是否同意給APP定位功能 location.requestWhenInUseAuthorization(); &#x2F;&#x2F;開始接收目前位置資訊 location.startUpdatingLocation(); &#125; override func viewDidDisappear(animated: Bool) &#123; &#x2F;&#x2F;因為ＧＰＳ功能很耗電,所以被敬執行時關閉定位功能 location.stopUpdatingLocation(); &#125; func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) &#123; &#x2F;&#x2F;取得目前的座標位置 let c &#x3D; locations[0] as CLLocation; &#x2F;&#x2F;c.coordinate.latitude 目前緯度 &#x2F;&#x2F;c.coordinate.longitude 目前經度 let nowLocation &#x3D; CLLocationCoordinate2D(latitude: c.coordinate.latitude, longitude: c.coordinate.longitude); &#x2F;&#x2F;將map中心點定在目前所在的位置 &#x2F;&#x2F;span是地圖zoom in, zoom out的級距 let _span:MKCoordinateSpan &#x3D; MKCoordinateSpan(latitudeDelta: 0.0005, longitudeDelta: 0.0005); self.uimap.setRegion(MKCoordinateRegion(center: nowLocation, span: _span), animated: true); &#125;&#125; 接著別忘了去Info.plist新增NSLocationWhenInUsageDescription [![](http://2.bp.blogspot.com/-FwRtS6qlxv0/VPUmFe5sNwI/AAAAAAAAEbI/ZBcSw4FmZKY/s400/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8A%E5%8D%8811.09.07.png)](http://2.bp.blogspot.com/-FwRtS6qlxv0/VPUmFe5sNwI/AAAAAAAAEbI/ZBcSw4FmZKY/s1600/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-03%2B%E4%B8%8A%E5%8D%8811.09.07.png) 接著執行看看！！ 詢問是否授權取得座標資訊地圖中心點移到你目前的位置摟~ 順帶一提,如果需要把使用者的位置座標顯示出來,在mapkit view設定檔將User Location打勾即可！！ 如果你有實際run過這段程式應該會發現你滑動map時,它會一直彈回你目前所在的位置,原因是我們沒有指定移動多少距離才會更新座標位置,所以didUpdateLocations會一直被呼叫,也就一直被彈回你的所在位置摟,告訴app移動多少距離再更新座標資訊即可 ```swiftlocation.distanceFilter = CLLocationDistance(10); //表示移動10公尺再更新座標資訊","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift]Navigation Controller  (2) 傳遞參數","slug":"swift-Navigation-Controller-2-傳遞參數","date":"2015-03-03T01:28:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/03/swift-Navigation-Controller-2-傳遞參數/","link":"","permalink":"https://toyo0103.github.io/2015/03/03/swift-Navigation-Controller-2-%E5%82%B3%E9%81%9E%E5%8F%83%E6%95%B8/","excerpt":"","text":"如果要在換頁時讓PageA傳遞數值給PageB,並且在PageB顯示傳遞的參數時作法如下 先在PageB的Controller新增一個Label,我們將用它來顯示PageA究竟傳了什麼過來```swiftimport UIKitclass Page_B_ViewController: UIViewController { @IBOutlet weak var lblValue: UILabel! //顯示傳遞數值的Label var fromA_Value:String!;//儲存Page_A傳遞過來的數值 override func viewDidLoad() { super.viewDidLoad(); lblValue.text = fromA_Value; }} 1234567891011121314151617181920212223242526272829303132333435* 接著在PageA Controller新增**prepareForSegue**事件 &#96;&#96;&#96;swiftimport UIKitclass Page_A_ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F;NavBar self.navigationController?.navigationBar.barTintColor &#x3D; UIColor(red: 0.58, green: 0.761, blue: 0.231, alpha: 1) let titleDic : NSDictionary &#x3D; [NSForegroundColorAttributeName : UIColor.whiteColor()]; &#x2F;&#x2F;字的顏色 self.navigationController?.navigationBar.titleTextAttributes &#x3D; titleDic; self.navigationController?.navigationBar.tintColor &#x3D; UIColor.whiteColor() &#x2F;&#x2F;按鈕的顏色 let barOptionIcon : UIBarButtonItem &#x3D; UIBarButtonItem(image: UIImage(named: &quot;icon-options&quot;), style: UIBarButtonItemStyle.Plain, target: self, action: &quot;PushToOptionController:&quot;); self.navigationController?.navigationBar.topItem?.setRightBarButtonItem(barOptionIcon, animated: true) ; &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() &#x2F;&#x2F; Dispose of any resources that can be recreated. &#125; &#x2F;&#x2F;右上角Button按下時觸發的事件 func PushToOptionController(sender: UIBarButtonItem) &#123; self.performSegueWithIdentifier(&quot;toPageB&quot;, sender: self); &#125; &#x2F;&#x2F;準備跳轉頁面的設定 override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) &#123; if(segue.identifier &#x3D;&#x3D; &quot;toPageB&quot;)&#123; var page_b:Page_B_ViewController? &#x3D; segue.destinationViewController as? Page_B_ViewController if(page_b !&#x3D; nil)&#123; page_b?.fromA_Value &#x3D; &quot;來自Ａ的數值&quot;; &#125; &#125; &#125;&#125; 完成!!!","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift]Navigation Controller (1) 畫面切換","slug":"swift-Navigation-Controller-1-畫面切換","date":"2015-03-02T09:47:00.000Z","updated":"2022-08-09T13:36:17.082Z","comments":true,"path":"2015/03/02/swift-Navigation-Controller-1-畫面切換/","link":"","permalink":"https://toyo0103.github.io/2015/03/02/swift-Navigation-Controller-1-%E7%95%AB%E9%9D%A2%E5%88%87%E6%8F%9B/","excerpt":"","text":"先拉一個Navigation Controller到StoryBoard,並將起始指標指向它 接著拉個ViewA並且設定他為root view並且執行看看執行結果首頁就是剛剛指定root view的那一頁了 接著在拉第二個ViewB,並將ViewA與ViewB做Push的關聯 接著設定這個push segue的identifier 在ViewA做已下修改 ```swiftimport UIKitclass Page_A_ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() //NavBar self.navigationController?.navigationBar.barTintColor = UIColor(red: 0.58, green: 0.761, blue: 0.231, alpha: 1) let titleDic : NSDictionary = [NSForegroundColorAttributeName : UIColor.whiteColor()]; //字的顏色 self.navigationController?.navigationBar.titleTextAttributes = titleDic; self.navigationController?.navigationBar.tintColor = UIColor.whiteColor() //按鈕的顏色 //設定右上角的按鈕let barOptionIcon : UIBarButtonItem = UIBarButtonItem(image: UIImage(named: “icon-options”), style: UIBarButtonItemStyle.Plain, target: self, action: “PushToOptionController:”); self.navigationController?.navigationBar.topItem?.setRightBarButtonItem(barOptionIcon, animated: true) ;} //右上角Button按下時觸發的事件func PushToOptionController(sender: UIBarButtonItem) { self.performSegueWithIdentifier(“toPageB”, sender: self);} } ``` 完成後試試看,點擊右上角的按鈕即可跳到第二頁了！！","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift]使用Storyboard的情況下,設定App的第一頁","slug":"swift-使用Storyboard的情況下-設定App的第一頁","date":"2015-03-02T08:45:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/02/swift-使用Storyboard的情況下-設定App的第一頁/","link":"","permalink":"https://toyo0103.github.io/2015/03/02/swift-%E4%BD%BF%E7%94%A8Storyboard%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B-%E8%A8%AD%E5%AE%9AApp%E7%9A%84%E7%AC%AC%E4%B8%80%E9%A0%81/","excerpt":"","text":"方法一:打開Storyboard移動起始指標,指到的Controller預設就會用那個ViewController為起始頁面方法二:先對在Storyboard的Controller設定Storyboard ID 然後找到AppDelegate.swift檔案改寫didFinishLaunchingWithOptions ```swiftfunc application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool { let storyboard = UIStoryboard(name:”Main” , bundle: nil);self.window? = UIWindow(frame: UIScreen.mainScreen().bounds);//指定Storyboard IDself.window?.rootViewController = storyboard.instantiateViewControllerWithIdentifier(“testa”) as? UIViewController;self.window?.makeKeyAndVisible();return true}","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 製作IOS Table (4)利用xib客製Tabel Cell","slug":"swift-製作IOS-Table-4-利用xib客製Tabel-Cell","date":"2015-03-02T07:50:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2015/03/02/swift-製作IOS-Table-4-利用xib客製Tabel-Cell/","link":"","permalink":"https://toyo0103.github.io/2015/03/02/swift-%E8%A3%BD%E4%BD%9CIOS-Table-4-%E5%88%A9%E7%94%A8xib%E5%AE%A2%E8%A3%BDTabel-Cell/","excerpt":"","text":"前幾篇是透過StoryBoard來建立客製的cell view這篇則是要寫如何透過xib來完成cell view 一樣先建立一個對應的Class ```swiftimport Uikitpublic class XibCell : UITableViewCell{ @IBOutlet weak var lblTitle: UILabel! //title的label @IBOutlet weak var imgIcon: UIImageView! //icon的小圖片 public override init()&#123; super.init(); } public required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445* 建立一個.xib的View[![](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-i547UQ5vRNc&#x2F;VPQbuDo0_LI&#x2F;AAAAAAAAEXo&#x2F;zna_SQsYioA&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%884.12.47.png)](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-i547UQ5vRNc&#x2F;VPQbuDo0_LI&#x2F;AAAAAAAAEXo&#x2F;zna_SQsYioA&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%884.12.47.png)* 指定xib的class為XibCell[![](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-CkRdJKdxYcs&#x2F;VPQcWDhQ8rI&#x2F;AAAAAAAAEXw&#x2F;e334Wa4ZKFc&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%884.14.39.png)](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-CkRdJKdxYcs&#x2F;VPQcWDhQ8rI&#x2F;AAAAAAAAEXw&#x2F;e334Wa4ZKFc&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%884.14.39.png)* 把UI的關聯拉起來[![](http:&#x2F;&#x2F;2.bp.blogspot.com&#x2F;-qDluWRV2fRc&#x2F;VPQeGTJOPfI&#x2F;AAAAAAAAEX8&#x2F;Cna7u8bnTWc&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%884.23.35.png)](http:&#x2F;&#x2F;2.bp.blogspot.com&#x2F;-qDluWRV2fRc&#x2F;VPQeGTJOPfI&#x2F;AAAAAAAAEX8&#x2F;Cna7u8bnTWc&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%884.23.35.png)* controller的寫法大同小異,但請注意cellForRowAtIndexPath的寫法改變 &#96;&#96;&#96;swiftimport UIKitclass xibTableViewController: UIViewController ,UITableViewDelegate , UITableViewDataSource&#123; @IBOutlet weak var uitable: UITableView! var data :[String]!; &#x2F;&#x2F;資料來源 override func viewDidLoad() &#123; super.viewDidLoad(); data &#x3D; []; data.append(&quot;籃球&quot;); data.append(&quot;棒球&quot;); data.append(&quot;足球&quot;); uitable.delegate &#x3D; self; uitable.dataSource &#x3D; self; &#125; &#x2F;&#x2F;這個table包含幾個section func numberOfSectionsInTableView(tableView: UITableView!) -&gt; Int &#123; return 1 &#125; &#x2F;&#x2F;每個section有幾個row func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count; &#125; &#x2F;&#x2F;每個row顯示的內容 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let identifier &#x3D; &quot;cellid&quot;; var cell : XibCell? &#x3D; self.uitable.dequeueReusableCellWithIdentifier(identifier) as? XibCell; if cell &#x3D;&#x3D; nil&#123; &#x2F;&#x2F;載入xib當作cell view uitable.registerNib(UINib(nibName: &quot;xibcell&quot;, bundle: nil), forCellReuseIdentifier: identifier); cell &#x3D; self.uitable.dequeueReusableCellWithIdentifier(identifier) as? XibCell; &#125; &#x2F;&#x2F;indexPath.row 可以知道目前是要製作第幾列的view cell?.lblTitle?.text &#x3D; data[indexPath.row]; cell?.imgIcon.image &#x3D; UIImage(named: &quot;icon-factory&quot;); return cell!; &#125;&#125; 最後呈現結果","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 製作IOS Table (3)點擊時展開cell","slug":"swift-製作IOS-Table-3-點擊時展開cell","date":"2015-03-02T07:08:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/02/swift-製作IOS-Table-3-點擊時展開cell/","link":"","permalink":"https://toyo0103.github.io/2015/03/02/swift-%E8%A3%BD%E4%BD%9CIOS-Table-3-%E9%BB%9E%E6%93%8A%E6%99%82%E5%B1%95%E9%96%8Bcell/","excerpt":"","text":"常常看到一些APP可以點擊TableCell時會動態展開看到更多的內容製作方式如下 在Storyboard將cell的高度調整後,把要顯示的更多資料擺進去,此例子是多了兩顆按鈕 [重要]記得要將tablecell的Clip Subviews打勾,這樣才能呈現擇疊的效果,如果沒打勾隱藏起來的按鈕都會跑出來並且蓋到其他cell上面 新增一個CellsValue Class ```swiftimport Foundationpublic class CellsValue{ var title:String!;//標題 var expand:Bool = false;//cell是否展開,預設為false init(){}} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758* 將controller改寫如下&#96;&#96;&#96;swiftimport UIKitclass ViewController: UIViewController , UITableViewDelegate , UITableViewDataSource&#123; @IBOutlet weak var uitable: UITableView! var data : [CellsValue]!; override func viewDidLoad() &#123; super.viewDidLoad() uitable.dataSource &#x3D; self; uitable.delegate &#x3D; self; data &#x3D; []; var c &#x3D; CellsValue(); c.title &#x3D; &quot;便當&quot;; data.append(c); c &#x3D; CellsValue(); c.title &#x3D; &quot;雞腿便當&quot;; data.append(c); c &#x3D; CellsValue(); c.title &#x3D; &quot;排骨便當&quot;; data.append(c); &#125; &#x2F;&#x2F;這個table包含幾個section func numberOfSectionsInTableView(tableView: UITableView!) -&gt; Int &#123; return 1 &#125; &#x2F;&#x2F;每個section有幾個row func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count; &#125; &#x2F;&#x2F;每個row顯示的內容 func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let identifier &#x3D; &quot;Customer_Cell&quot;; var cell:CustomerCell? &#x3D; uitable.dequeueReusableCellWithIdentifier(identifier) as? CustomerCell; if(cell &#x3D;&#x3D; nil)&#123; cell &#x3D; CustomerCell(style: UITableViewCellStyle.Default, reuseIdentifier: identifier); &#125; &#x2F;&#x2F;indexPath.row 可以知道目前是要製作第幾列的view cell?.lblTitle?.text &#x3D; data[indexPath.row].title; &#x2F;&#x2F;依據是第幾個row決定icon的圖片 switch indexPath.row&#123; case 0: cell?.imgIcon.image &#x3D; UIImage(named: &quot;icon-factory&quot;); break; case 1: cell?.imgIcon.image &#x3D; UIImage(named: &quot;icon-location&quot;); break; case 2: cell?.imgIcon.image &#x3D; UIImage(named: &quot;icon-money&quot;); break; default: break; &#125; return cell!; &#125;&#125; override cell高度的事件heightForRowAtIndexPath ```swift//每個cell的heightfunc tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat { let cellValue = data[indexPath.row]; //如果cell是展開的話,回傳高度為120 if(cellValue.expand){ return 120; } else{ //否則回傳44 return 44; }} 1234567891011121314* override didSelectRowAtIndexPath事件 &#96;&#96;&#96;swift&#x2F;&#x2F;cell被選擇的狀況func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) &#123; data[indexPath.row].expand &#x3D; !data[indexPath.row].expand; &#x2F;&#x2F;將目前狀態相反後存回去 var cell &#x3D; tableView.cellForRowAtIndexPath(indexPath) as? CustomerCell; if(cell !&#x3D; nil)&#123; &#x2F;&#x2F;為了讓cell展開或閉合的效果能呈現,所以要呼叫reloadRowsAtIndexPaths讓cell重繪 uitable.reloadRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Automatic) &#x2F;&#x2F;不要讓cell有選擇起來的反黑的效果,用這這個語法可以取消選擇 uitable.deselectRowAtIndexPath(indexPath, animated: false); &#125;&#125; 大功告成,點擊後會展開跟收合的Cell就完成了","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 製作IOS Table (2)客製化cell","slug":"swift-製作IOS-Table-2-客製化cell","date":"2015-03-02T06:02:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/02/swift-製作IOS-Table-2-客製化cell/","link":"","permalink":"https://toyo0103.github.io/2015/03/02/swift-%E8%A3%BD%E4%BD%9CIOS-Table-2-%E5%AE%A2%E8%A3%BD%E5%8C%96cell/","excerpt":"","text":"基於上一篇的基礎語法可以做出簡單的table,但果要客製化每個cell的樣式呢？已storyboard為例 在storyboard拉cell並且佈置成自己要的樣子 建立相對應的cell Class ```swiftimport Foundationimport UiKitpublic class CustomerCell:UITableViewCell{ override init(style: UITableViewCellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier); } //繼承UITableViewCell一定要override的function public required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder); }} 12345678910111213141516171819* 在storyboard指定該cell的class為CustomerCell,並且設定Identifier [![](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-ccc0-6L5vYk&#x2F;VPQCFF6QKwI&#x2F;AAAAAAAAEWY&#x2F;sOW8wxdPRSc&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%882.19.52.png)](http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-ccc0-6L5vYk&#x2F;VPQCFF6QKwI&#x2F;AAAAAAAAEWY&#x2F;sOW8wxdPRSc&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%882.19.52.png)[![](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-ZcUAw2yn9OU&#x2F;VPQCnODddHI&#x2F;AAAAAAAAEWg&#x2F;Xs5EhzwGDsI&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%882.25.39.png)](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-ZcUAw2yn9OU&#x2F;VPQCnODddHI&#x2F;AAAAAAAAEWg&#x2F;Xs5EhzwGDsI&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-03-02%2B%E4%B8%8B%E5%8D%882.25.39.png)* 把對應的控制項建立起關聯 &#96;&#96;&#96;swiftimport Foundationimport UiKitpublic class CustomerCell:UITableViewCell&#123; @IBOutlet weak var lblTitle: UILabel! &#x2F;&#x2F;title的label @IBOutlet weak var imgIcon: UIImageView! &#x2F;&#x2F;icon的小圖片 override init(style: UITableViewCellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier: reuseIdentifier); &#125; public required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder); &#125;&#125; 改寫cellForRowAtIndexPath這個事件 ```swift//每個row顯示的內容func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let identifier = “Customer_Cell”; var cell:CustomerCell? = uitable.dequeueReusableCellWithIdentifier(identifier) as? CustomerCell; if(cell == nil){cell = CustomerCell(style: UITableViewCellStyle.Default, reuseIdentifier: identifier); } //indexPath.row 可以知道目前是要製作第幾列的view cell?.lblTitle?.text = data[indexPath.row]; //依據是第幾個row決定icon的圖片 switch indexPath.row{case 0: cell?.imgIcon.image = UIImage(named: &quot;icon-factory&quot;); break; case 1: cell?.imgIcon.image = UIImage(named: &quot;icon-location&quot;); break; case 2: cell?.imgIcon.image = UIImage(named: &quot;icon-money&quot;); break; default: break; } return cell!;} ``` 最後呈現的結果","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[swift] 製作IOS Table (1)基本的Tabel語法","slug":"swift-製作IOS-Table-1-基本的Tabel語法","date":"2015-03-02T03:05:00.000Z","updated":"2022-08-09T13:36:17.083Z","comments":true,"path":"2015/03/02/swift-製作IOS-Table-1-基本的Tabel語法/","link":"","permalink":"https://toyo0103.github.io/2015/03/02/swift-%E8%A3%BD%E4%BD%9CIOS-Table-1-%E5%9F%BA%E6%9C%AC%E7%9A%84Tabel%E8%AA%9E%E6%B3%95/","excerpt":"","text":"首先必須讓Controller符合UITableViewDelegate , UITableViewDataSource的規範,並將table元件的delegate與datasource指定為自己這個controller 123456789101112131415class OptionViewController: UIViewController , UITableViewDelegate , UITableViewDataSource &#123; @IBOutlet weak var UIOptionTable: UITableView! var data : [String]!; //資料來源 override func viewDidLoad() &#123; super.viewDidLoad(); self.UIOptionTable.delegate = self; self.UIOptionTable.dataSource = self; data = []; data.append(&quot;便當&quot;); data.append(&quot;雞腿便當&quot;); data.append(&quot;排骨便當&quot;); &#125;&#125; 再來override幾個主要的事件 123456789101112131415161718192021222324//這個table包含幾個sectionfunc numberOfSectionsInTableView(tableView: UITableView!) -&gt; Int &#123; return 1&#125;//每個section有幾個rowfunc tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count;&#125;//每個row顯示的內容func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;cellid&quot;; var cell:UITableViewCell? = uitable.dequeueReusableCellWithIdentifier(identifier) as? UITableViewCell; if(cell == nil)&#123; cell = UITableViewCell(style: UITableViewCellStyle.Default, reuseIdentifier: identifier); &#125; //indexPath.row 可以知道目前是要製作第幾列的view cell?.textLabel?.text = data[indexPath.row]; return cell!;&#125; 結果～","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"}]},{"title":"[Xamarin] Xamarin的奇幻旅程","slug":"Xamarin-Xamarin的奇幻旅程","date":"2014-11-13T07:21:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2014/11/13/Xamarin-Xamarin的奇幻旅程/","link":"","permalink":"https://toyo0103.github.io/2014/11/13/Xamarin-Xamarin%E7%9A%84%E5%A5%87%E5%B9%BB%E6%97%85%E7%A8%8B/","excerpt":"","text":"最近因為公司需要,開始學習如何用Xamarin開發 IOS,雖然主打用C#開發APP,但無論生命週期跟呼叫的function跟傳統的windows forms或ASP MVC都有相當大的差異性,有很大的一段GAP要跨過就是. 這邊紀錄一下我開發**IOS**時遇到的問題跟心得 AppDelegate,程式的進入點 123456public override bool FinishedLaunching(UIApplication app, NSDictionary options)&#123; // 指定APP符合螢幕大小 UIWindow window = new UIWindow(UIScreen.MainScreen.Bounds); // 指定APP Root的View,這邊Config.MainStoryboard是我為了避免每次重複一直寫一樣的code // 所以把抓取Storyboard的程式碼整合到config,原本應該是UIStoryboard.FromName (&quot;MainStoryboard&quot;, null) window.RootViewController = Config.MainStoryboard.InstantiateInitialViewController () as UIViewController; // make the window visible window.MakeKeyAndVisible(); return true;&#125; Storyboard,編輯流程的地方,只要把對應的Controller抓進來並且命名,Xamarin Studio會將Class檔案自動建好 取得Storyboard裡面的ViewController方法 12UIStoryboard.FromName (&quot;MainStoryboard&quot;, null).InstantiateViewController (viewcontroller_name) as UIViewController; IOS頁面間的流程靠的是對NavigationController的操作,以下是針對NavigationController的一些設定```csharppublic override void ViewDidLoad (){ //edit control in viewdidload //NavigationBar的背景色 NavigationController.NavigationBar.BarTintColor = new UIColor(0.58f,0.761f,0.231f,1f); //字的顏色 NavigationController.NavigationBar.TitleTextAttributes = new UIStringAttributes (){ ForegroundColor = UIColor.White }; //NavigationBar Button的顏色 NavigationController.NavigationBar.TintColor = UIColor.White; //設定NavigationBar的右邊按鈕為何 UIBarButtonItem barOptionIcon = new UIBarButtonItem (UIImage.FromBundle (“icon-options”), UIBarButtonItemStyle.Plain, (sender, args) =&gt; { // button clicked NavigationController.PushViewController(Config.GetStoryboardViewController(“OptionViewController”),true); }); NavigationController.NavigationBar.TopItem.SetRightBarButtonItem (barOptionIcon,true); //OptionIcon} 1234567891011* IOS抓取對應圖片的方式[![](&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-yKVU6385RPk&#x2F;VGRo5f3lZII&#x2F;AAAAAAAAET0&#x2F;Kz-_aQWVyLA&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2014-11-13%2B%E4%B8%8B%E5%8D%884.15.59.png)](https:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-yKVU6385RPk&#x2F;VGRo5f3lZII&#x2F;AAAAAAAAET0&#x2F;Kz-_aQWVyLA&#x2F;s1600&#x2F;%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2014-11-13%2B%E4%B8%8B%E5%8D%884.15.59.png)&#96;&#96;&#96;csharp&#x2F;&#x2F;FromBundle的方式IOS會自動對應不同的裝置抓取預備好給他的圖&#x2F;&#x2F;圖片檔名命名方式&#x2F;&#x2F;[imageName]~iphone.png&#x2F;&#x2F;[imageName]~ipad.png&#x2F;&#x2F;[imageName]@2~ipad.png for retina顯示器UIImage.FromBundle (&quot;icon-options&quot;);&#x2F;&#x2F;FromFile不管任何解析度都是用這張來顯示,所以用前者的方式較佳UIImage.FromFile (&quot;icon-options.png&quot;); TableViewController的製作方式```csharp//製作TableSource的Classpublic class TableSource : UITableViewSource{ string cellIdentifier = “OptionsTableCell”; public List TABLE_ITEMS{ get; set;} //每列資料 public event EventHandler Cell_RowSelected;//給外層cell click事件 public TableSource () { TABLE_ITEMS = new List&lt;tablecell&gt; (); } public override nint RowsInSection (UITableView tableview, nint section) { return TABLE_ITEMS.Count; } public override UITableViewCell GetCell (UITableView tableView, Foundation.NSIndexPath indexPath) { UITableViewCell cell = tableView.DequeueReusableCell (cellIdentifier); //if there are no cells to reuse , cerate a new one if (cell == null) cell = new UITableViewCell (UITableViewCellStyle.Default, cellIdentifier); cell.TextLabel.Text = TABLE_ITEMS [indexPath.Row].TITLE; cell.TextLabel.Font = UIFont.SystemFontOfSize(15f); cell.TextLabel.TextColor = new UIColor (0.453f, 0.453f, 0.453f, 1); cell.ImageView.Image = UIImage.FromBundle (TABLE_ITEMS[indexPath.Row].IMAGE); //cell front Image cell.Accessory = UITableViewCellAccessory.DisclosureIndicator; return cell; } public override void RowSelected (UITableView tableView, Foundation.NSIndexPath indexPath) {//把值拋到OptionViewController的Cell_RowSelected的事件if (Cell_RowSelected != null) Cell_RowSelected(this,new TableRowSelectedEventArgs(){ indexPath = indexPath});tableView.DeselectRow (indexPath, true); //cancel select row style }} 12345678910111213141516171819202122232425262728293031323334353637383940&#96;&#96;&#96;csharp&#x2F;&#x2F;製作TableSource的Classpublic class TableSource : UITableViewSource&#123; string cellIdentifier &#x3D; &quot;OptionsTableCell&quot;; public List&lt;tablecell&gt; TABLE_ITEMS&#123; get; set;&#125; &#x2F;&#x2F;每列資料 public event EventHandler&lt;tablerowselectedeventargs&gt; Cell_RowSelected;&#x2F;&#x2F;給外層cell click事件 public TableSource () &#123; TABLE_ITEMS &#x3D; new List&lt;tablecell&gt; (); &#125; public override nint RowsInSection (UITableView tableview, nint section) &#123; return TABLE_ITEMS.Count; &#125; public override UITableViewCell GetCell (UITableView tableView, Foundation.NSIndexPath indexPath) &#123; UITableViewCell cell &#x3D; tableView.DequeueReusableCell (cellIdentifier); &#x2F;&#x2F;if there are no cells to reuse , cerate a new one if (cell &#x3D;&#x3D; null) cell &#x3D; new UITableViewCell (UITableViewCellStyle.Default, cellIdentifier); cell.TextLabel.Text &#x3D; TABLE_ITEMS [indexPath.Row].TITLE; cell.TextLabel.Font &#x3D; UIFont.SystemFontOfSize(15f); cell.TextLabel.TextColor &#x3D; new UIColor (0.453f, 0.453f, 0.453f, 1); cell.ImageView.Image &#x3D; UIImage.FromBundle (TABLE_ITEMS[indexPath.Row].IMAGE); &#x2F;&#x2F;cell front Image cell.Accessory &#x3D; UITableViewCellAccessory.DisclosureIndicator; return cell; &#125; public override void RowSelected (UITableView tableView, Foundation.NSIndexPath indexPath) &#123; &#x2F;&#x2F;把值拋到OptionViewController的Cell_RowSelected的事件 if (Cell_RowSelected !&#x3D; null) Cell_RowSelected(this,new TableRowSelectedEventArgs()&#123; indexPath &#x3D; indexPath&#125;); tableView.DeselectRow (indexPath, true); &#x2F;&#x2F;cancel select row style &#125;&#125; 12//Table Cell Classpublic class TableCell&#123; public string TITLE &#123; get; set; &#125; //標題 public string IMAGE &#123; get; set;&#125; //圖片 public TableCell () &#123; &#125; public TableCell (string title , string image) &#123; TITLE = title; IMAGE = image; &#125;&#125; 然後在ViewController這麼做 ```csharppublic OptionViewController (IntPtr handle) : base (handle){ _tableview = SetTable (); this.Add (_tableview); //把Table加進去View裡面}/// /// Set Table Data/// /// The table.private UITableView SetTable(){ UITableView tv = new UITableView (View.Bounds); TableSource _source = new TableSource (); List celllist = new List (); //將options的menu選項加進table cell裡面 foreach (Options item in Enum.GetValues(typeof(Options))) { string[] descript = Tools.GetEnumDescription (item).Split(new String[]{“;”}, StringSplitOptions.RemoveEmptyEntries); celllist.Add(new TableCell (descript[0], descript[1]));//標題;圖片 &#125; _source.TABLE_ITEMS = celllist; tv.Source = _source; //cell click觸發的事件 _source.Cell_RowSelected += (object sender, TableRowSelectedEventArgs e) =&amp;gt; &#123; switch ((Options)e.indexPath.Row) &#123; case Options.BuildAge:NavigationController.PushViewController(Config.GetStoryboardViewController(&quot;Options_BuildAgeViewController&quot;),true); break; &#125; }; return tv;} ```","categories":[],"tags":[{"name":"Xamarin","slug":"Xamarin","permalink":"https://toyo0103.github.io/tags/Xamarin/"}]},{"title":"【XML】將資料匯出到EXCEL - 透過ClosedXML套件","slug":"【XML】將資料匯出到EXCEL-透過ClosedXML套件","date":"2014-08-11T02:03:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2014/08/11/【XML】將資料匯出到EXCEL-透過ClosedXML套件/","link":"","permalink":"https://toyo0103.github.io/2014/08/11/%E3%80%90XML%E3%80%91%E5%B0%87%E8%B3%87%E6%96%99%E5%8C%AF%E5%87%BA%E5%88%B0EXCEL-%E9%80%8F%E9%81%8EClosedXML%E5%A5%97%E4%BB%B6/","excerpt":"","text":"最近有寫Excel報表的需求，ClosedXML真的是個不錯的套件 12345678910var workbook = new XLWorkbook(); //new Excel var sheet_A = workbook.Worksheets.Add(&quot;Sheet_A&quot;); //新增Sheet到 Excel //塞資料到Sheet中 worksheet.Cell(_index, 1).Value = &quot;欄位一&quot;; worksheet.Cell(_index, 2).Value = &quot;欄位二&quot;; worksheet.Cell(_index, 3).Value = &quot;欄位三&quot;; worksheet.Cell(_index, 4).Value = &quot;欄位四&quot;; worksheet.Cell(_index, 5).Value = &quot;欄位五&quot;; 用法還滿簡單的，如果有更深入的用法想瞭解也可以到ClosedXml網站看文件在使用的過程有遇到一個情況就是從DB裡面撈出大量的資料倒入Excel時，匯出打開檔案會顯示Excel已經損毀，可是直接把DB撈出來的資料用複製貼上卻可以完整地貼到Excel中，存檔再打開也不會壞掉。這個問題搞了好久…最後查到大陸網站得到以下的解答 1234567891011121314151617181920/// &lt;summary&gt;/// 提示??，??信息如下： 十六?制值 0x0B 是?效的字符??///?生原因是xml文件中包含低位非打印字符造成的///?理方法：在?生xml文件的?候，??低位非打印字符/// &lt;/summary&gt;/// &lt;param name=&quot;tmp&quot; /&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string ReplaceLowOrderASCIICharacters(string tmp)&#123; StringBuilder info = new StringBuilder(); foreach (char cc in tmp) &#123; int ss = (int)cc; if (((ss &gt;= 0) &amp;&amp; (ss &lt;= 8)) || ((ss &gt;= 11) &amp;&amp; (ss &lt;= 12)) || ((ss &gt;= 14) &amp;&amp; (ss &lt;= 32))) info.AppendFormat(&quot; &quot;, ss);//&amp;#x&#123;0:X&#125;; else info.Append(cc); &#125; return info.ToString();&#125; 把字元丟到這個function去過濾後就可以避免錯誤了!!","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Excel","slug":"Excel","permalink":"https://toyo0103.github.io/tags/Excel/"}]},{"title":"【.NET】防止XSS攻擊","slug":"【-NET】防止XSS攻擊","date":"2014-06-03T08:39:00.000Z","updated":"2022-08-09T13:36:17.084Z","comments":true,"path":"2014/06/03/【-NET】防止XSS攻擊/","link":"","permalink":"https://toyo0103.github.io/2014/06/03/%E3%80%90-NET%E3%80%91%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E6%93%8A/","excerpt":"","text":"一直都有聽過XSS攻擊的原理跟方式，但都沒有好好認真研究過，剛好最近看到一個小遊戲在這邊推薦給大家:瞭解XSS攻擊的小遊戲 查了一下.NET防止XSS攻擊的有效方法，剛好保哥有寫過相關的文章保哥-推薦使用 Microsoft Anti-Cross Site Scripting Library v3.1裡面介紹的非常詳細，這邊就不再多做贅述了。 唯一需要特別注意的地方是Anti-XSS Library在4.2版的時候將GetSafeHtml 、GetSafeHtmlFragment移到了新的DLL了。所以如果依照文章去下載這個DLL會發現沒有這兩個方法可用，請改用Nuget搜尋HtmlSanitizationLibrary [![](http://4.bp.blogspot.com/-El2JuoTjn70/U42JPHwLqqI/AAAAAAAAEOM/z99tk-Wb_AI/s1600/1.png)](http://4.bp.blogspot.com/-El2JuoTjn70/U42JPHwLqqI/AAAAAAAAEOM/z99tk-Wb_AI/s1600/1.png) 使用方法也變成 12Sanitizer.GetSafeHtmlFragment(inputext); 真是很好很強大阿!!!!","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【SQL】WAITFOR DELAY","slug":"【SQL】WAITFOR-DELAY","date":"2014-05-28T03:57:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2014/05/28/【SQL】WAITFOR-DELAY/","link":"","permalink":"https://toyo0103.github.io/2014/05/28/%E3%80%90SQL%E3%80%91WAITFOR-DELAY/","excerpt":"","text":"有時候大量資料批次匯入時，我們會用寫SQL語法的方式增加效率(LinqToSql會讓你慢到server timeout)，但常常發生SQL處理速度太快，造成datein的時間完全一樣，讓人分不清楚哪筆先哪筆後 這種先後順序在權限的處理上又異常的重要，畢竟權限通常都是拿最後一筆的時間再繼續往下疊加下去，如果分不出哪一筆應該是最後一筆可就慘了阿!!! SQL表示:今天的我沒有極限 [![](http://3.bp.blogspot.com/-yo13exV70Lw/U4VbOW1w9OI/AAAAAAAAEN8/hulc_I52GBk/s1600/1.png)](http://3.bp.blogspot.com/-yo13exV70Lw/U4VbOW1w9OI/AAAAAAAAEN8/hulc_I52GBk/s1600/1.png) 所以要在每一筆寫入的時候告訴SQL Server說，\"來，您辛苦了。休息個0.1秒再繼續吧!!\"這時候你就會需要WAITFOR DELAY語法了([MSDN解說](http://msdn.microsoft.com/zh-tw/library/ms187331.aspx)) ```sql --每insert一筆都呼叫一次 WAITFOR DELAY '00:00:00.010' ```打完收工","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【SQL】SQL的foreach，逐筆執行","slug":"【SQL】SQL的foreach，逐筆執行","date":"2014-03-13T09:17:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2014/03/13/【SQL】SQL的foreach，逐筆執行/","link":"","permalink":"https://toyo0103.github.io/2014/03/13/%E3%80%90SQL%E3%80%91SQL%E7%9A%84foreach%EF%BC%8C%E9%80%90%E7%AD%86%E5%9F%B7%E8%A1%8C/","excerpt":"","text":"需求:將Table_A的資料塞到Table_B，並把Table_B產生的ID編號回寫回Table_A的對應欄位 ```sql– 宣告變數DECLARE @para1 VARCHAR(50)DECLARE @para2 uniqueidentifierDECLARE @para3 VARCHAR(100) – 宣告指標變數DECLARE _cursor CURSOR FORSELECT s1,s2,s3 FROM Table_A where eiplstatus = 1 – 啟用指標變數OPEN _cursor– 以指標變數為基準點, 將取出的欄位值,依序塞給我們自訂的變數，亦即將每筆s1 =&gt; @para1、 s2 =&gt; @para2 、s3 =&gt; @para3FETCH NEXT FROM _cursor INTO @para1,@para2,@para3 WHILE @@FETCH_STATUS = 0BEGIN insert into Table_B(c1,c2,c3) values(@para1,@para2,@para3) SET @id = SCOPE_IDENTITY(); update Table_A set id = @id where CURRENT of _cursor -- 指標變數往下移動, 並將取出的欄位值, 設定給我們自訂的變數 FETCH NEXT FROM _cursor INTO @para1,@para2,@para3 END – 關閉指標變數CLOSE _cursor– 釋放指標變數DEALLOCATE _cursor","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【心情】世殊事異","slug":"【心情】世殊事異","date":"2013-12-09T09:02:00.000Z","updated":"2022-08-09T13:36:17.096Z","comments":true,"path":"2013/12/09/【心情】世殊事異/","link":"","permalink":"https://toyo0103.github.io/2013/12/09/%E3%80%90%E5%BF%83%E6%83%85%E3%80%91%E4%B8%96%E6%AE%8A%E4%BA%8B%E7%95%B0/","excerpt":"","text":"[![](http://4.bp.blogspot.com/-O5EO2Xn1EKo/UqWGOc7xaRI/AAAAAAAAEM0/dPda1T6sNAI/s400/IMG_0440.JPG)](http://4.bp.blogspot.com/-O5EO2Xn1EKo/UqWGOc7xaRI/AAAAAAAAEM0/dPda1T6sNAI/s1600/IMG_0440.JPG) 最近心情持續低氣壓，想在FB上抒發一下心情卻又礙於人多口雜。希望能在這找到屬於自己的另一個僻靜小天地 剛剛看到有人用CSS畫出幾個下雨的樣式，正好也符合自己的心境就來跟部落格整合一下好了。 [下雨CSS請參考](http://www.blogger.com/blogger.g?blogID=6692337573339064262) html 1234&lt;div class=&quot;body&quot;&gt;&lt;section class=&quot;rain&quot;&gt;&lt;/section&gt;&lt;/div&gt; javascript 123456789101112131415161718192021222324// number of drops created.var nbDrop = 858; // function to generate a random number range.function randRange( minNum, maxNum) &#123; return (Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum);&#125;// function to generate dropsfunction createRain() &#123; for( i=1;i &lt; nbDrop;i++) &#123; var dropLeft = randRange(0,1600); var dropTop = randRange(-1000,1400); $(&#x27;.rain&#x27;).append(&#x27;&lt;div class=&quot;drop&quot; id=&quot;drop&#x27;+i+&#x27;&quot;&gt;&lt;/div&gt;&#x27;); $(&#x27;#drop&#x27;+i).css(&#x27;left&#x27;,dropLeft); $(&#x27;#drop&#x27;+i).css(&#x27;top&#x27;,dropTop); &#125;&#125;// Make it raincreateRain(); css 1234567891011121314151617181920212223242526div.body &#123; background:#0D343A; background:-webkit-gradient(linear,0% 0%,0% 100%, from(rgba(13,52,58,1) ), to(#000000) ); background: -moz-linear-gradient(top, rgba(13,52,58,1) 0%, rgba(0,0,0,1) 100%); overflow:hidden;&#125; .drop &#123; background:-webkit-gradient(linear,0% 0%,0% 100%, from(rgba(13,52,58,1) ), to(rgba(255,255,255,0.6)) ); background: -moz-linear-gradient(top, rgba(13,52,58,1) 0%, rgba(255,255,255,.6) 100%); width:1px; height:89px; position: absolute; bottom:200px; -webkit-animation: fall .63s linear infinite; -moz-animation: fall .63s linear infinite; &#125; /* animate the drops*/ @-webkit-keyframes fall &#123; to &#123;margin-top:900px;&#125; &#125; @-moz-keyframes fall &#123; to &#123;margin-top:900px;&#125; &#125; [雨滴請參考](http://codepen.io/lbebber/full/uIiJp) div.body { background:#0D343A; background:-webkit-gradient(linear,0% 0%,0% 100%, from(rgba(13,52,58,1) ), to(#000000) ); background: -moz-linear-gradient(top, rgba(13,52,58,1) 0%, rgba(0,0,0,1) 100%); overflow:hidden;} .drop { background:-webkit-gradient(linear,0% 0%,0% 100%, from(rgba(13,52,58,1) ), to(rgba(255,255,255,0.6)) ); background: -moz-linear-gradient(top, rgba(13,52,58,1) 0%, rgba(255,255,255,.6) 100%); width:1px; height:89px; position: absolute; bottom:200px; -webkit-animation: fall .63s linear infinite; -moz-animation: fall .63s linear infinite; } /* animate the drops*/ @-webkit-keyframes fall { to {margin-top:900px;} } @-moz-keyframes fall { to {margin-top:900px;} } //","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://toyo0103.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://toyo0103.github.io/tags/HTML/"}]},{"title":"【C#】如何在Server Side執行phantomjs對網頁進行快照","slug":"【C-】如何在Server-Side執行phantomjs對網頁進行快照","date":"2013-12-06T16:57:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2013/12/07/【C-】如何在Server-Side執行phantomjs對網頁進行快照/","link":"","permalink":"https://toyo0103.github.io/2013/12/07/%E3%80%90C-%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8Server-Side%E5%9F%B7%E8%A1%8Cphantomjs%E5%B0%8D%E7%B6%B2%E9%A0%81%E9%80%B2%E8%A1%8C%E5%BF%AB%E7%85%A7/","excerpt":"","text":"phantomjs如何使用，詳細請參考參考黑暗執行緒前輩的文章 首先寫了一支snapshot.js放到phantomjs的根目錄 123456789101112131415var page = require(&#x27;webpage&#x27;).create(),system = require(&#x27;system&#x27;),edmid,address;address = system.args[1];edmid = system.args[2];path = system.args[3];page.open(address,function(status)&#123; page.render(path + &#x27;/&#x27; + edmid+&#x27;.png&#x27;); phantom.exit();&#125;); 這支JS需要傳遞三個參數，1.網址 2.圖片的名稱 3.拍好的圖片存的路徑在cmd的執行方式如下 這次的功能是要在網站上按下一個按鈕後就對特定的網頁進行快照，程式如下 1234567891011121314151617181920212223242526//phantomjs在伺服器上的根目錄資料夾 string path = HostingEnvironment.MapPath(@&quot;~/phantomjs&quot;); //因為拍照可能需要數秒的時間，避免網頁被hand住所以切出執行緒來進行。故抓MapPath的方式需要改成 HostingEnvironment.MapPath //這裡是我把拍好的圖片放到哪個資料夾的路徑 string snapshotPath = HostingEnvironment.MapPath(&quot;~/phantomjs/snapshot&quot;); //透過Process這個類別來對cmd操作 using (System.Diagnostics.Process exep = new System.Diagnostics.Process()) &#123; System.Diagnostics.Process p = new System.Diagnostics.Process(); p.StartInfo.FileName = @&quot;C:\\Windows\\System32\\cmd.exe&quot;; p.StartInfo.RedirectStandardOutput = true; p.StartInfo.RedirectStandardInput = true; p.StartInfo.UseShellExecute = false; p.Start(); //StandardInput的資訊流指定給StreamWriter ，這樣只要透過StreamWriter寫指令就等於對cmd下command了 StreamWriter sw = p.StandardInput; sw.WriteLine(@&quot;cd\\&quot;); sw.WriteLine(string.Format(@&quot;&#123;0&#125;:&quot;, path.Substring(0, 1))); sw.WriteLine(@&quot;cd &quot; + path); sw.WriteLine(string.Format(@&quot;phantomjs snapshot.js &#123;0&#125; &#123;1&#125; &#123;2&#125;&quot;, 網址, 圖片名稱, snapshotPath )); sw.Close(); p.WaitForExit(); &#125; 重點在於只要自己透過cmd操作過phantomjs.exe來拍照，依樣畫葫蘆的透過Process逐步的下指令就可以達成了!! 另外phantomjs是將要被拍照的DOM元件抓下來在進行組合拍照，有了這個特性你就可以對想拍照的網站進行一些修改。例如載入JQuery把某個區塊移除之類的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Wait until the test condition is true or a timeout occurs. Useful for waiting * on a server response or for a ui change (fadeIn, etc.) to occur. * * @param testFx javascript condition that evaluates to a boolean, * it can be passed in as a string (e.g.: &quot;1 == 1&quot; or &quot;$(&#x27;#bar&#x27;).is(&#x27;:visible&#x27;)&quot; or * as a callback function. * @param onReady what to do when testFx condition is fulfilled, * it can be passed in as a string (e.g.: &quot;1 == 1&quot; or &quot;$(&#x27;#bar&#x27;).is(&#x27;:visible&#x27;)&quot; or * as a callback function. * @param timeOutMillis the max amount of time to wait. If not specified, 3 sec is used. */function waitFor(testFx, onReady, timeOutMillis) &#123; var maxtimeOutMillis = timeOutMillis ? timeOutMillis : 3000, //&lt; Default Max Timout is 3s start = new Date().getTime(), condition = false, interval = setInterval(function() &#123; if ( (new Date().getTime() - start &lt; maxtimeOutMillis) &amp;&amp; !condition ) &#123; // If not time-out yet and condition not yet fulfilled condition = (typeof(testFx) === &quot;string&quot; ? eval(testFx) : testFx()); //&lt; defensive code &#125; else &#123; if(!condition) &#123; // If condition still not fulfilled (timeout but condition is &#x27;false&#x27;) console.log(&quot;&#x27;waitFor()&#x27; timeout&quot;); phantom.exit(1); &#125; else &#123; // Condition fulfilled (timeout and/or condition is &#x27;true&#x27;) console.log(&quot;&#x27;waitFor()&#x27; finished in &quot; + (new Date().getTime() - start) + &quot;ms.&quot;); typeof(onReady) === &quot;string&quot; ? eval(onReady) : onReady(); //&lt; Do what it&#x27;s supposed to do once the condition is fulfilled clearInterval(interval); //&lt; Stop this interval &#125; &#125; &#125;, 250); //&lt; repeat check every 250ms&#125;;var page = require(&#x27;webpage&#x27;).create(),system = require(&#x27;system&#x27;),edmid,address;edmid = system.args[1];address = &#x27;http://xxx.com.tw/&#x27;+ edmid;// Open Twitter on &#x27;sencha&#x27; profile and, onPageLoad, do...page.open(address, function (status) &#123; // Check for page load success if (status !== &quot;success&quot;) &#123; console.log(&quot;Unable to access network&quot;); &#125; else &#123; // Wait for &#x27;signin-dropdown&#x27; to be visible waitFor(function() &#123; // Check in the page if a specific element is now visible return page.evaluate(function() &#123; return ($(&quot;body&quot;).prop(&quot;class&quot;) == &quot;allready&quot; ); //return $(&quot;#signin-dropdown&quot;).is(&quot;:visible&quot;); &#125;); &#125;, function() &#123; console.log(&quot;body allready now.&quot;); page.render(&#x27;D:\\\\test\\\\&#x27;+edmid+&#x27;.png&#x27;); phantom.exit(); &#125;); &#125;&#125;);","categories":[],"tags":[]},{"title":"【C#】取得dynamic的屬性","slug":"【C-】取得dynamic的屬性","date":"2013-11-20T07:30:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2013/11/20/【C-】取得dynamic的屬性/","link":"","permalink":"https://toyo0103.github.io/2013/11/20/%E3%80%90C-%E3%80%91%E5%8F%96%E5%BE%97dynamic%E7%9A%84%E5%B1%AC%E6%80%A7/","excerpt":"","text":"解析Json格式時取得dynamic型別的物件，但如果裡面的物件不是用陣列的方式回傳，而是像這樣我們不會知道.links底下究竟會link0、link1、link2….到幾，所以需要一個方法去try這個屬性是否存在 123456789101112131415private object GetDynamicMember(object obj, string memberName)&#123; try &#123; var binder = Binder.GetMember(CSharpBinderFlags.None, memberName, obj.GetType(), new[] &#123; CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) &#125;); var callsite = CallSite&lt;Func&lt;CallSite, object, object&gt;&gt;.Create(binder); return callsite.Target(callsite, obj); &#125; catch (Exception ex) &#123; return null; &#125; &#125; 透過這個方法，我們就可以試著將屬性丟進去看看有無回傳值了 ```csharpint i = 0;while (true){ dynamic trylink = GetDynamicMember(jsondata.links, “link” + i); if (trylink != null) { _urlclickcount += Convert.ToInt32(trylink.clicks); i++; } else break;}","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【C#】Server端透過POST資料到API","slug":"【C-】Server端透過POST資料到API","date":"2013-10-09T03:58:00.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2013/10/09/【C-】Server端透過POST資料到API/","link":"","permalink":"https://toyo0103.github.io/2013/10/09/%E3%80%90C-%E3%80%91Server%E7%AB%AF%E9%80%8F%E9%81%8EPOST%E8%B3%87%E6%96%99%E5%88%B0API/","excerpt":"","text":"之前POST資料都是在Client端無論是用JQuery的AJAX或是Form的方式，今天學會如何從Server端POST資料到指定的頁面，記錄一下程式碼 123456789101112131415161718//Post資料到WebHttpWebRequest request = (HttpWebRequest)WebRequest.Create(WebURL);request.Method = &quot;POST&quot;;request.ContentType = &quot;application/x-www-form-urlencoded&quot;;//將要傳遞的資料PostData轉成Byte陣列並寫入requestbyte[] byWordWriteroPost = encoding.GetBytes(PostData);request.ContentLength = byWordWriteroPost.Length;Stream stream = request.GetRequestStream();stream.Write(byWordWriteroPost, 0, byWordWriteroPost.Length);stream.Close();//取得網頁結果HttpWebResponse response = (HttpWebResponse)request.GetResponse();StreamReader reader = new StreamReader(response.GetResponseStream(), encoding);string returnString = reader.ReadToEnd();response.Close();","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【WebConfig】擴充WebConfig","slug":"【WebConfig】擴充WebConfig","date":"2013-10-01T06:34:00.000Z","updated":"2022-08-09T13:36:17.095Z","comments":true,"path":"2013/10/01/【WebConfig】擴充WebConfig/","link":"","permalink":"https://toyo0103.github.io/2013/10/01/%E3%80%90WebConfig%E3%80%91%E6%93%B4%E5%85%85WebConfig/","excerpt":"","text":"做專案時常常會有測試機與正式機的區別，又兩者要呼叫的API常常也有正式與測試的區別。如果將網址寫死在Code裡，將造成佈署測試機時compile一次，佈署到正式機又要打開code改好網址後再compile一次，不僅耗時又容易出錯。 所以大部分有這種情況時會將網址參數寫在WebConfig裡，這樣只要到兩台機器去修改參數網址即可，避免了一再compile的問題。 12345&lt;appSettings&gt; &lt;add key=&quot;APIUrlTest&quot; value=&quot;TestAPI.com.tw&quot; /&gt; &lt;add key=&quot;APIUrl&quot; value=&quot;xxx.com.tw&quot; /&gt;&lt;/appSettings&gt; 但可能會有很多類似這種參數會寫在Config裡，網址、時間、變數…琳瑯滿目，寫到最後連RD自己也搞得亂七八糟，所以就會寫要將同類型的參數歸類整理一翻。接下來Demo如何將WebConfig隔離與整理。 首先先在專案中新增一個新的Config檔，就暫且命名為i.config 在這個i.config中寫下新的區段(這邊我創了一個新的區塊叫iconfig) 接著到Web.Config註冊這個區段 * 在configSections中註冊[![](http://4.bp.blogspot.com/-Fgx71lYcBws/UkprtA0ViaI/AAAAAAAAELY/07Mhjt5ygQ4/s1600/1.png)](http://4.bp.blogspot.com/-Fgx71lYcBws/UkprtA0ViaI/AAAAAAAAELY/07Mhjt5ygQ4/s1600/1.png) 在appSettings區段下面註冊 在code裡面抓取i.config參數值得方法 ```csharppublic class iconfig{ private static System.Collections.Hashtable iConfig = (System.Collections.Hashtable)System.Configuration.ConfigurationManager.GetSection(“iconfig”); public static string ReservationApi { get { return (string)iConfig[“ReservationApi”]; } }} ```依照上述方法就可以將很多不同類型的參數分門別類的整理起來了!!!","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"},{"name":"webconfig","slug":"webconfig","permalink":"https://toyo0103.github.io/tags/webconfig/"},{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"}]},{"title":"【MVC】呼叫ELMAH(艾爾瑪)","slug":"【MVC】呼叫ELMAH-艾爾瑪","date":"2013-09-10T05:54:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2013/09/10/【MVC】呼叫ELMAH-艾爾瑪/","link":"","permalink":"https://toyo0103.github.io/2013/09/10/%E3%80%90MVC%E3%80%91%E5%91%BC%E5%8F%ABELMAH-%E8%89%BE%E7%88%BE%E7%91%AA/","excerpt":"","text":"首先透過NuGet安裝以下四個套件 打開WebConfig可以找到以下設定 ```xml //是否需要權限才能閱讀這個Log，當然是True啦!! //是否停用原本預設調用Log的\"網址/elmah\"路徑 //如果權限設定為true的話，何種role可以調用Log //那些登入者可以調用Log 多人時用逗號分開 //設定調用Elmah Log的MVC Route 1234563. 刪除掉WebConfig的以下區段，所有人都不法透過&quot;網址&#x2F;elmah.axd&quot;來讀取Log檔案(包含本機) &#96;&#96;&#96;xml&lt;location path&#x3D;&quot;elmah.axd&quot; inheritInChildApplications&#x3D;&quot;false&quot;&gt;...略...&lt;&#x2F;location&gt; ELMAH還有很多不錯的功能，例如將錯誤Log寫到DB裡面去，或是主動寄信通知設定。但目前還用不上就先不研究了!!5. 實際上看到Log的紀錄 按下Detail後的詳細資訊，說實在還滿棒的~","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【MVC】MVC上傳圖片","slug":"【MVC】MVC上傳圖片","date":"2013-09-09T09:39:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2013/09/09/【MVC】MVC上傳圖片/","link":"","permalink":"https://toyo0103.github.io/2013/09/09/%E3%80%90MVC%E3%80%91MVC%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87/","excerpt":"","text":"View ```csharp@using (Html.BeginForm(“edit”, “group”, FormMethod.Post, new { enctype = “multipart/form-data” })){ 圖片 } 1234567891011121314152. Controller，這邊特別注意&lt;span style&#x3D;&quot;color: blue;&quot;&gt;HttpPostedFileBase&lt;&#x2F;span&gt; picture的參數名稱要與View file的name相同 &#96;&#96;&#96;csharppublic ActionResult AddExhibitionItem(string name, string sort,string stop ,HttpPostedFileBase picture)&#123; string err&#x3D; string.Empty; if (ExhibitionUtilFactory.AddItem(name, sort, stop, picture, ref err)) &#123; return Content(&quot;&lt;script&gt;alert(&#39;新增成功&#39;);window.parent.closeDialog();&lt;&#x2F;script&gt;&quot;); &#125; else &#123; TempData[&quot;alert&quot;] &#x3D; err; return View(); &#125;&#125; 如果是多檔上傳的話，View ```csharp 圖片 1234567894. Controller &#96;&#96;&#96;csharppublic ActionResult AddExhibitionItem(string name, string sort,string stop ,IEnumerable&lt;HttpPostedFileBase&gt; picture)&#123; foreach (var file in picture) &#123; ............ &#125;&#125;","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【LINQ TO SQL】解決SubmitChanges時與資料庫衝突的問題","slug":"【LINQ-TO-SQL】解決SubmitChanges時與資料庫衝突的問題","date":"2013-09-06T02:39:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2013/09/06/【LINQ-TO-SQL】解決SubmitChanges時與資料庫衝突的問題/","link":"","permalink":"https://toyo0103.github.io/2013/09/06/%E3%80%90LINQ-TO-SQL%E3%80%91%E8%A7%A3%E6%B1%BASubmitChanges%E6%99%82%E8%88%87%E8%B3%87%E6%96%99%E5%BA%AB%E8%A1%9D%E7%AA%81%E7%9A%84%E5%95%8F%E9%A1%8C/","excerpt":"","text":"一樣參考保哥的解決 LINQ to SQL 資料庫更新衝突的情形與公司前輩的Source Code 發生原因：有可能我們在跟DB取得某個欄位時得到A這個值，但當我們改動這個值並嘗試更新回DB時，可能DB早就被其他使用者改成B了。DBContext SubmitChanges會去比對這個欄位最初值是否與DB目前的值一致避免Dirty Data的問題，但當上述情況發生時則會擲出Exception。各種處理方式如下:```csharptry{ _dbContext.SubmitChanges(System.Data.Linq.ConflictMode.ContinueOnConflict);}catch (System.Data.Linq.ChangeConflictException ex){ foreach (System.Data.Linq.ObjectChangeConflict occ in _dbContext.ChangeConflicts) { // 採用資料庫的查詢出來的值，目前物件的值將會被資料庫最新查到的複寫 //occ.Resolve(System.Data.Linq.RefreshMode.OverwriteCurrentValues); // 採用目前物件中的值，並更新資料庫中的版本 //occ.Resolve(System.Data.Linq.RefreshMode.KeepCurrentValues); // 僅更新此物件中變更的欄位，僅將變更的欄位寫入資料庫（或稱為合併更新） occ.Resolve(System.Data.Linq.RefreshMode.KeepChanges); } // 注意：解決完衝突之後要記得重新再 SubmitChanges() 一次，否則一樣不會更新資料庫 _dbContext.SubmitChanges();}","categories":[],"tags":[{"name":"LINQ TO SQL","slug":"LINQ-TO-SQL","permalink":"https://toyo0103.github.io/tags/LINQ-TO-SQL/"}]},{"title":"【SQL】SQL 2008R2 開啟SA帳號","slug":"【SQL】SQL-2008R2-開啟SA帳號","date":"2013-09-03T01:57:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2013/09/03/【SQL】SQL-2008R2-開啟SA帳號/","link":"","permalink":"https://toyo0103.github.io/2013/09/03/%E3%80%90SQL%E3%80%91SQL-2008R2-%E9%96%8B%E5%95%9FSA%E5%B8%B3%E8%99%9F/","excerpt":"","text":"這個東西做了八百萬遍了還是常常忘記在哪設定，所以決定寫起來方必查詢(汗)* 首先，SQL Server上右鍵 &gt; 屬性 &gt; 安全性 &gt; 選擇SQL Server及Windows驗證模式 安全性 &gt; 登入 &gt; SA帳戶 &gt; 屬性狀態 &gt; 登入 &gt; 啟用 重新啟動SQL服務","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【C#】FormsAuthentication驗證模式","slug":"【C-】FormsAuthentication驗證模式","date":"2013-09-01T09:04:04.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2013/09/01/【C-】FormsAuthentication驗證模式/","link":"","permalink":"https://toyo0103.github.io/2013/09/01/%E3%80%90C-%E3%80%91FormsAuthentication%E9%A9%97%E8%AD%89%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"研究了老半天終於搞懂了，來做一下簡單的筆記從.NET 2.0開始就已經開始實行的Form驗證模式，今天拜讀了保哥的「概略解釋 Forms Authentication 的運作」後測試的簡單心得 使用這個方法即表示驗證成功，這個驗證會記錄在電腦的cookie當中 1FormsAuthentication.RedirectFromLoginPage(strUsername, false); 但如果你想要關閉瀏覽器時就登出，你就得改用以下方式將cookie記錄在web browser當中 12345678//改發Ticket的方式FormsAuthenticationTicket ticket = new FormsAuthenticationTicket(1, username, DateTime.Now, DateTime.Now.AddMinutes(30),false, userdata, FormsAuthentication.FormsCookiePath);// Encrypt the ticket.string encTicket = FormsAuthentication.Encrypt(ticket);// Create the cookie.Response.Cookies.Add(new HttpCookie(FormsAuthentication.FormsCookieName, encTicket)); 那如果又要實作，記住我xx天不用重新登入的功能呢? 123456789//除了剛剛發Ticket之外if (bool.Parse(remember))&#123; //如果打勾記住我的話 HttpCookie cookie = new HttpCookie(&quot;rememberme&quot;); cookie.Value = SysHelper.enCrypt(account); cookie.Expires = DateTime.Now.AddDays(3); Response.Cookies.Add(cookie);&#125; 這樣下次登入的時候只要判斷這個cookie存不存在就可以放行了!! 12345678910111213//登入Login頁面時，先判斷Form驗證已經通過了嗎?if (!User.Identity.IsAuthenticated)&#123; //沒通過的話，判斷cookie存不存在。有的話表示此人上次登入時有勾記住我!! if ( Request.Cookies[&quot;backend&quot;] != null) &#123; //cookie如果過期的話會判斷為null，所以進得來表示cookie還沒過期，可以發Ticket給他 passTicket(SysHelper.deCrypt(Request.Cookies[&quot;rememberme&quot;].Value), &quot;&quot;); return Redirect(&quot;/backend&quot;); &#125; return View();&#125; 登出 1234567891011//呼叫這個方法就已經登出摟~FormsAuthentication.SignOut(); if (Request.Cookies[&quot;backend&quot;] != null)&#123; //如果cookie還沒過期，既然已經登出當然要把它重新設定為過期啦!! HttpCookie myCookie = new HttpCookie(&quot;backend&quot;); myCookie.Expires = DateTime.Now.AddDays(-1d); Response.Cookies.Add(myCookie);&#125;return Redirect(&quot;/backend&quot;); 最後不要搞混Response與Request了。我寫的時候沒注意到害我Debug超久的….(汗)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"FormsAuthentication","slug":"FormsAuthentication","permalink":"https://toyo0103.github.io/tags/FormsAuthentication/"}]},{"title":"【MVC】PartialView傳值導致ViewBag的值變為null","slug":"【MVC】PartialView傳值導致ViewBag的值變為null","date":"2013-08-26T09:39:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2013/08/26/【MVC】PartialView傳值導致ViewBag的值變為null/","link":"","permalink":"https://toyo0103.github.io/2013/08/26/%E3%80%90MVC%E3%80%91PartialView%E5%82%B3%E5%80%BC%E5%B0%8E%E8%87%B4ViewBag%E7%9A%84%E5%80%BC%E8%AE%8A%E7%82%BAnull/","excerpt":"","text":"如果在呼叫PartialView時用以下傳值方式 ```csharp//透過第三個參數用ViewDataDictionary的方式傳遞參數，會導致之前存的ViewBag的值在PartialView裡面變成Null讀不到@Html.Partial(“_at_article_endlink”, linklist,new ViewDataDictionary { { “linktitle”, Model.LINKTITLE } }) 12345* 最後改良的方式變成在外面先存成ViewBag的值，接下來PartialView裡面就一切正常了 &#96;&#96;&#96;csharp@&#123;ViewBag.linktitle &#x3D; na.LINKTITLE;&#125;@Html.Partial(&quot;_at_article_endlink&quot;, linklist)","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【JavaScript】驗證上傳的附檔名","slug":"【JavaScript】驗證上傳的附檔名","date":"2013-07-14T04:27:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2013/07/14/【JavaScript】驗證上傳的附檔名/","link":"","permalink":"https://toyo0103.github.io/2013/07/14/%E3%80%90JavaScript%E3%80%91%E9%A9%97%E8%AD%89%E4%B8%8A%E5%82%B3%E7%9A%84%E9%99%84%E6%AA%94%E5%90%8D/","excerpt":"","text":"1234567891011$(&#x27;input[type=&quot;file&quot;]&#x27;).on(&#x27;change&#x27;, function () &#123; var file = $(this).val(); if (!file.match(/^([0-9a-zA-Z_\\-~ :\\\\])+(.jpg|.JPG|.jpeg|.JPEG|.bmp|.BMP|.gif|.GIF|.png|.PNG)$/)) &#123; alert(&#x27;只允許上傳圖檔&#x27;); var control = $(this); //如果上傳的檔案格式不符合，將該Control換成新的 control.replaceWith(control = control.clone(true)); &#125;&#125;);","categories":[],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://toyo0103.github.io/tags/JQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://toyo0103.github.io/tags/JavaScript/"}]},{"title":"GridView 加入空白行","slug":"GridView-加入空白行","date":"2013-07-11T03:20:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2013/07/11/GridView-加入空白行/","link":"","permalink":"https://toyo0103.github.io/2013/07/11/GridView-%E5%8A%A0%E5%85%A5%E7%A9%BA%E7%99%BD%E8%A1%8C/","excerpt":"","text":"Function如下 ```vb‘’’ ‘’’’’’ ‘’’ 要新增空白行的GridView‘’’ 要加入幾行‘’’ Public Shared Sub GridView_AddEmptyRow(gv As GridView, count As Integer) Dim dt As DataTable = New DataTable() Dim dr As DataRow For i = 0 To gv.Columns.Count - 1 Step 1 dt.Columns.Add(New DataColumn(gv.Columns(i).HeaderText, System.Type.GetType(&quot;System.String&quot;))) Next For i = 1 To count Step 1 dr = dt.NewRow() For x = 0 To gv.Columns.Count - 1 Step 1 dr(gv.Columns(x).HeaderText) = String.Empty Next dt.Rows.Add(dr) Next gv.DataSource = dt gv.DataBind()End Sub","categories":[],"tags":[{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"},{"name":"GridView","slug":"GridView","permalink":"https://toyo0103.github.io/tags/GridView/"}]},{"title":"【ASP】 動態新增GridView的 TemplateField欄位","slug":"【ASP】-動態新增GridView的-TemplateField欄位","date":"2013-06-13T09:27:10.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2013/06/13/【ASP】-動態新增GridView的-TemplateField欄位/","link":"","permalink":"https://toyo0103.github.io/2013/06/13/%E3%80%90ASP%E3%80%91-%E5%8B%95%E6%85%8B%E6%96%B0%E5%A2%9EGridView%E7%9A%84-TemplateField%E6%AC%84%E4%BD%8D/","excerpt":"","text":"因為某些搜尋條件的不同，造成要顯示的欄位可能也略有差異，一般可以透過多個GridView隱藏來隱藏去的方法，或是動態將某些Column隱藏起來，今天試的方法是在搜尋完後DataBind之前先將GridView的欄位換成自己想要的，新增一般BoundField沒什麼太特別的，但TemplateField就卡關了….參考很多資料後來做個筆記!!! 先將該準備的類別與方法準備好1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&#x27;&#x27;&#x27; &lt;summary&gt; &#x27;&#x27;&#x27; 複製控制項 &#x27;&#x27;&#x27; &lt;/summary&gt; &#x27;&#x27;&#x27; &lt;param name=&quot;taget&quot;&gt;&lt;/param&gt; &#x27;&#x27;&#x27; &lt;param name=&quot;source&quot;&gt;&lt;/param&gt; &#x27;&#x27;&#x27; &lt;returns&gt;&lt;/returns&gt; &#x27;&#x27;&#x27; &lt;remarks&gt;&lt;/remarks&gt; Public Shared Function Clone(ByVal taget As Object, ByVal source As Object) As Object For Each p As System.Reflection.PropertyInfo In source.GetType().GetProperties() If p.CanRead AndAlso p.CanWrite Then p.SetValue(taget, p.GetValue(source, p.GetIndexParameters()), p.GetIndexParameters()) End If Next Return taget End Function &#x27;新增一個類別實作ITemplate介面，就會跑出InstantiateIn的方法Public Class gvTemplate Implements ITemplate Private Property templateType As DataControlRowType Private Property columnName As String Private Property Control As Object Public Sub New(type As DataControlRowType, colname As String, ctrl As Object) templateType = type columnName = colname Control = ctrl End Sub Public Sub InstantiateIn(container As Control) Implements ITemplate.InstantiateIn Select Case templateType Case DataControlRowType.Header If Control Is Nothing Then &#x27;如果沒有沒有控制項，則塞入粗體字 Dim lt As Literal = New Literal() lt.Text = &quot;&lt;B&gt;&quot; + columnName + &quot;&lt;/B&gt;&quot; container.Controls.Add(lt) ElseIf TypeOf Control Is CheckBox Then &#x27;否則塞入控制項 container.Controls.Add(Control) End If Case DataControlRowType.DataRow Dim obj As Object If Not Control Is Nothing Then Select Case Control.GetType().Name Case &quot;CheckBox&quot; obj = New CheckBox() &#x27;如果有傳入WebControl的話，複製一個新的並把它加到DataRow中 &#x27;如果沒這麼做就直接將傳入的Control加入Container當中 &#x27;會變成只有最後一行有那個Control(Control為Reference型別) SysHelper.Clone(obj, Control) End Select obj = SysHelper.Clone(obj, Control) Else obj = New Label() AddHandler CType(obj, Label).DataBinding, AddressOf data_DataBinding End If container.Controls.Add(obj) End Select End Sub Private Sub data_DataBinding(sender As Object, e As EventArgs) Dim lbl As Label = CType(sender, Label) Dim row As GridViewRow = CType(lbl.NamingContainer, GridViewRow) lbl.Text = DataBinder.Eval(row.DataItem, columnName).ToString() End Sub End Class 使用方法如下12345678910111213141516171819202122232425Private Sub setGridViewColumns(ByVal mode As GriviewMode) gvSummons.Columns.Clear() &#x27;新增TemplateField的方法 Dim TemplateField As TemplateField = New TemplateField() TemplateField.ItemStyle.HorizontalAlign = HorizontalAlign.Center Dim cb As CheckBox = New CheckBox() cb.ID = &quot;cbSelectAll&quot; cb.Text = &quot;註記&quot; cb.CssClass = &quot;gvSummonsSelectAll&quot; TemplateField.HeaderTemplate = New SysHelper.gvTemplate(DataControlRowType.Header, &quot;&quot;, cb) cb = New CheckBox() cb.ID = &quot;cbSelect&quot; cb.CssClass = &quot;gvSummonsSelect&quot; TemplateField.ItemTemplate = New SysHelper.gvTemplate(DataControlRowType.DataRow, &quot;&quot;, cb) gvSummons.Columns.Add(TemplateField) &#x27;新增BoundField的方法 Dim BoundField As BoundField = New BoundField() BoundField.DataField = &quot;voucherno&quot; BoundField.HeaderText = &quot;傳票號碼&quot; BoundField.ItemStyle.HorizontalAlign = HorizontalAlign.Center gvSummons.Columns.Add(BoundField) End Sub","categories":[],"tags":[{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"},{"name":"GridView","slug":"GridView","permalink":"https://toyo0103.github.io/tags/GridView/"}]},{"title":"【JQuery】製作Sortable下拉時ScrollBar也會跟著捲動","slug":"【JQuery】製作Sortable下拉時ScrollBar也會跟著捲動","date":"2013-06-12T10:44:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2013/06/12/【JQuery】製作Sortable下拉時ScrollBar也會跟著捲動/","link":"","permalink":"https://toyo0103.github.io/2013/06/12/%E3%80%90JQuery%E3%80%91%E8%A3%BD%E4%BD%9CSortable%E4%B8%8B%E6%8B%89%E6%99%82ScrollBar%E4%B9%9F%E6%9C%83%E8%B7%9F%E8%91%97%E6%8D%B2%E5%8B%95/","excerpt":"","text":"JQuery Sortable套件 這個常常被我用來設定排序的套件，但有個缺點就是它在拉動時父容器不會跟著滾動ScrollBar，所以自己稍做修改了一下(包含上下按鈕的功能) 先看一下成果 HTML ```html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 123456789101112131415161718192021222324* CSS &#96;&#96;&#96;css#sortable &#123; list-style-type: none; margin: 0; padding: 0; width: 150px; &#125;#sortable li &#123; margin: 0 5px 5px 5px; padding: 5px; font-size: 1.2em; height: 1.5em; &#125;html&gt;body #sortable li &#123; height: 1.5em; line-height: 1.2em; &#125;.ui-state-highlight &#123; height: 1.5em; line-height: 1.2em; &#125; #sortable&#123; border:1px dotted gray; overflow:auto; height:500px; display:inline-block; width:130px;&#125;#sortbtn&#123; display:inline-block; width:30px; vertical-align:top; position:relative; top:180px;&#125; JavaScript ```javascript$(function () { var is_dragging = false; $(‘#sortable’).disableSelection().sortable({ placeholder: &quot;ui-state-highlight&quot;, axis: &#39;y&#39;, start: function (event, ui) &#123; is_dragging = true; itemSelect(ui.item); &#125;, stop: function (event, ui) &#123; is_dragging = false;&#125; }).mousemove(function (e) { if (is_dragging) &#123; $(&#39;#sortable&#39;).scrollTop(function (i, v) &#123; var h = $(&#39;#sortable&#39;).height(); var y = e.clientY - h / 2; return v + y * 0.05; &#125;); &#125; }); //=== 點擊Item時 $(‘#sortable &gt; li’).click(function (event) { itemSelect(this); }); ////=== 上下按鈕 $(‘#btnUp,#btnDown’).click(function () { var Container_height = $(&#39;#sortable&#39;).height(); var position_top = $(&#39;#sortable&#39;).position().top; if (lastSelect != null) &#123; if ($(this).prop(&#39;id&#39;) == &quot;btnUp&quot;) &#123; lastSelect.prev().before(lastSelect); //卷軸向上滾動 $(&#39;#sortable&#39;).scrollTop(function (i, v) &#123; if (lastSelect.position().top &lt;= position_top + Container_height / 2) &#123; return v - lastSelect.height(); &#125; &#125;); &#125; else &#123; lastSelect.next().after(lastSelect); //卷軸向下滾動 $(&#39;#sortable&#39;).scrollTop(function (i, v) &#123; if (lastSelect.position().top &gt;= position_top + Container_height / 2) &#123; return v + lastSelect.height(); &#125; &#125;); &#125; &#125; });});","categories":[],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://toyo0103.github.io/tags/JQuery/"}]},{"title":"【JavaScript】網址傳遞中文參數亂碼解決問題","slug":"【JavaScript】網址傳遞中文參數亂碼解決問題","date":"2013-06-10T14:53:00.000Z","updated":"2022-08-09T13:36:17.088Z","comments":true,"path":"2013/06/10/【JavaScript】網址傳遞中文參數亂碼解決問題/","link":"","permalink":"https://toyo0103.github.io/2013/06/10/%E3%80%90JavaScript%E3%80%91%E7%B6%B2%E5%9D%80%E5%82%B3%E9%81%9E%E4%B8%AD%E6%96%87%E5%8F%83%E6%95%B8%E4%BA%82%E7%A2%BC%E8%A7%A3%E6%B1%BA%E5%95%8F%E9%A1%8C/","excerpt":"","text":"參考 今天網址列傳遞參數時，透過Request.QueryString轉回來時變成亂碼。參考該部落格的解法後做個小筆記避免自己忘記 如果是用JavaScript串網址的話，用encodeURI()這個方法 ```javascriptvar Feature = ‘dialogWidth:500px;dialogHeight:200px;status:0;help:0;’;var Url = ‘wFrmAccount_Insert.aspx?src=’ + src + ‘&amp;bancode=’ + bancode + ‘&amp;ym=’ + ym + ‘&amp;type=’ + type;//將網址先編譯過後再傳遞window.showModalDialog(encodeURI(Url), window, Feature 1234* 如果是在ServerSide串網址，則用以下方法 &#96;&#96;&#96;csharpResponse.Redirect(&quot;WebForm2.aspx?id&#x3D;&quot; + Server.UrlEncode(&quot;中文&quot;))","categories":[],"tags":[{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://toyo0103.github.io/tags/JavaScript/"}]},{"title":"【SQL】Group by and Top 1","slug":"【SQL】Group-by-and-Top-1","date":"2013-05-29T09:13:00.000Z","updated":"2022-08-09T13:36:17.091Z","comments":true,"path":"2013/05/29/【SQL】Group-by-and-Top-1/","link":"","permalink":"https://toyo0103.github.io/2013/05/29/%E3%80%90SQL%E3%80%91Group-by-and-Top-1/","excerpt":"","text":"參考：[SQL] 於多筆重複資料中取得該重複群組中最新一筆資料 今天也遇到一個需求是將group by完後的資料挑出最新的一筆模擬的原始資料大致如下 我希望抓出每個人在在每個地點所做的最後一件事情，寫法如下: 先將每個人跟地點透過時間由大到小歸類 ```sqlselect * ,ROW_NUMBER() over(partition by location,who order by time Desc ) as row_index from timeline 1234567 [![](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-hbcc3sD90ek&#x2F;UaXGjjKL0UI&#x2F;AAAAAAAADmw&#x2F;jh2ks4iABqM&#x2F;s1600&#x2F;%E6%9C%AA%E5%91%BD%E5%90%8D.png)](http:&#x2F;&#x2F;3.bp.blogspot.com&#x2F;-hbcc3sD90ek&#x2F;UaXGjjKL0UI&#x2F;AAAAAAAADmw&#x2F;jh2ks4iABqM&#x2F;s1600&#x2F;%E6%9C%AA%E5%91%BD%E5%90%8D.png)* 然後 &#96;&#96;&#96;sqlselect * from ( select * ,ROW_NUMBER() over(partition by location,who order by time Desc ) as row_index from timeline) as tempTable where tempTable.row_index &#x3D; 1 [![](http://4.bp.blogspot.com/-E-Syl1jp57A/UaXHnZ_4jwI/AAAAAAAADm8/4cLCGkPmMag/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)](http://4.bp.blogspot.com/-E-Syl1jp57A/UaXHnZ_4jwI/AAAAAAAADm8/4cLCGkPmMag/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)* 結論就是早點回家，否則也只是在公司吃東西而已 XD","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"SQL NOT  EXISTS","slug":"SQL-NOT-EXISTS","date":"2013-05-28T06:46:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2013/05/28/SQL-NOT-EXISTS/","link":"","permalink":"https://toyo0103.github.io/2013/05/28/SQL-NOT-EXISTS/","excerpt":"","text":"參考MSDN結論就是，如果單一欄位要篩選掉就用Not IN ```sqlselect *from [order]where 序號 not in( select 訂單編號 from orderDetail) 123456789如果多個欄位要同時符合才篩選掉，就用Not Exists &#96;&#96;&#96;sqlselect *from [order] awhere not exists( select 訂單編號 from orderDetail b where b.訂單編號 &#x3D; a.序號 and b.購買日期 &#x3D; (a.民國年+1911) )","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【SharePoint 2013】開啟BreadCrumb","slug":"【SharePoint-2013】開啟BreadCrumb","date":"2013-05-20T02:15:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2013/05/20/【SharePoint-2013】開啟BreadCrumb/","link":"","permalink":"https://toyo0103.github.io/2013/05/20/%E3%80%90SharePoint-2013%E3%80%91%E9%96%8B%E5%95%9FBreadCrumb/","excerpt":"","text":"用Sharepoint Designer登入SharePoint網站 編輯主板頁面 找到GlobalBreadCrumbNavPopout 做以下修改 * 將div class=&quot;ms-breadcrumb-dropdownBox&quot;旁邊的display:none修改掉 將GlobalBreadCrumbNavPopout的Visible改為True ```html ``` breadCrumb就出現了","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"Cache","slug":"Cache","date":"2013-05-15T06:53:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2013/05/15/Cache/","link":"","permalink":"https://toyo0103.github.io/2013/05/15/Cache/","excerpt":"","text":"今天在研究Cache，意外發現好多觀念上的問題有些東西還沒時間驗證跟消化，先筆記起來之後回來好好看一下 保哥 正確的使用 ASP.NET 的 Cache 物件How to cache data in a MVC application[ASP.NET MVC] 快取( Cache ) 的機制.NET記憶體管理之弱式參考(Weak Reference)Partial Output Caching in ASP.NET MVC","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【JQuery】透過$.fn.Extend自製Alert Function","slug":"【JQuery】透過-fn-Extend自製Alert-Function","date":"2013-05-13T09:19:14.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2013/05/13/【JQuery】透過-fn-Extend自製Alert-Function/","link":"","permalink":"https://toyo0103.github.io/2013/05/13/%E3%80%90JQuery%E3%80%91%E9%80%8F%E9%81%8E-fn-Extend%E8%87%AA%E8%A3%BDAlert-Function/","excerpt":"","text":"Google Drive新增修刪除後顯示訊息的方式，是在畫面上方跑出訊息一段時候後自動消失。今天就來實作一下這個功能~ 首先請先去下載bootstrap，這裡面有個alert的class個人覺得滿漂亮的，所以就拿這個來改吧!! 首先正確的載入bootstrap的CSS跟JavaScript 寫一個自製的JavaScript，其中$.fn.extend是JQuery的擴充function1234567891011121314151617181920212223242526/// &lt;reference path=&quot;../jquery-1.9.1.min.js&quot; /&gt; $.fn.extend(&#123; alert: function (msg) &#123; var parentElement = $(this); var alertElement = $(&#x27;&lt;div class=&quot;alert&quot;&gt;&#x27;+ &#x27;&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt;&#x27;+ &#x27;&lt;span class=&quot;text-center&quot;&gt;&#x27; + msg + &#x27;&lt;/span&gt;&#x27; + &#x27;&lt;/div&gt;&#x27;); //先加到容器內才能算長度 alertElement.appendTo(parentElement); //alert區塊的寬度 var alertWidth = alertElement.width(); //容器的寬度 var targetWidth = parentElement.width(); var position = parentElement.position(); var _left = position.left + (targetWidth / 2) - (alertWidth / 2); alertElement.css(&#123; top: position.top, left: _left &#125;).fadeIn(500); //時間到就清除掉 var timer = setTimeout(function () &#123; alertElement.fadeOut(); clearTimeout(timer); &#125;, 5000); &#125;&#125;); 改一些bootstrap的CSS，通常我會將這段另外寫在自己的css檔案裡面，盡量避免直接改動官方的任何檔案1234567891011121314151617/* alert訊息 */.alert&#123; width:300px; z-index:3; display:none; color:#0300FA; position:absolute; margin:0px;&#125; .alert&gt;span&#123; display:inline-block; width:270px; word-break:break-all;&#125; 之後呼叫這樣寫12//在這邊$(&#x27;#BackStageBody&#x27;)為要出現訊息方塊的區域，剛剛擴充的function會自動計算其寬高，並把訊息顯示在正確的位置$(&#x27;#BackStageBody&#x27;).alert(&#x27;新增成功&#x27;) 效果如下","categories":[],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://toyo0103.github.io/tags/JQuery/"}]},{"title":"【MVC】擴充HtmlHelper","slug":"【MVC】擴充HtmlHelper","date":"2013-05-08T08:10:00.000Z","updated":"2022-08-09T13:36:17.090Z","comments":true,"path":"2013/05/08/【MVC】擴充HtmlHelper/","link":"","permalink":"https://toyo0103.github.io/2013/05/08/%E3%80%90MVC%E3%80%91%E6%93%B4%E5%85%85HtmlHelper/","excerpt":"","text":"第一個範例，讓ActionLink可以放HTML標籤進去 首先我先在專案中建立一個資料夾，並且在裡面新增一個類別檔案 [![](http://2.bp.blogspot.com/-NBhxVa8AExI/UYoHecX2TrI/AAAAAAAADIE/G9Hvt_r7t_4/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)](http://2.bp.blogspot.com/-NBhxVa8AExI/UYoHecX2TrI/AAAAAAAADIE/G9Hvt_r7t_4/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)* ```csharp //將命名空間改成System.Web.Mvc.Html，使用前不用修改~/Views/Web.confignamespace System.Web.Mvc.Html{ public static class MyHtmlHelperExtensions { public static MvcHtmlString InsertHtmlTagActionLink(this AjaxHelper ajaxHelper,string linkText ,string actionName, string controllerName, AjaxOptions ajaxOptions) &#123; var lnk = ajaxHelper.ActionLink(&quot;[replaceme]&quot;, actionName, controllerName, ajaxOptions); return MvcHtmlString.Create(lnk.ToString().Replace(&quot;[replaceme]&quot;, linkText)); &#125; } 123* 使用方式如下 &#96;&#96;&#96;csharp@Ajax.InsertHtmlTagActionLink(&quot;&lt;i class&#x3D;&#39;icon-file&#39;&gt;&lt;&#x2F;i&gt;&quot;+@childFunction.funname, action, controller, new AjaxOptions &#123; UpdateTargetId&#x3D;&quot;BackStageBody&quot; &#125;); 第二個範例，將TextBoxFor固定塞入一個data-content的html屬性，並將值給這個屬性 ```csharppublic static MvcHtmlString TextBoxFor_WithOriginData&lt;TModel, TProp&gt;(this HtmlHelper htmlHelper, Expression&lt;Func&lt;TModel, TProp&gt;&gt; expression,object HtmlAttributes = null){ //透過AnonymousObjectToHtmlAttributes將HtmlAttribute讀取出來 var attrs = HtmlHelper.AnonymousObjectToHtmlAttributes(HtmlAttributes); //將expression的值抓出來放到data-content這個屬性中 attrs.Add(“data-content”,ModelMetadata.FromLambdaExpression(expression, htmlHelper.ViewData).Model); var txtBoxFor = htmlHelper.TextBoxFor(expression, attrs); return MvcHtmlString.Create(txtBoxFor.ToString());} 123456789101112131415161718* **第三個範例，加入Img這個Tag*** &#96;&#96;&#96;csharppublic static MvcHtmlString ImageFor_WithOriginData&lt;TModel, TProp&gt;(this HtmlHelper&lt;TModel&gt; htmlHelper, Expression&lt;Func&lt;TModel, TProp&gt;&gt; expression, object HtmlAttributes &#x3D; null)&#123; string value &#x3D; ModelMetadata.FromLambdaExpression(expression, htmlHelper.ViewData).Model &#x3D;&#x3D; null ? &quot;&quot; : ModelMetadata.FromLambdaExpression(expression, htmlHelper.ViewData).Model.ToString(); &#x2F;&#x2F;屬性的值 string propname &#x3D; ModelMetadata.FromLambdaExpression(expression, htmlHelper.ViewData).PropertyName; &#x2F;&#x2F;透過AnonymousObjectToHtmlAttributes將HtmlAttribute讀取出來 var attrs &#x3D; HtmlHelper.AnonymousObjectToHtmlAttributes(HtmlAttributes); attrs.Add(&quot;data-content&quot;, value); attrs.Add(&quot;src&quot;, value); attrs.Add(&quot;name&quot;, propname); var img &#x3D; new TagBuilder(&quot;img&quot;); img.MergeAttributes(attrs); return MvcHtmlString.Create(img.ToString(TagRenderMode.SelfClosing));&#125;","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【MVC】回傳Json格式，並用JQuery解讀","slug":"【MVC】回傳Json格式，並用JQuery解讀","date":"2013-05-07T15:13:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2013/05/07/【MVC】回傳Json格式，並用JQuery解讀/","link":"","permalink":"https://toyo0103.github.io/2013/05/07/%E3%80%90MVC%E3%80%91%E5%9B%9E%E5%82%B3Json%E6%A0%BC%E5%BC%8F%EF%BC%8C%E4%B8%A6%E7%94%A8JQuery%E8%A7%A3%E8%AE%80/","excerpt":"","text":"View中回傳Json格式的物件 ```csharpvar jsonObject = JsonConvert.SerializeObject(Repository.GetExhibitionList().OrderBy(o =&gt; o.CreateDate).ToArray());return Json(jsonObject); 12345678910111213141516JQuery中解讀 &#96;&#96;&#96;javascriptvar List &#x3D; $.parseJSON(returnvalue);var tr &#x3D; [];&#x2F;&#x2F;轉換日期格式$.each(List, function (index, val) &#123; tr.push(&#39;&lt;tr class&#x3D;&quot;exhibitionItem&quot;&gt;&#39; + &#39;&lt;td&gt;&#39; + (index + 1) + &#39;&lt;&#x2F;td&gt;&#39; + &#39;&lt;td&gt;&#39; + val.ExhibitionName + &#39;&lt;&#x2F;td&gt;&#39; + &#39;&lt;td&gt;&#39; + val.CreateDate + &#39;&lt;&#x2F;td&gt;&#39; + &#39;&lt;td&gt;&#39; + val.EditDate + &#39;&lt;&#x2F;td&gt;&#39; + &#39;&lt;&#x2F;tr&gt;&#39;);&#125;);","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://toyo0103.github.io/tags/JSON/"},{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"},{"name":"JQuery","slug":"JQuery","permalink":"https://toyo0103.github.io/tags/JQuery/"}]},{"title":"動態新增或刪除MenuTab與MultiView","slug":"動態新增或刪除MenuTab與MultiView","date":"2013-05-07T07:28:00.000Z","updated":"2022-08-09T13:36:17.097Z","comments":true,"path":"2013/05/07/動態新增或刪除MenuTab與MultiView/","link":"","permalink":"https://toyo0103.github.io/2013/05/07/%E5%8B%95%E6%85%8B%E6%96%B0%E5%A2%9E%E6%88%96%E5%88%AA%E9%99%A4MenuTab%E8%88%87MultiView/","excerpt":"","text":"雖然我應該八萬年都不會用這兩個控制項，但今天幫人家改了一個莫名其妙的問題，就順便紀錄一下吧必須寫在Page_Init，且MultiView在新增時不能放在Page_Load裡面，不然有時候會當掉….超怪!! ```vbProtected Sub Page_Init(ByVal Sender As Object, ByVal e As EventArgs) Handles Me.Init If Not Page.IsPostBack Then Me.MultiViewControl.Controls.Clear() Select Case Request.QueryString(&quot;Type&quot;) Case &quot;01&quot; Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items(0).Selected = True Me.MultiViewControl.Controls.Add(View4) Case &quot;02&quot; Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items.RemoveAt(1) Me.MenuTab.Items.RemoveAt(1) Me.MenuTab.Items(0).Selected = True Me.MultiViewControl.Controls.Add(View2) Case Else Me.MenuTab.Items.RemoveAt(3) Me.MultiViewControl.Controls.Add(View1) Me.MultiViewControl.Controls.Add(View2) Me.MultiViewControl.Controls.Add(View3) End Select End If End Sub 1234567891011121314151617181920212223242526272829303132333435363738**補充!!!*** 之前是用QueryString的參數來決定要加入哪些View，但因為其實開的WebForm都是同一個，所以如果有使用一些控制項(例如:UpdatePanel之類的)，會回傳ViewState不一致或一些奇奇怪怪的問題一堆，所以改正了上述的作法，MultiView從頭到尾都不移除，而是依據目前Menu選取來決定show哪個View* 修正版本 &#96;&#96;&#96;vbProtected Sub Page_Init(ByVal Sender As Object, ByVal e As EventArgs) Handles Me.Init If Not Page.IsPostBack Then Select Case Request.QueryString(&quot;Type&quot;) Case &quot;01&quot; Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items(0).Selected &#x3D; True Case &quot;02&quot; Me.MenuTab.Items.RemoveAt(0) Me.MenuTab.Items.RemoveAt(1) Me.MenuTab.Items.RemoveAt(1) Me.MenuTab.Items(0).Selected &#x3D; True Case Else Me.MenuTab.Items.RemoveAt(3) End Select End If End Sub Protected Sub View_Select(sender As Object, e As EventArgs) Handles Menu1.PreRender Select Case Menu1.SelectedValue Case &quot;1&quot; MultiView1.ActiveViewIndex &#x3D; 0 Case &quot;2&quot; MultiView1.ActiveViewIndex &#x3D; 1 Case &quot;3&quot; MultiView1.ActiveViewIndex &#x3D; 2 End Select End Sub","categories":[],"tags":[{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"}]},{"title":"跨DB select","slug":"跨DB-select","date":"2013-05-02T09:42:00.000Z","updated":"2022-08-09T13:36:17.098Z","comments":true,"path":"2013/05/02/跨DB-select/","link":"","permalink":"https://toyo0103.github.io/2013/05/02/%E8%B7%A8DB-select/","excerpt":"","text":"12select * from opendatasource(&#x27;SQLNCLI10&#x27;,&#x27;Data Source=192.168.1.110;User ID=帳號;Password=密碼&#x27;).DataBaseName.dbo.TableName","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【C#】透過C#加密","slug":"【C-】透過C-加密","date":"2013-05-01T07:55:00.000Z","updated":"2022-08-09T13:36:17.086Z","comments":true,"path":"2013/05/01/【C-】透過C-加密/","link":"","permalink":"https://toyo0103.github.io/2013/05/01/%E3%80%90C-%E3%80%91%E9%80%8F%E9%81%8EC-%E5%8A%A0%E5%AF%86/","excerpt":"","text":"strKey與strIV是用來加密的參數，可以替換任何字元但一定要8個字 //加密動作 private static string strKey = \"toyo1234\"; private static string strIV = \"lovecode\"; /// &lt;summary&gt;字串編碼&lt;/summary&gt; /// &lt;param name=\"strSource\"&gt;原始字串&lt;/param&gt; /// &lt;returns&gt;編碼後的結果字串&lt;/returns&gt; public static string enCrypt(string strSource) { MemoryStream ms = new MemoryStream(); DESCryptoServiceProvider key = new DESCryptoServiceProvider(); CryptoStream encStream = new CryptoStream(ms, key.CreateEncryptor(Encoding.Default.GetBytes(strKey), Encoding.Default.GetBytes(strIV)), CryptoStreamMode.Write); StreamWriter sw = new StreamWriter(encStream); sw.WriteLine(strSource); sw.Close(); encStream.Close(); byte[] buffer = ms.ToArray(); ms.Close(); return Convert.ToBase64String(buffer); } /// &lt;summary&gt;字串解碼&lt;/summary&gt; /// &lt;param name=\"strSource\"&gt;加密過的字串&lt;/param&gt; /// &lt;returns&gt;解碼後的結果字串&lt;/returns&gt; public static string deCrypt(string strSource) { MemoryStream ms = new MemoryStream(Convert.FromBase64String(strSource)); DESCryptoServiceProvider key = new DESCryptoServiceProvider(); CryptoStream encStream = new CryptoStream(ms, key.CreateDecryptor(Encoding.Default.GetBytes(strKey), Encoding.Default.GetBytes(strIV)), CryptoStreamMode.Read); StreamReader sr = new StreamReader(encStream); string val = sr.ReadLine(); sr.Close(); encStream.Close(); ms.Close(); return val; }","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"Entity Framework問題筆記","slug":"Entity-Framework問題筆記","date":"2013-05-01T07:44:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2013/05/01/Entity-Framework問題筆記/","link":"","permalink":"https://toyo0103.github.io/2013/05/01/Entity-Framework%E5%95%8F%E9%A1%8C%E7%AD%86%E8%A8%98/","excerpt":"","text":"目前使用的是MVC4 + Entity Framework **Q:**無法更新 EntitySet ‘xxxx’，因為它有 DefiningQuery，但是在 項目中沒有 項目來支援目前的作業。**A：**這是因為 Table 沒有 PK 的關係，所以 EF 就認定這是唯讀的 Table ，在 EDMX 的 Model 中的 Table 的欄位，加上 pk 後就正常了 **Q:**在設計資料庫時明明有指定欄位的預設值，可是每次透過 EF 新增資料時，該欄位的值卻是 null？**A:**這是因為 DB 該欄位有 Default Value 而且又不允許 null，在 Visual Studio 中開啟 .edmx 檔案，在模型編輯器中點選 entity 的屬性，然後到屬性視窗中設定其 Default Value 屬性。參考下圖： 參考自:Entity Framework 4 的錯誤訊息排除Entity Framework 欄位預設值相關問題","categories":[],"tags":[{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://toyo0103.github.io/tags/Entity-Framework/"}]},{"title":"【MVC】Client Side Validate in Partial View  with unobtrusive","slug":"【MVC】Client-Side-Validate-in-Partial-View-with-unobtrusive","date":"2013-04-29T08:23:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2013/04/29/【MVC】Client-Side-Validate-in-Partial-View-with-unobtrusive/","link":"","permalink":"https://toyo0103.github.io/2013/04/29/%E3%80%90MVC%E3%80%91Client-Side-Validate-in-Partial-View-with-unobtrusive/","excerpt":"","text":"MVC中很好用的一種驗證方式就是在model寫attribute 1234[Required(ErrorMessage=&quot;展覽名稱為必填&quot;)][MaxLength(50)]public string ExhibitionName &#123; get; set; &#125; 接著在View中用HtmlHelp方式建立Textbox 123@Html.TextBoxFor(m =&gt; m.ExhibitionName)@Html.ValidationMessageFor(m =&gt; m.ExhibitionName) MVC就會很貼心的把你的Client端驗證做好了。 但今天遇到的問題是，用同樣的方法寫在Partial View裡面卻沒有用狀況如下：在_layout Page中一樣載入了必備的MVC4提供的Jquery驗證檔案 &lt;script src=\"/Scripts/jquery.unobtrusive-ajax.js\"&gt;&lt;/script&gt; &lt;script src=\"/Scripts/jquery.validate.js\"&gt;&lt;/script&gt; &lt;script src=\"/Scripts/jquery.validate.unobtrusive.js\"&gt;&lt;/script&gt; 網站頁面長成這樣 [![](http://4.bp.blogspot.com/-WiQ8PRLsFG0/UX4vwwOgvvI/AAAAAAAACq8/ifNZBq9JUEs/s640/1.png)](http://4.bp.blogspot.com/-WiQ8PRLsFG0/UX4vwwOgvvI/AAAAAAAACq8/ifNZBq9JUEs/s1600/1.png)當按下紅色框框內的功能列表，用Ajax的方式return Partial View放到藍色框框中。 [![](http://1.bp.blogspot.com/-h-0y5VY6FgE/UX4wNNMxGiI/AAAAAAAACrE/IzSGeMXQhQo/s640/1.png)](http://1.bp.blogspot.com/-h-0y5VY6FgE/UX4wNNMxGiI/AAAAAAAACrE/IzSGeMXQhQo/s1600/1.png) 但用Ajax載入的Partial View用上述的方式就不會自動驗證了，研判應該是動態產生的DOM元件沒有跟JQuery繫結到，這跟以前Asp.Net的UpdatePanel有異曲同工之妙。 所以在Partial View中的Script block中加入這行 註:#ajaxForm為Partial View中Form ID 1234$(&#x27;body&#x27;).on(&quot;click&quot;, &#x27;.addNewExihition&#x27;, function () &#123; $.validator.unobtrusive.parse(&#x27;.ajaxForm&#x27;); &#125;); 這樣JQuery的驗證就又重新繫結上了，讚!!","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"【JQuery】為動態新增的Elements綁定事件 -- jQuery .on()","slug":"【JQuery】為動態新增的Elements綁定事件-jQuery-on","date":"2013-04-29T04:20:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2013/04/29/【JQuery】為動態新增的Elements綁定事件-jQuery-on/","link":"","permalink":"https://toyo0103.github.io/2013/04/29/%E3%80%90JQuery%E3%80%91%E7%82%BA%E5%8B%95%E6%85%8B%E6%96%B0%E5%A2%9E%E7%9A%84Elements%E7%B6%81%E5%AE%9A%E4%BA%8B%E4%BB%B6-jQuery-on/","excerpt":"","text":"按下新增按鈕後，利用JQuery動態新增一個填寫欄位跟兩個按鈕 其中取消的按鈕ID為addCancel，我想替它增加click事件按下後彈跳一則簡短的訊息原本的寫法如下： 1234$(&#x27;#addCancel&#x27;).click(function () &#123; alert(&#x27;Click事件沒有問題&#x27;);&#125;); 但Click事件始終沒有效果，原來動態新增的elements要綁定事件需要用**.on**的方式 1234$(&#x27;body&#x27;).on(&quot;click&quot;, &#x27;#addCancel&#x27;, function () &#123; alert(&#x27;用on綁定就沒有問題!!&#x27;);&#125;);","categories":[],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://toyo0103.github.io/tags/JQuery/"}]},{"title":"【MVC】One View Two Models --  tuple or ViewModel","slug":"【MVC】One-View-Two-Models-tuple-or-ViewModel","date":"2013-04-29T02:48:00.000Z","updated":"2022-08-09T13:36:17.089Z","comments":true,"path":"2013/04/29/【MVC】One-View-Two-Models-tuple-or-ViewModel/","link":"","permalink":"https://toyo0103.github.io/2013/04/29/%E3%80%90MVC%E3%80%91One-View-Two-Models-tuple-or-ViewModel/","excerpt":"","text":"如果有個View同時需要載入兩個model時可以使用tuple ```html@model Tuple&lt;IEnumerable&lt;NTI.Models.ExhibitionList&gt;,NTI.Models.ExhibitionList&gt; 1234567891011121314**Model**&#96;&#96;&#96;csharppublic class ExhibitionList &#123; [Required] [MaxLength(50)] public string ExhibitionName &#123; get; set; &#125; public DateTime CreateDate &#123; get; set; &#125; public DateTime EditDate &#123; get; set; &#125;&#125; Controller```csharppublic ActionResult ExhibitionList(){ var tuple = new Tuple&lt;IEnumerable, ExhibitionList&gt;(Repository.GetExhibitionList(), new ExhibitionList()); return PartialView(tuple);} 123456789101112131415161718192021222324**View**&#96;&#96;&#96;htmlif (Model.Item1.Count() &#x3D;&#x3D; 0)&#123; &lt;tr id&#x3D;&quot;noExhibition&quot;&gt; &lt;td colspan&#x3D;&quot;4&quot;&gt; &lt;span class&#x3D;&quot;text-left&quot;&gt;沒有建立任何展覽喔....&lt;&#x2F;span&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &#125;else&#123; foreach (var exhibitionItem in Model.Item1) &#123; &lt;tr&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;@exhibitionItem.ExhibitionName&lt;&#x2F;td&gt; &lt;td&gt;@exhibitionItem.CreateDate&lt;&#x2F;td&gt; &lt;td&gt;@exhibitionItem.EditDate&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &#125; @Html.TextBoxFor(m &#x3D;&gt; Model.Item2.ExhibitionName)&#125; 在View中使用Model的方法為：Model.Item1代表載入的第一個ModelModel.Item2代表載入的第二個Model 第二種方式就是建立一個ViewModel的方式Model```csharp/// 展覽列表的ViewModelpublic class ExhibitionListViewModel{ public IEnumerable IEmumerable_ExhibitionList { get; set; } public ExhibitionList ExhibitionListModel { get; set; }} 123456789**View**&#96;&#96;&#96;csharppublic ActionResult ExhibitionList() &#123; ExhibitionListViewModel model &#x3D; new ExhibitionListViewModel(); model.IEmumerable_ExhibitionList &#x3D; Repository.GetExhibitionList(); model.ExhibitionListModel &#x3D; new ExhibitionList(); return PartialView(model);&#125; Controller```csharp@Html.TextBoxFor(model =&gt; model.ExhibitionListModel.ExhibitionName)@Html.ValidationMessageFor(model =&gt; model.ExhibitionListModel.ExhibitionName) //and ….if (Model.IEmumerable_ExhibitionList.Count() == 0){ //do something}","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"Git 語法筆記","slug":"Git-語法筆記","date":"2013-04-28T13:48:00.000Z","updated":"2022-08-09T13:36:17.078Z","comments":true,"path":"2013/04/28/Git-語法筆記/","link":"","permalink":"https://toyo0103.github.io/2013/04/28/Git-%E8%AA%9E%E6%B3%95%E7%AD%86%E8%A8%98/","excerpt":"","text":"將狀態還原到當時的commit ```csharpgit reset “編碼” 1234將判斷現在source code的狀態 &#96;&#96;&#96;csharpgit status 將改變過的source code全部add進去 ```csharpgit add . 123Commit &#96;&#96;&#96;csharpgit commit -m &quot;名稱&quot; push ```csharpgit push origin master","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://toyo0103.github.io/tags/Git/"}]},{"title":"【SQL】Split","slug":"【SQL】Split","date":"2013-04-24T08:33:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2013/04/24/【SQL】Split/","link":"","permalink":"https://toyo0103.github.io/2013/04/24/%E3%80%90SQL%E3%80%91Split/","excerpt":"","text":"今天遇到一個需求如下Table1 T1裡面有問候語加上一群使用者的代碼(用逗號區隔開來) Table1 T2裡面有使用者代碼跟其對應的名稱 目標搜尋出來的結果如下：意即代碼要被換成其對應的名稱 首先先建立一個可以將分隔符號拆開，並且去搜尋對應名稱的function (抓網路上高手寫的Code回來修改而成) ```sqlcreate FUNCTION [dbo].[ufn_Split]( @InputString nvarchar(4000))RETURNS varchar(1000) –執行這個function會回傳字串ASBEGIN –用來儲存分隔符號的Index DECLARE @CIndex smallint –用來串接字串並最後回傳回去的字串 declare @OutputString varchar(1000) =’’ declare @tempString varchar(500) =’’ WHILE (@InputString&lt;&gt;’’) BEGIN SET @CIndex=CHARINDEX(‘,’,@InputString) –抓到第一個分隔符號的Index IF @CIndex=0 SET @CIndex=LEN(@InputString)+1 –將第一組代碼拆解出來並帶到T2去搜尋對應的名稱，如果搜尋出來為null的話則當作空字串處理 set @tempString = isnull((select name from t2 where id = (SUBSTRING(@InputString,1,@CIndex-1))),’’) –這串if else純粹只是要解決多餘的逗號問題而已，就不多加解釋了 if @tempString &lt;&gt; ‘’ begin if @OutputString = ‘’ begin set @OutputString = @tempString end else set @OutputString = @OutputString +’,‘+@tempString end IF @CIndex=LEN(@InputString)+1 BREAK –把剛剛搜尋過的代碼挑掉後，剩下的繼續跑迴圈 SET @InputString=SUBSTRING(@InputString,@CIndex+1,LEN(@InputString)-@CIndex) END RETURN @OutputStringEND 1234最後SQL command如下，就可以得到上述合併的結果了!!! &#96;&#96;&#96;sqlselect title,dbo.ufn_Split(number) from t1","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"Forms Authentication in MVC","slug":"Forms-Authentication-in-MVC","date":"2013-04-21T13:06:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2013/04/21/Forms-Authentication-in-MVC/","link":"","permalink":"https://toyo0103.github.io/2013/04/21/Forms-Authentication-in-MVC/","excerpt":"","text":"今天練習在MVC4中使用Forms Authentication的驗證機制來控制登入與否的狀態，記錄一下筆記 首先打開MVC的web.config找到authentication的標籤將登入頁面註冊一下 ```csharp 123456789101112131415只要在沒有登入的情況下瀏覽需要權限的頁面就會被導到&#x2F;BackStage&#x2F;Login，要求其登入* 接下來設定哪些action需要權限才能觀看，在MVC4中的設定方式如下 * 第一種：直接在要action上面加上[Authorize]，表示該action匿名的方式無法存取 &#96;&#96;&#96;csharppublic class ExhibitionController : Controller &#123; &#x2F;&#x2F; &#x2F;&#x2F; GET: &#x2F;Exhibition&#x2F; [Authorize] public ActionResult Index() &#123; return View(); &#125; &#125; 第二種：在Controller加上[Authorize]，表示所有這個controller底下的action皆需要驗證通過的狀態下才能讀取，可以在action加上 [AllowAnonymous]讓該action不用驗證 [Authorize]//預設這個controller都要驗證過後才能讀取public class ExhibitionController : Controller{ [AllowAnonymous]//這個action無需驗證，所有人皆能直接讀取 public ActionResult Index() { return View(); } public ActionResult about() { return View(); }} &lt;/pre&gt; 驗證成功後呼叫FormsAuthentication.RedirectFromLoginPage()，告訴網站該使用者已經通過驗證。 ```csharpif (Acclogin.CheckPassword()){ FormsAuthentication.RedirectFromLoginPage(Acclogin.Account, false);return Redirect(returnUrl);}","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"}]},{"title":"Entity Framwork 使用 SQL的PWDCOMPARE函數","slug":"Entity-Framwork-使用-SQL的PWDCOMPARE函數","date":"2013-04-21T08:02:00.000Z","updated":"2022-08-09T13:36:17.077Z","comments":true,"path":"2013/04/21/Entity-Framwork-使用-SQL的PWDCOMPARE函數/","link":"","permalink":"https://toyo0103.github.io/2013/04/21/Entity-Framwork-%E4%BD%BF%E7%94%A8-SQL%E7%9A%84PWDCOMPARE%E5%87%BD%E6%95%B8/","excerpt":"","text":"要使用SQL的PWDCOMPARE 函數，必須先將邏輯寫進StoreProcedure或是SQL function裡面，這裡以StoreProcedure為例 先建立StoreProcedure在裡面使用PWDCOMPARE函數比對密碼是否正確，成功傳回1，失敗傳回0 create procedure sp_CheckLoginPassword @Account varchar(50), @Password varchar(150) as declare @validate int set @validate = ( select PWDCOMPARE(@Password,tcuser.Password) from tcuser where tcuser.Account = @Account) select isnull(@validate,0) * 建立Entity Framwork，將剛剛寫的StoreProcedure更新進來 透過Entity Framwork建立出來的物件呼叫該方法就大功告成了!! public bool CheckPassword(){//傳回0表示驗證失敗; 1表示成功NTIEntities db = new NTIEntities();bool isValidate = db.sp_CheckLoginPassword(this.Account, this.Password).First() == 1 ? true : false;return isValidate;} 驗證方法成功後呼叫FormsAuthentication.RedirectFromLoginPage(),告訴網站該使用者已經成功登入 ```csharpif (Acclogin.CheckPassword()){ FormsAuthentication.RedirectFromLoginPage(Acclogin.Account, false);return Redirect(returnUrl);}","categories":[],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"},{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://toyo0103.github.io/tags/Entity-Framework/"},{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"}]},{"title":"【SharePoint 2013】開啟以不同使用者登入選項","slug":"【SharePoint-2013】開啟以不同使用者登入選項","date":"2013-04-13T09:33:30.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2013/04/13/【SharePoint-2013】開啟以不同使用者登入選項/","link":"","permalink":"https://toyo0103.github.io/2013/04/13/%E3%80%90SharePoint-2013%E3%80%91%E9%96%8B%E5%95%9F%E4%BB%A5%E4%B8%8D%E5%90%8C%E4%BD%BF%E7%94%A8%E8%80%85%E7%99%BB%E5%85%A5%E9%81%B8%E9%A0%85/","excerpt":"","text":"在SharePoint 2013中，預設沒有切換使用者的選項 叫出來的方法如下: 先找到以下路徑開啟 \\15\\TEMPLATE\\CONTROLTEMPLATES\\Welcome.ascx 用編輯器打開，並找到ID為 ID_RequestAccess的控制項 在該控制項前面加入以下程式碼 123456&lt;SharePoint:MenuItemTemplate runat=&quot;server&quot; ID=&quot;ID_LoginAsDifferentUser&quot; Text=&quot;&lt;%$Resources:wss,personalactions_loginasdifferentuser%&gt;&quot; Description=&quot; &lt;%$Resources:wss,personalactions_loginasdifferentuserdescription%&gt;&quot; MenuGroupId=&quot;100&quot; Sequence=&quot;100&quot; UseShortId=&quot;true&quot; /&gt; 大功告成","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【C#】GridView動態加入textbox","slug":"【C-】GridView動態加入textbox","date":"2013-01-31T03:14:00.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2013/01/31/【C-】GridView動態加入textbox/","link":"","permalink":"https://toyo0103.github.io/2013/01/31/%E3%80%90C-%E3%80%91GridView%E5%8B%95%E6%85%8B%E5%8A%A0%E5%85%A5textbox/","excerpt":"","text":"GridView原本產出的資料如下圖 [![](http://2.bp.blogspot.com/-Spka-CC-RXA/UQne4vnVBtI/AAAAAAAAA1c/vq-CaRzXOyI/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)](http://2.bp.blogspot.com/-Spka-CC-RXA/UQne4vnVBtI/AAAAAAAAA1c/vq-CaRzXOyI/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png) 需求是將*號的部分變成TextBox且可輸入的字數要跟*號的個數相同，程式碼如下： 在GridView RowDataBound事件中 1234567891011121314151617protected void GridView_RowDataBound(object sender, GridViewRowEventArgs e) &#123; if(e.Row.RowType == DataControlRowType.DataRow) &#123; for(int i = 0 ; i = &lt; e.Row.Cells.Count; i++) &#123; if(e.Row.Cells[i].Text.Contains(&quot;*&quot;)) &#123; int count = e.Row.Cells[i].Text.Count(f =&gt; f== &#x27;*&#x27;); int firstIndex = e.Row.Cells[i].Text.IndexOf(&#x27;*&#x27;); e.Row.Cells[i].Text = e.Row.Cells[i].Text.Replace(&quot;*&quot;,&quot;&quot;).Insert(firstIndex, &quot;&lt;input maxlength=&quot;+ count +&quot; runat=&#x27;server&#x27; size=&#x27;5&#x27; type=&#x27;text&#x27; value=&#x27;&#x27; /&gt;&quot;); &#125; &#125; &#125; &#125; 先算出*號的個數 找到*號第一次出現的位置 將*號全部Replace並在第一次出現的位置插入&lt;input type=’text’ /&gt; 結果如下[![](http://2.bp.blogspot.com/-e8AUIv9UIiU/UQnhfaf2eUI/AAAAAAAAA1w/cKFgnpj4UIE/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)](http://2.bp.blogspot.com/-e8AUIv9UIiU/UQnhfaf2eUI/AAAAAAAAA1w/cKFgnpj4UIE/s1600/%E6%9C%AA%E5%91%BD%E5%90%8D.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"},{"name":"GridView","slug":"GridView","permalink":"https://toyo0103.github.io/tags/GridView/"}]},{"title":"【C#】GridView更改Pager的樣式","slug":"【C-】GridView更改Pager的樣式","date":"2013-01-08T09:04:00.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2013/01/08/【C-】GridView更改Pager的樣式/","link":"","permalink":"https://toyo0103.github.io/2013/01/08/%E3%80%90C-%E3%80%91GridView%E6%9B%B4%E6%94%B9Pager%E7%9A%84%E6%A8%A3%E5%BC%8F/","excerpt":"","text":"在GridView的Pager是用Table組成的，這裡是做個簡單的將 \"...\" 改成前五頁後五頁。 else if(e.Row.RowType == DataControlRowType.Pager) { //修改page ...的樣式 TableRow pageTR = (TableRow)e.Row.Controls[0].Controls[0].Controls[0]; for(int x = 0; x&lt; pageTR.Controls.Count; x++) { TableCell pageTD = (TableCell)pageTR.Controls[x]; for(int y = 0 ; y&lt;pageTD.Controls.Count; y++) { if(pageTD.Controls[y] is LinkButton) { LinkButton lb = (LinkButton)pageTD.Controls[y]; if(lb.Text == &quot;...&quot; &amp;&amp; x == 1) { lb.Text = &quot;前5頁&quot;; } else if(lb.Text ==&quot;...&quot;) { lb.Text = &quot;後5頁&quot;; } } } } }","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"},{"name":"GridView","slug":"GridView","permalink":"https://toyo0103.github.io/tags/GridView/"}]},{"title":"【SharePoint】判斷清單屬性","slug":"【SharePoint】判斷清單屬性","date":"2012-12-27T03:31:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2012/12/27/【SharePoint】判斷清單屬性/","link":"","permalink":"https://toyo0103.github.io/2012/12/27/%E3%80%90SharePoint%E3%80%91%E5%88%A4%E6%96%B7%E6%B8%85%E5%96%AE%E5%B1%AC%E6%80%A7/","excerpt":"","text":"最近做一個SharePoint的功能，需要將SiteCollection裡面所有子網站的清單全數撈出來，並判斷是否為Survey或Announcement 判斷是否為Survey ```csharpList.BaseType.ToString() ==”Survey”1234* 判斷是否為Announcement &#96;&#96;&#96;csharpList.BaseTemplate.ToString() &#x3D;&#x3D; &quot;Announcements&quot; 問卷 Survey 公告 Announcements 文件庫 DocumentLibrary 另外網路上查到各種清單的對照表，可以參考 : 清單對照表","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【SharePoint】VisualWebPart","slug":"【SharePoint】VisualWebPart","date":"2012-12-27T03:17:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2012/12/27/【SharePoint】VisualWebPart/","link":"","permalink":"https://toyo0103.github.io/2012/12/27/%E3%80%90SharePoint%E3%80%91VisualWebPart/","excerpt":"","text":"[![](http://1.bp.blogspot.com/-BbJDYNJ9yJQ/UNu49lR8hFI/AAAAAAAAAeA/ETeG2o2Gs4M/s640/111.png)](http://1.bp.blogspot.com/-BbJDYNJ9yJQ/UNu49lR8hFI/AAAAAAAAAeA/ETeG2o2Gs4M/s1600/111.png) 建立VisualWebPart(後面簡稱vwp)後會產生以下檔案結構 [![](http://4.bp.blogspot.com/-sj79ZvE6lH4/UNu5jeqCYrI/AAAAAAAAAeI/stuhIeBL11k/s1600/111.png)](http://4.bp.blogspot.com/-sj79ZvE6lH4/UNu5jeqCYrI/AAAAAAAAAeI/stuhIeBL11k/s1600/111.png) **.XML檔中可以設定vwp佈署後歸類在哪個群組裡面**[![](http://4.bp.blogspot.com/-Vv3Q5WgnzGo/UNu68vKX92I/AAAAAAAAAeg/l0j6pcw1oLY/s640/111.png)](http://4.bp.blogspot.com/-Vv3Q5WgnzGo/UNu68vKX92I/AAAAAAAAAeg/l0j6pcw1oLY/s1600/111.png) [![](http://4.bp.blogspot.com/-8K_6ifqFwTw/UNu7eFJb4gI/AAAAAAAAAeo/uMqpnmtiMNc/s320/111.png)](http://4.bp.blogspot.com/-8K_6ifqFwTw/UNu7eFJb4gI/AAAAAAAAAeo/uMqpnmtiMNc/s1600/111.png) **VWP的CS檔中可以增加可設定的參數**```csharp namespace ScinoPharm.EIP.vwpSurveys { [ToolboxItemAttribute(false)] public class vwpSurveys : WebPart { //增加可設定的參數 [Category(\"MySetting\"), Personalizable(PersonalizationScope.Shared), //共用設定 WebBrowsable(true), //是否顯示在面板上 WebDisplayName(\"來源清單名稱\"), WebDescription(\"請填寫Survey資料來源的清單名稱\") //描述 ] public string ListName&#123;get;set;&#125; //當您變更視覺 Web 組件專案項目時，Visual Studio 可能會自動更新此路徑 private const string _ascxPath = @&quot;~/_CONTROLTEMPLATES/ScinoPharm.EIP/vwpSurveys/vwpSurveysUserControl.ascx&quot;; protected override void CreateChildControls() &#123; Control control = Page.LoadControl(_ascxPath); ControlSkin.Add(control); &#125; &#125; } 123456789101112131415&lt;div class&#x3D;&quot;separator&quot; style&#x3D;&quot;clear: both; text-align: left;&quot;&gt;****&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;separator&quot; style&#x3D;&quot;clear: both; text-align: center;&quot;&gt;[![](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-vNWquvR2rzs&#x2F;UNu9Aq_nY_I&#x2F;AAAAAAAAAe4&#x2F;lNd-Ro9x2Z4&#x2F;s1600&#x2F;111.png)](http:&#x2F;&#x2F;4.bp.blogspot.com&#x2F;-vNWquvR2rzs&#x2F;UNu9Aq_nY_I&#x2F;AAAAAAAAAe4&#x2F;lNd-Ro9x2Z4&#x2F;s1600&#x2F;111.png)&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;separator&quot; style&#x3D;&quot;clear: both; text-align: left;&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;separator&quot; style&#x3D;&quot;clear: both; text-align: left;&quot;&gt;&lt;&#x2F;div&gt;**在UserControl中要抓到VWP的參數設定，需要透過以下的方法**&#96;&#96;&#96;csharppublic vwpSurveys SurveyParameter; protected void Page_Load(object sender, EventArgs e) &#123; if (!Page.IsPostBack) &#123; SurveyParameter &#x3D; this.Parent as vwpSurveys; &#125; &#125; ****","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【C#】TreeView 的 CheckBox打勾後自動POST BACK","slug":"【C-】TreeView-的-CheckBox打勾後自動POST-BACK","date":"2012-12-27T02:36:00.000Z","updated":"2022-08-09T13:36:17.085Z","comments":true,"path":"2012/12/27/【C-】TreeView-的-CheckBox打勾後自動POST-BACK/","link":"","permalink":"https://toyo0103.github.io/2012/12/27/%E3%80%90C-%E3%80%91TreeView-%E7%9A%84-CheckBox%E6%89%93%E5%8B%BE%E5%BE%8C%E8%87%AA%E5%8B%95POST-BACK/","excerpt":"","text":"ASP.NET中的TreeView有ontreenodecheckchanged的事件，但當你在TreeView上打勾時，卻不會觸發Post Back的效果 [![](http://2.bp.blogspot.com/-hIBTtd4zrrQ/UNu4XQV-SvI/AAAAAAAAAd4/wxCJqnyVB8Q/s1600/111.png)](http://2.bp.blogspot.com/-hIBTtd4zrrQ/UNu4XQV-SvI/AAAAAAAAAd4/wxCJqnyVB8Q/s1600/111.png) 查了一下，原來.Net會記住你目前TreeView的狀態，當有任何東西造成Post Back的時候(例如按按鈕)，就會觸發ontreenodecheckchanged的事件 所以如果想要CheckBox點擊時能即時的Post Back就要做一些小加工 先加一個按鈕，並請隱藏起來這裡需要特別注意不能直接用Visible=”false“將按鈕隱藏，否則ASP不會將這個按鈕真的Render出來。所以請用CSS的方式隱藏吧!! 透過JavaScript的方式(這邊利用JQuery撰寫)，偵測當CheckBox被點擊時去觸發我們隱藏起來的Button，透過這個Button達到Post Back的效果 這樣就會進到ontreenodecheckchanged的事件 [![](http://2.bp.blogspot.com/-qkdq-K0tGW0/UNu0IfXO4qI/AAAAAAAAAdk/Gt2D8z_Ijyw/s1600/111.png)](http://2.bp.blogspot.com/-qkdq-K0tGW0/UNu0IfXO4qI/AAAAAAAAAdk/Gt2D8z_Ijyw/s1600/111.png)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"}]},{"title":"【SharePoint】確認Web或List是否有權限讀取","slug":"【SharePoint】確認Web或List是否有權限讀取","date":"2012-12-26T10:14:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2012/12/26/【SharePoint】確認Web或List是否有權限讀取/","link":"","permalink":"https://toyo0103.github.io/2012/12/26/%E3%80%90SharePoint%E3%80%91%E7%A2%BA%E8%AA%8DWeb%E6%88%96List%E6%98%AF%E5%90%A6%E6%9C%89%E6%AC%8A%E9%99%90%E8%AE%80%E5%8F%96/","excerpt":"","text":"詳細可以參考這個網站 節錄摘要， if (oWeb.DoesUserHavePermissions(SPBasePermissions.ViewPages)) { SPList oList = oWeb.Lists[ListName]; if (oList.DoesUserHavePermissions(SPBasePermissions.ViewListItems)) { // some smart code } } 因為要先Get Web或是List的物件才能進行判斷，所以如果該使用者對該物件沒有權限，這樣寫可能會當掉，所以建議寫法如下 123456789101112131415161718192021SPUser User = SPContext.Current.Web.CurrentUser; //先記錄目前使用者SPSecurity.RunWithElevatedPrivileges(delegate &#123; //進行升權的動作 using (SPSite Site = new SPSite(SPContext.Current.Site.ID)) &#123; using (SPWeb Web = Site.OpenWeb(WebName)) &#123; //在將剛剛紀錄的使用者丟到Function進行權限的判斷 if(Web.DoesUserHavePermissions(User.LoginName,SPBasePermissions.ViewPages)) &#123; SPList List = Web.GetList(URL); if(List.DoesUserHavePermissions(User, SPBasePermissions.ViewPages)) &#123; HavePermission = true; &#125; &#125; &#125; &#125;&#125;); 或是 12345678910111213141516171819202122232425262728//如果不把SPSecurity.CatchAccessDeniedException改回正常狀況，Sharepoint網站會直接返回無權限的頁面//並停止執行接下來的程式private bool CheckPermission(SPWeb _web) &#123; Boolean catchException = SPSecurity.CatchAccessDeniedException; SPSecurity.CatchAccessDeniedException = false; try &#123; if (_web.DoesUserHavePermissions(currentUser.LoginName, SPBasePermissions.ViewPages)) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch &#123; return false; &#125; finally &#123; //reset the flag to original value SPSecurity.CatchAccessDeniedException = catchException; &#125;&#125;","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【SharePoint】讀取目前使用者的DispayName","slug":"【SharePoint】讀取目前使用者的DispayName","date":"2012-11-13T02:57:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2012/11/13/【SharePoint】讀取目前使用者的DispayName/","link":"","permalink":"https://toyo0103.github.io/2012/11/13/%E3%80%90SharePoint%E3%80%91%E8%AE%80%E5%8F%96%E7%9B%AE%E5%89%8D%E4%BD%BF%E7%94%A8%E8%80%85%E7%9A%84DispayName/","excerpt":"","text":"是DisplayName不是Account喔!! [![](http://2.bp.blogspot.com/-NaAuRmyrQd0/UKG2nwaZzcI/AAAAAAAAAOM/dE6rh8dC8PI/s1600/1.png)](http://2.bp.blogspot.com/-NaAuRmyrQd0/UKG2nwaZzcI/AAAAAAAAAOM/dE6rh8dC8PI/s1600/1.png)","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【SharePoint】在LayOut底下的資料夾寫入txt的Log檔","slug":"【SharePoint】在LayOut底下的資料夾寫入txt的Log檔","date":"2012-11-13T02:51:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2012/11/13/【SharePoint】在LayOut底下的資料夾寫入txt的Log檔/","link":"","permalink":"https://toyo0103.github.io/2012/11/13/%E3%80%90SharePoint%E3%80%91%E5%9C%A8LayOut%E5%BA%95%E4%B8%8B%E7%9A%84%E8%B3%87%E6%96%99%E5%A4%BE%E5%AF%AB%E5%85%A5txt%E7%9A%84Log%E6%AA%94/","excerpt":"","text":"我在佈署SharePoint專案時在LayOut資料夾底下放了一個Log的資料夾，打算在該資料夾寫txt的Log檔用，結構如下圖 首先要在Log資料夾裡下先隨便放個檔案，否則VS在佈署時發現該資料夾沒檔案就不會真的建那個該資料夾出來。 以下程式是抓到佈署完之後該資料夾的實體位置，並以一天一檔案的方式寫Log檔 [![](http://3.bp.blogspot.com/-Gjb8chCZLdk/UKG1rVrrveI/AAAAAAAAAOE/5F6qYNcbPg4/s1600/1.png)](http://3.bp.blogspot.com/-Gjb8chCZLdk/UKG1rVrrveI/AAAAAAAAAOE/5F6qYNcbPg4/s1600/1.png)","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【SharePoint】ListItem附加檔案的URL","slug":"【SharePoint】ListItem附加檔案的URL","date":"2012-11-13T02:41:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2012/11/13/【SharePoint】ListItem附加檔案的URL/","link":"","permalink":"https://toyo0103.github.io/2012/11/13/%E3%80%90SharePoint%E3%80%91ListItem%E9%99%84%E5%8A%A0%E6%AA%94%E6%A1%88%E7%9A%84URL/","excerpt":"","text":"當ListItem有附加檔案時，用以下方法來抓取該附檔的連結 [![](http://3.bp.blogspot.com/-4cMr5xgDNcY/UKGzLSCms9I/AAAAAAAAAN0/iUjTDRLCsTk/s1600/1.png)](http://3.bp.blogspot.com/-4cMr5xgDNcY/UKGzLSCms9I/AAAAAAAAAN0/iUjTDRLCsTk/s1600/1.png)","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【SharePoint】 佈署方式","slug":"【SharePoint】-佈署方式","date":"2012-11-01T07:18:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2012/11/01/【SharePoint】-佈署方式/","link":"","permalink":"https://toyo0103.github.io/2012/11/01/%E3%80%90SharePoint%E3%80%91-%E4%BD%88%E7%BD%B2%E6%96%B9%E5%BC%8F/","excerpt":"","text":"參考資料 透過命令提示字元佈署 stsadn 路徑 ```htmlC:\\Program Files\\Common Files\\Microsoft Shared\\Web Server Extensions\\14\\BIN 12345* 部署 * 加入Solution &#96;&#96;&#96;htmlstsadm -o addSolution –filename [xxxx.wsp] * 部署Solution ```html stsadm -o deploysolution –name [xxxx.wsp] -immediate –url [SiteURL] -allowGacDeployment 1234* 移除 * 解除Solution&#96;&#96;&#96;htmlstsadm -o retractsolution –name [xxxx.wsp] -immediate -url [SiteURL] * 移除Solution```html stsadm -o deletesolution –name [xxxx.wsp] 1234* 更新 * 如果Solution已經在網站上使用，就可以使用下面一句命令就可以更新，不用先執行上面先解除再移除然後再重新部署 &#96;&#96;&#96;htmlstsadm -o upgradesolution –name [xxxx.wsp] –filename [xxxx.wsp] -immediate -allowgacdeployment 透過SharePoint管理介面更新佈署 部署 * 加入Solution ```html Add-SPSolution C:\\xxx.wsp 123 * 安裝Solution &#96;&#96;&#96;htmlInstall-SPSolution -Identity xxx.wsp -WebApplication http:&#x2F;&#x2F;xxxx.com.tw -GACDeployment 更新 ```htmlUpdate-SPSolution -Identity xxx.wsp -LiteralPath C:\\xxx.wsp -GACDeployment 123* Restore &#96;&#96;&#96;htmlrestore-spsite -identity http:&#x2F;&#x2F;xxx.com.tw -path d:\\xxx.bak -force","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【SharePoint】 取清單的值","slug":"【SharePoint】-取清單的值","date":"2012-10-29T06:55:00.000Z","updated":"2022-08-09T13:36:17.092Z","comments":true,"path":"2012/10/29/【SharePoint】-取清單的值/","link":"","permalink":"https://toyo0103.github.io/2012/10/29/%E3%80%90SharePoint%E3%80%91-%E5%8F%96%E6%B8%85%E5%96%AE%E7%9A%84%E5%80%BC/","excerpt":"","text":"1.先開啟sharepoint site2.開啟web3.選擇清單4.清單裡面item要撈出哪幾個欄位 [![](http://4.bp.blogspot.com/-h3eeHiTjNpM/UI4oUiZsetI/AAAAAAAAANM/bOXEld8V_7E/s1600/1.png)](http://4.bp.blogspot.com/-h3eeHiTjNpM/UI4oUiZsetI/AAAAAAAAANM/bOXEld8V_7E/s1600/1.png) ===================================================================== sharepoint在撈清單時，預設用使用者的權限去取得該清單的item 但有時候該清單需要更高的權限才能存取，這時候就要先做升權的動作，如紅框處 [![](http://3.bp.blogspot.com/-cZafIYUsPtU/UKGvm9LbLjI/AAAAAAAAANg/Mc0HN0vuuLc/s1600/1.png)](http://3.bp.blogspot.com/-cZafIYUsPtU/UKGvm9LbLjI/AAAAAAAAANg/Mc0HN0vuuLc/s1600/1.png) 紫色框框處為清單的搜尋語法，但還在摸索中，先做個簡單的紀錄!!","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【JavaScript】判斷檔案是否存在","slug":"【JavaScript】判斷檔案是否存在","date":"2012-10-18T16:46:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2012/10/19/【JavaScript】判斷檔案是否存在/","link":"","permalink":"https://toyo0103.github.io/2012/10/19/%E3%80%90JavaScript%E3%80%91%E5%88%A4%E6%96%B7%E6%AA%94%E6%A1%88%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8/","excerpt":"","text":"最近用IE判斷某檔案是否存在，路徑分別有以下兩種情況相對路徑 : %appdata%\\Microsoft\\Windows\\Start Menu\\Programs\\Accessories\\Notepad.lnk絕對路徑 :&nbsp;C:\\xxx\\xxxx\\Microsoft\\Windows\\Start Menu\\Programs\\Accessories\\Notepad.lnk 原本只是單純使用ActiveXObject(‘Scripting.FileSystemObject’)的FileExists來判斷該檔案是否存在 在絕對路徑下都很OK，但這個function無法判斷相對路徑，所以必須先做一個轉換為絕對路徑的動作var objShell = new ActiveXObject(“Wscript.Shell”);&nbsp; objShell.ExpandEnvironmentStrings(“%appdata%\\Microsoft\\Windows\\StartMenu\\Programs\\Accessories\\Notepad.lnk”); 再丟給FileExists來判斷檔案是否存在，即大功告成。 全部code 12345678910111213var objnav = navigator;var OsVersion = objnav.appVersion;var fso = new ActiveXObject(&#x27;Scripting.FileSystemObject&#x27;);var objShell = new ActiveXObject(&quot;Wscript.Shell&quot;);strfolderpath = objShell.ExpandEnvironmentStrings(&quot;%appdata%\\\\Microsoft\\\\Windows\\\\StartMenu\\\\Programs\\\\Accessories\\\\Notepad.lnk&quot;);if (fso.FileExists(strfolderpath))&#123; alert(&#x27;絕對路徑有&#x27;);&#125;else&#123; alert(&#x27;絕對路徑沒有&#x27;); &#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://toyo0103.github.io/tags/JavaScript/"}]},{"title":"VM上網設定","slug":"VM上網設定","date":"2012-10-17T02:36:00.000Z","updated":"2022-08-09T13:36:17.079Z","comments":true,"path":"2012/10/17/VM上網設定/","link":"","permalink":"https://toyo0103.github.io/2012/10/17/VM%E4%B8%8A%E7%B6%B2%E8%A8%AD%E5%AE%9A/","excerpt":"","text":"連結有詳細介紹!! &nbsp; 終於可以安心在VM裡面開發SharePoint了 Windows7中的VMWare網路設定 以下是摘錄 首先開啟網路共用中心 &gt; 變更介面卡設定 &gt; 找到VMnet1然後記住它的名稱 找到目前的連線(此圖為無線網路連線)&gt; 右鍵點選內容 &gt; 切到”共用”頁籤&gt; 然後把共用都打勾並選擇剛剛那個VM的連線與他共享 接著點選VMnet1右鍵 &gt; 內容 &gt; TCP/IPV4 &gt;設定如下 執行 VMWare 及虛擬系統，例如：Windows XP，開啟虛擬系統的「網蔎連線」，在「區域網路」上按滑鼠右鍵，選擇「內容」 最後在 VMWare 的「VM \\ setting」中將「Hardware \\ Ethenet」設定為「Host-Only」","categories":[],"tags":[{"name":"VM","slug":"VM","permalink":"https://toyo0103.github.io/tags/VM/"}]},{"title":"【SharePoint】安裝筆記","slug":"【SharePoint】安裝筆記","date":"2012-10-16T08:54:00.000Z","updated":"2022-08-09T13:36:17.093Z","comments":true,"path":"2012/10/16/【SharePoint】安裝筆記/","link":"","permalink":"https://toyo0103.github.io/2012/10/16/%E3%80%90SharePoint%E3%80%91%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/","excerpt":"","text":"1.先安裝Window server 2008 R2 2.啟動Active Directory網域服務 3.啟動DC 4.新增兩名Domain的使用者 EX：sps_service , sps_admin [![](http://1.bp.blogspot.com/-pdH93mRSZ6U/UHz7sukxtvI/AAAAAAAAALE/kVexakOlhXY/s1600/11.png)](http://1.bp.blogspot.com/-pdH93mRSZ6U/UHz7sukxtvI/AAAAAAAAALE/kVexakOlhXY/s1600/11.png)[![](http://1.bp.blogspot.com/-23V72MV9S64/UHz9Wwu1EeI/AAAAAAAAALM/mo-DmwO5fbo/s1600/11.png)](http://1.bp.blogspot.com/-23V72MV9S64/UHz9Wwu1EeI/AAAAAAAAALM/mo-DmwO5fbo/s1600/11.png) 之後再將兩個帳號加到Builtin的administrator的成員之中 [![](http://4.bp.blogspot.com/-naehp0j1yl8/UHz96Ob1eDI/AAAAAAAAALU/b_CzKkYeyfM/s1600/11.png)](http://4.bp.blogspot.com/-naehp0j1yl8/UHz96Ob1eDI/AAAAAAAAALU/b_CzKkYeyfM/s1600/11.png) 接下來的安裝都用sps_admin來做5.安裝SQL Server 2008 R2&nbsp; &nbsp;將帳戶指定給sps_service [![](http://2.bp.blogspot.com/-bf65-cgmngg/UH0IyzgAmSI/AAAAAAAAALs/1NXycYusVwc/s1600/11.png)](http://2.bp.blogspot.com/-bf65-cgmngg/UH0IyzgAmSI/AAAAAAAAALs/1NXycYusVwc/s1600/11.png) 6.安裝SharePointService&nbsp; &nbsp;先點選安裝軟體先決條件 [![](http://1.bp.blogspot.com/-lQXiOG1zWlA/UH0UVHgAi7I/AAAAAAAAAME/VtB6ot6gQFY/s1600/11.png)](http://1.bp.blogspot.com/-lQXiOG1zWlA/UH0UVHgAi7I/AAAAAAAAAME/VtB6ot6gQFY/s1600/11.png) 過程中如果有問題的話，可以參考提示另行下載元件安裝 [![](http://1.bp.blogspot.com/-9tHDhQmuN54/UH0Us5D-7SI/AAAAAAAAAMM/TvIjFqbK7CE/s1600/11.png)](http://1.bp.blogspot.com/-9tHDhQmuN54/UH0Us5D-7SI/AAAAAAAAAMM/TvIjFqbK7CE/s1600/11.png)元件表 [![](http://4.bp.blogspot.com/-Go4DUvNwuLo/UH0ZDeWE2bI/AAAAAAAAAMk/yG6Z_ePVICY/s1600/11.png)](http://4.bp.blogspot.com/-Go4DUvNwuLo/UH0ZDeWE2bI/AAAAAAAAAMk/yG6Z_ePVICY/s1600/11.png) 7.正式安裝SharePoint &nbsp; &nbsp;選擇新的伺服器陣列 &gt; 設定機器名稱 &gt; 輸入使用者名稱與密碼 [![](http://1.bp.blogspot.com/-p-X5WlDPa0E/UH0ZgKYDUFI/AAAAAAAAAMs/8dSN3t3oWiM/s1600/1-1.png)](http://1.bp.blogspot.com/-p-X5WlDPa0E/UH0ZgKYDUFI/AAAAAAAAAMs/8dSN3t3oWiM/s1600/1-1.png) 指定Port [![](http://2.bp.blogspot.com/-Xyvy6bqdUBA/UH0Z3-axdmI/AAAAAAAAAM0/NHBNBdBTnrU/s1600/1-2.png)](http://2.bp.blogspot.com/-Xyvy6bqdUBA/UH0Z3-axdmI/AAAAAAAAAM0/NHBNBdBTnrU/s1600/1-2.png) 之後再設定頂層網站就大功告成了!!","categories":[],"tags":[{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"}]},{"title":"【JavaScript】showModalDialog運用","slug":"【JavaScript】showModalDialog運用","date":"2012-10-16T06:09:00.000Z","updated":"2022-08-09T13:36:17.087Z","comments":true,"path":"2012/10/16/【JavaScript】showModalDialog運用/","link":"","permalink":"https://toyo0103.github.io/2012/10/16/%E3%80%90JavaScript%E3%80%91showModalDialog%E9%81%8B%E7%94%A8/","excerpt":"","text":"最近公司專案有使用到IE的showModalDialog，所以做一下筆記!! 叫用方式： 12345function openWindow(url) &#123; var Feature = &#x27;dialogWidth:850px;dialogHeight:600px;status:0;help:0;&#x27;; var showModalObj = window.showModalDialog(url, window, Feature)&#125; 各項參數請參考MSDN文件:參數設定 我的是寫個function,如要使用時將url傳進來。其中第二個參數window是將這這個視窗傳遞給開啟的showModalDialog，之後方便showModalDialog叫用母視窗的function或是變數。 例如我在母視窗有個alertMe的function 1234function alertMe() &#123; alert(&#x27;我是母視窗的一個function&#x27;);&#125; 我只要在showModalDialog視窗中使用&nbsp;window.dialogArguments.alertMe(); ，就可以直接到母視窗的function。 另外showModalDialog無論是postback或是location到別的網址都會開啟新視窗，所以在&lt;head&gt;裡面加上 &lt;head&gt; &lt;base target=\"_self\" &gt; &lt;/head&gt; 這樣目標就會是showModalDialog自己。 為了解決showModalDialog因為Cache的關係只有第一個會PostBack的問題，請加入以下的code在page_load事件，讓每次開啟modal dialog都會PostBack 12345678if (!Page.IsPostBack) &#123; //為了解決showModalDialog常常會讀到舊頁面的問題 Page.Response.Expires = -1; Page.Response.AddHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); Page.Response.AddHeader(&quot;cache-control&quot;,&quot;no-store&quot;);&#125; 或是在Head裡面加上 ```html 1234567**showModalDialog回傳True或false給母頁面的方法**showModalDialog頁面寫以下Javascript &#96;&#96;&#96;jswindow.returnValue &#x3D; false; 母頁面寫以下Javascript 123456789if (window.showModalDialog(url, window, set))&#123; alert(&#x27;true&#x27;);&#125;else&#123; alert(&#x27;false&#x27;);&#125; showModalDialog回傳值的方式showModalDialog頁面寫以下Javascript： 12345678910function GoReturnValue() &#123; //宣告一個Object var ReturnObj = new Object(); //給這個Object屬性值 ReturnObj.codeValue = &quot;i&#x27;am return value&quot;; //將這個Object回傳 window.returnValue = ReturnObj; window.close();&#125; 母頁面取值方式： 1234var returnObj = window.showModalDialog(url, window, Feature);//取得這個Object的屬性值，在這邊應該會得到&quot;i&#x27;am return value&quot;alert(returnObj .codeValue);","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://toyo0103.github.io/tags/JavaScript/"}]}],"categories":[{"name":"領域驅動設計與.Net Core","slug":"領域驅動設計與-Net-Core","permalink":"https://toyo0103.github.io/categories/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"},{"name":"工程師的那些事","slug":"工程師的那些事","permalink":"https://toyo0103.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/categories/LeetCode/"},{"name":"學習MVC","slug":"學習MVC","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92MVC/"},{"name":"VSTS建置CI-CD","slug":"VSTS建置CI-CD","permalink":"https://toyo0103.github.io/categories/VSTS%E5%BB%BA%E7%BD%AECI-CD/"},{"name":"學習單元測試","slug":"學習單元測試","permalink":"https://toyo0103.github.io/categories/%E5%AD%B8%E7%BF%92%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/"}],"tags":[{"name":"Cache","slug":"Cache","permalink":"https://toyo0103.github.io/tags/Cache/"},{"name":"dotnet core","slug":"dotnet-core","permalink":"https://toyo0103.github.io/tags/dotnet-core/"},{"name":"DDD","slug":"DDD","permalink":"https://toyo0103.github.io/tags/DDD/"},{"name":"讀書心得","slug":"讀書心得","permalink":"https://toyo0103.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"},{"name":"領域驅動設計與 .Net Core","slug":"領域驅動設計與-Net-Core","permalink":"https://toyo0103.github.io/tags/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88%E8%88%87-Net-Core/"},{"name":"工程師的那些事","slug":"工程師的那些事","permalink":"https://toyo0103.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"CQRS","slug":"CQRS","permalink":"https://toyo0103.github.io/tags/CQRS/"},{"name":"wireshark","slug":"wireshark","permalink":"https://toyo0103.github.io/tags/wireshark/"},{"name":"clumsy","slug":"clumsy","permalink":"https://toyo0103.github.io/tags/clumsy/"},{"name":"Docker","slug":"Docker","permalink":"https://toyo0103.github.io/tags/Docker/"},{"name":"C#","slug":"C","permalink":"https://toyo0103.github.io/tags/C/"},{"name":"Async","slug":"Async","permalink":"https://toyo0103.github.io/tags/Async/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://toyo0103.github.io/tags/RabbitMQ/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://toyo0103.github.io/tags/CI-CD/"},{"name":"powershell","slug":"powershell","permalink":"https://toyo0103.github.io/tags/powershell/"},{"name":"microservice","slug":"microservice","permalink":"https://toyo0103.github.io/tags/microservice/"},{"name":"service discovery","slug":"service-discovery","permalink":"https://toyo0103.github.io/tags/service-discovery/"},{"name":"NATS","slug":"NATS","permalink":"https://toyo0103.github.io/tags/NATS/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://toyo0103.github.io/tags/LeetCode/"},{"name":"精神時光屋","slug":"精神時光屋","permalink":"https://toyo0103.github.io/tags/%E7%B2%BE%E7%A5%9E%E6%99%82%E5%85%89%E5%B1%8B/"},{"name":"SQL","slug":"SQL","permalink":"https://toyo0103.github.io/tags/SQL/"},{"name":"aws","slug":"aws","permalink":"https://toyo0103.github.io/tags/aws/"},{"name":"windows container","slug":"windows-container","permalink":"https://toyo0103.github.io/tags/windows-container/"},{"name":"centos","slug":"centos","permalink":"https://toyo0103.github.io/tags/centos/"},{"name":"jenkins","slug":"jenkins","permalink":"https://toyo0103.github.io/tags/jenkins/"},{"name":"hexo","slug":"hexo","permalink":"https://toyo0103.github.io/tags/hexo/"},{"name":".Net","slug":"Net","permalink":"https://toyo0103.github.io/tags/Net/"},{"name":"日文學習","slug":"日文學習","permalink":"https://toyo0103.github.io/tags/%E6%97%A5%E6%96%87%E5%AD%B8%E7%BF%92/"},{"name":"神奇事件","slug":"神奇事件","permalink":"https://toyo0103.github.io/tags/%E7%A5%9E%E5%A5%87%E4%BA%8B%E4%BB%B6/"},{"name":"英文學習","slug":"英文學習","permalink":"https://toyo0103.github.io/tags/%E8%8B%B1%E6%96%87%E5%AD%B8%E7%BF%92/"},{"name":"AWS","slug":"AWS","permalink":"https://toyo0103.github.io/tags/AWS/"},{"name":"Lambda","slug":"Lambda","permalink":"https://toyo0103.github.io/tags/Lambda/"},{"name":"生產力","slug":"生產力","permalink":"https://toyo0103.github.io/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"},{"name":"其它","slug":"其它","permalink":"https://toyo0103.github.io/tags/%E5%85%B6%E5%AE%83/"},{"name":"Entity Framework","slug":"Entity-Framework","permalink":"https://toyo0103.github.io/tags/Entity-Framework/"},{"name":"AutoFac","slug":"AutoFac","permalink":"https://toyo0103.github.io/tags/AutoFac/"},{"name":"MVC教學","slug":"MVC教學","permalink":"https://toyo0103.github.io/tags/MVC%E6%95%99%E5%AD%B8/"},{"name":"演算法","slug":"演算法","permalink":"https://toyo0103.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/"},{"name":"資料結構","slug":"資料結構","permalink":"https://toyo0103.github.io/tags/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"},{"name":"Azure","slug":"Azure","permalink":"https://toyo0103.github.io/tags/Azure/"},{"name":"VSTS","slug":"VSTS","permalink":"https://toyo0103.github.io/tags/VSTS/"},{"name":"Selenium","slug":"Selenium","permalink":"https://toyo0103.github.io/tags/Selenium/"},{"name":"RazorEngine","slug":"RazorEngine","permalink":"https://toyo0103.github.io/tags/RazorEngine/"},{"name":"AutoMapper","slug":"AutoMapper","permalink":"https://toyo0103.github.io/tags/AutoMapper/"},{"name":"MVC","slug":"MVC","permalink":"https://toyo0103.github.io/tags/MVC/"},{"name":"Tools","slug":"Tools","permalink":"https://toyo0103.github.io/tags/Tools/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"https://toyo0103.github.io/tags/Unit-Test/"},{"name":"FluentValidation","slug":"FluentValidation","permalink":"https://toyo0103.github.io/tags/FluentValidation/"},{"name":"Regular Expression","slug":"Regular-Expression","permalink":"https://toyo0103.github.io/tags/Regular-Expression/"},{"name":"WebAPI","slug":"WebAPI","permalink":"https://toyo0103.github.io/tags/WebAPI/"},{"name":"IIS","slug":"IIS","permalink":"https://toyo0103.github.io/tags/IIS/"},{"name":"LINQ","slug":"LINQ","permalink":"https://toyo0103.github.io/tags/LINQ/"},{"name":"Swagger","slug":"Swagger","permalink":"https://toyo0103.github.io/tags/Swagger/"},{"name":"QuadTree","slug":"QuadTree","permalink":"https://toyo0103.github.io/tags/QuadTree/"},{"name":"Refactor","slug":"Refactor","permalink":"https://toyo0103.github.io/tags/Refactor/"},{"name":"FluentAssertions","slug":"FluentAssertions","permalink":"https://toyo0103.github.io/tags/FluentAssertions/"},{"name":"Config","slug":"Config","permalink":"https://toyo0103.github.io/tags/Config/"},{"name":"webconfig","slug":"webconfig","permalink":"https://toyo0103.github.io/tags/webconfig/"},{"name":"LINQ TO SQL","slug":"LINQ-TO-SQL","permalink":"https://toyo0103.github.io/tags/LINQ-TO-SQL/"},{"name":"JSON","slug":"JSON","permalink":"https://toyo0103.github.io/tags/JSON/"},{"name":"Android","slug":"Android","permalink":"https://toyo0103.github.io/tags/Android/"},{"name":"ios","slug":"ios","permalink":"https://toyo0103.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://toyo0103.github.io/tags/swift/"},{"name":"Xamarin","slug":"Xamarin","permalink":"https://toyo0103.github.io/tags/Xamarin/"},{"name":"Excel","slug":"Excel","permalink":"https://toyo0103.github.io/tags/Excel/"},{"name":"CSS","slug":"CSS","permalink":"https://toyo0103.github.io/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://toyo0103.github.io/tags/HTML/"},{"name":"ASP","slug":"ASP","permalink":"https://toyo0103.github.io/tags/ASP/"},{"name":"FormsAuthentication","slug":"FormsAuthentication","permalink":"https://toyo0103.github.io/tags/FormsAuthentication/"},{"name":"JQuery","slug":"JQuery","permalink":"https://toyo0103.github.io/tags/JQuery/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://toyo0103.github.io/tags/JavaScript/"},{"name":"GridView","slug":"GridView","permalink":"https://toyo0103.github.io/tags/GridView/"},{"name":"SharePoint","slug":"SharePoint","permalink":"https://toyo0103.github.io/tags/SharePoint/"},{"name":"Git","slug":"Git","permalink":"https://toyo0103.github.io/tags/Git/"},{"name":"VM","slug":"VM","permalink":"https://toyo0103.github.io/tags/VM/"}]}